<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.1" />
<title>Python-Screen-Stack-Manager.pssm API documentation</title>
<meta name="description" content="" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>Python-Screen-Stack-Manager.pssm</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#!/usr/bin/env python
import sys
import os
import json
import threading
# Load Pillow
from PIL import Image, ImageDraw, ImageFont
from PIL.ImageOps import invert as PILInvert
from copy import deepcopy

############################ - VARIABLES - #####################################
lastUsedId=0

PATH_TO_PSSM = os.path.dirname(os.path.abspath(__file__))
DEFAULT_FONT = os.path.join(PATH_TO_PSSM,&#34;fonts&#34;, &#34;Merriweather-Regular.ttf&#34;)
DEFAULT_FONTBOLD = os.path.join(PATH_TO_PSSM,&#34;fonts&#34;, &#34;Merriweather-Bold.ttf&#34;)
STANDARD_FONT_SIZE = &#34;h*0.036&#34;


# Constants for the on-screen-keyboard:
DEFAULT_KEYMAP_PATH_STANDARD = os.path.join(PATH_TO_PSSM,&#34;config&#34;, &#34;default-keymap-en_us.json&#34;)
DEFAULT_KEYMAP_PATH_CAPS         = os.path.join(PATH_TO_PSSM,&#34;config&#34;, &#34;default-keymap-en_us_CAPS.json&#34;)
DEFAULT_KEYMAP_PATH_ALT      = os.path.join(PATH_TO_PSSM,&#34;config&#34;, &#34;default-keymap-en_us_ALT.json&#34;)
DEFAULT_KEYMAP_PATH = {
        &#39;standard&#39;      : DEFAULT_KEYMAP_PATH_STANDARD,
        &#39;caps&#39;          : DEFAULT_KEYMAP_PATH_CAPS,
        &#39;alt&#39;           : DEFAULT_KEYMAP_PATH_ALT
}

KTstandardChar   = 0
KTcarriageReturn = 1
KTbackspace      = 2
KTdelete         = 3
KTcapsLock       = 4
KTcontrol        = 5
KTalt            = 6


############################# - One lines - ####################################
def returnFalse(*args): return False

############################# - StackManager    - ##############################
class PSSMScreen:
        &#34;&#34;&#34;
        This is the class which handles most of the logic.

        Args:
                deviceName (str): &#34;Kobo&#34; for Kobo ereaders (and probably all FBInk supported devices)
                name (str): The name of the class instance (deprecated, I will eventually remove it)
                stack (list): Do not use it unless you know what you are doing. It is the list of all the pssm Elements which are on the screen
                isInverted (bool)

        Example of usage:
                screen = pssm.PSSMScreen(&#34;Kobo&#34;,&#34;Main&#34;))

        &#34;&#34;&#34;
        def __init__(
                        self,
                        deviceName,
                        name=&#34;screen&#34;,
                        stack=[],
                        isInverted=False
                ):
                if deviceName == &#34;Kobo&#34;:
                        import devices.kobo.device as pssm_device
                else:
                        import devices.emulator.device as pssm_device
                self.device = pssm_device
                self.colorType = self.device.colorType
                self.width = self.device.screen_width
                self.height = self.device.screen_height
                self.view_width = self.device.view_width
                self.view_height = self.device.view_height
                self.w_offset = self.device.w_offset
                self.h_offset = self.device.h_offset
                self.area = [(0,0),(self.view_width,self.view_height)]
                self.name = name
                self.stack = stack
                self.isInverted = isInverted
                self.isInputThreadStarted = False
                self.lastX = -1
                self.lastY = -1
                self.osk = None
                self.onKeyPress = None
                self.isKeyboardShown = False

        def findEltWithId(self,myElementId,stack=None):
                &#34;&#34;&#34;
                Returns the element which has such an ID.
                Avoid using this function as much as possible, as it is really not Performance-friendly
                (Recursive search through all the elements of the stack)
                And anyway there is no reason why you should use it.
                &#34;&#34;&#34;
                if stack == None:
                        stack = self.stack
                for elt in stack:
                        if elt.id == myElementId:
                                return elt
                        elif elt.isLayout:
                                layoutEltList = elt.createEltList()
                                search = self.findEltWithId(myElementId,stack=layoutEltList)
                                if search != None:
                                        return search
                return None

        def printStack(self,area=None):
                &#34;&#34;&#34;
                Prints the stack Elements in the stack order
                If a area is set, then, we only display
                the part of the stack which is in this area
                &#34;&#34;&#34;
                #TODO : Must be retought to work with the new nested structure
                #TODO : Must honor the &#39;area&#39; argument
                # for now it will just reprint the whole stack
                white = get_Color(&#34;white&#34;,self.colorType)
                placeholder = Image.new(self.colorType, (self.width, self.height), color=white)
                for elt in self.stack:
                        [(x,y),(w,h)] = elt.area
                        placeholder.paste(elt.imgData, (x,y))
                [(x,y),(w,h)] = self.area
                self.device.print_pil(placeholder,x, y, w, h, isInverted=self.isInverted)

        def getPartialEltImg(self,elt,rectIntersection):
                &#34;&#34;&#34;
                Returns a PIL image of the the interesection of the Element image and the
                rectangle coordinated given as parameter.
                        elt : a PSSM Element
                        rectIntersection : a [[x1,y1],[x2,y2]] array
                &#34;&#34;&#34;
                #TODO : MUST HONOR INVERSION
                # We crop and print a part of the Element
                # First, lets make a PILLOW Element:
                [(x,y),(w,h)] = elt.area
                img = deepcopy(elt.imgData)
                # Then, lets crop it:
                img = img.crop((rectIntersection[0][0]-x, rectIntersection[0][1]-y, rectIntersection[1][0]-x, rectIntersection[1][1]-y))
                if elt.isInverted:
                        inverted_img = PILInvert(img)
                        return inverted_img
                else:
                        return img

        def simplePrintElt(self,myElement,skipGeneration = False):
                &#34;&#34;&#34;
                Prints the Element without adding it to the stack.
                Args:
                        myElement (PSSM Element): The element you want to display
                        skipGeneration (bool): Do you want to regenerate the image?
                &#34;&#34;&#34;
                if not skipGeneration:
                        # First, the element must be generated
                        myElement.generator()
                # Then, we print it
                [(x,y),(w,h)] = myElement.area
                # What follows is a Workaround :
                # TODO : this Workaround must be investigated
                if not myElement.isLayout:
                        w += 1
                        h += 1
                self.device.print_pil(myElement.imgData,x, y, w, h, isInverted=myElement.isInverted)

        def createCanvas(self,color=&#34;white&#34;):
                &#34;&#34;&#34;
                (Deprecated)
                Creates a white Element at the bottom of the stack, displays it while refreshing the screen.
                &#34;&#34;&#34;
                color = get_Color(color,self.colorType)
                img = Image.new(self.colorType, (self.width,self.height), color=color)
                background = Static(img,0,0,name=&#34;Canvas&#34;)
                self.addElt(background)

        def addElt(self,myElement,skipPrint=False,skipRegistration=False):
                &#34;&#34;&#34;
                Adds Element to the stack and prints it
                        myElement (PSSM Element): The Element you want to add
                        skipPrint (bool): True if you don&#39;t want to update the screen
                        skipRegistration (bool): True if you don&#39;t want to add the Element to the stack
                &#34;&#34;&#34;
                for i in range(len(self.stack)):
                        elt=self.stack[i]
                        if elt.id == myElement.id:
                                # There is already an Element in the stack with the same ID.
                                # Let&#39;s update the Element in the stack
                                if not skipPrint:
                                        self.stack[i] = myElement
                                        self.printStack(area=myElement.area)
                                break   #The Element is already in the stack
                else:
                        # the Element is not already in the stack
                        if not skipRegistration:
                                # We append the element to the stack
                                myElement.parentPSSMScreen = self
                                self.stack.append(myElement)
                                if not skipPrint:
                                        if self.isKeyboardShown:
                                                #TODO : make it faster, we only need to display the image behind the keyboard, not reprint everything
                                                myElement.generator()
                                                self.printStack(area=myElement.area)
                                        else:
                                                #No keyboard on the horizon, let&#39;s do it
                                                self.simplePrintElt(myElement)

        def removeElt(self,elt=None,eltid=None,skipPrint=False):
                &#34;&#34;&#34;
                Removes the Element from the stack and hides it from the screen
                &#34;&#34;&#34;
                if elt:
                        self.stack.remove(elt)
                        if not skipPrint:
                                self.printStack(area=elt.area)
                elif eltid :
                        elt = self.findEltWithId(myElementId)
                        if elt:
                                self.stack.remove(elt)
                                if not skipPrint:
                                        self.printStack(area=elt.area)
                else:
                        print(&#39;No element given&#39;)

        def getTagList(self):
                &#34;&#34;&#34;
                Returns the set of all tags from all Elements in the stack
                &#34;&#34;&#34;
                tags={}
                for elt in self.stack:
                        tags.update(elt.tags)
                return tags

        def removeAllWithTag(self,tag):
                &#34;&#34;&#34;
                Removes every Element from the stack which have the specified tag
                &#34;&#34;&#34;
                stackCopy = deepcopy(self.stack) #It is unsage to loop through a mutable list which is being edited afterwards : some items are skipped
                for elt in stackCopy:
                        if tag in elt.tags:
                                self.removeElt(elt.id,skipPrint=True,weAlreadyHaveTheElt=elt)
                #Then we reprint the whole screen (yeah, the *whole* screen... Performance is not our goal)
                self.printStack()

        def invertAllWithTag(self,tag,invertDuration=-1):
                &#34;&#34;&#34;
                Removes all the Element which have a specific tag
                &#34;&#34;&#34;
                stackCopy = deepcopy(self.stack) #It is unsage to loop through a mutable list which is being edited afterwards : some items are skipped
                for elt in stackCopy:
                        if tag in elt.tags:
                                self.invertElt(myElementId=elt.id,invertDuration=-1,skipPrint=True)
                #Then we reprint the whole screen (yeah, the *whole* screen... Performance is not our goal)
                self.printStack()
                # If an invert duration is given, then start a timer to go back to the original state
                if invertDuration&gt;0:
                        threading.Timer(invertDuration,self.invertAllWithTag,[tag,-1]).start()

        def getStackLevel(self,myElementId):
                elt = self.findEltWithId(myElementId)
                return self.stack.index(elt)

        def setStackLevel(self,myElementId,stackLevel=&#34;last&#34;):
                &#34;&#34;&#34;
                Set the position of said Element
                Then prints every Element above it (including itself)
                &#34;&#34;&#34;
                #TODO : Must be able to accept another stackLevel
                if stackLevel==&#34;last&#34; or stackLevel==-1:
                        stackLevel=len(self.stack)
                        elt = self.findEltWithId(myElementId)
                        self.removeElt(myElementId,skipPrint=True)
                        self.stack.insert(stackLevel,elt)
                        self.printStack(area=[elt.xy,elt.xy2])
                        return True

        def invertElt(self,myElementId,invertDuration=-1,skipPrint=False):
                &#34;&#34;&#34;
                Inverts an Element
                &gt; myElementId
                &gt; invertDuration (int) : -1 or 0 if permanent, else an integer
                &#34;&#34;&#34;
                myElement = self.findEltWithId(myElementId)
                if myElement==None:
                        return False
                # First, let&#39;s get the Element&#39;s initial inverted state
                Element_initial_state = bool(myElement.isInverted)
                # Then, we change the Element&#39;s state
                myElement.setInverted(not Element_initial_state)
                if not skipPrint:
                        # Then we print the inverted version
                        self.printStack(skipEltId=None, area=myElement.area)
                # Then, if an invertDuration is given, we setup a timer to go back to the original state
                if invertDuration and invertDuration&gt;0:
                        #Then, we start a timer to set it back to its intial state
                        threading.Timer(invertDuration,myElement.setInverted,[Element_initial_state]).start()
                        threading.Timer(invertDuration,self.invertElt,[myElementId,-1]).start()

        def invertArea(self,area,invertDuration,isInverted=False):
                &#34;&#34;&#34;
                Inverts an area
                &#34;&#34;&#34;
                # TODO: To be tested
                initial_mode = isInverted
                self.device.do_screen_refresh(
                        isInverted      = not isInverted,
                        area            = area,
                        isPermanent     = False,
                        isFlashing      = False,
                        w_offset        = self.w_offset,
                        h_offset        = self.h_offset
                )
                if invertDuration&gt;0:
                        # Now we call this funcion, without starting a timer
                        # And the screen is now in an opposite state as the initial one
                        threading.Timer(invertDuration,self.invertArea,[area,-1,not initial_mode]).start()
                return True

        def invert(self):
                &#34;&#34;&#34;
                Inverts the whole screen
                &#34;&#34;&#34;
                self.isInverted = not self.isInverted
                self.device.do_screen_refresh(self.isInverted)
                return True

        def refresh(self):
                &#34;&#34;&#34;
                Refreshes the screeen
                &#34;&#34;&#34;
                self.device.do_screen_refresh()
                return True

        def clear(self):
                &#34;&#34;&#34;
                Clears the screen
                &#34;&#34;&#34;
                self.device.do_screen_clear()
                return True

        def convertDimension(self,dimension):
                if isinstance(dimension,int):
                        return dimension
                else:
                        t  = dimension[0]
                        op = dimension[1:]
                        if t == &#34;p&#34;:
                                return int(eval(&#34;1&#34; + op))
                        elif t== &#34;w&#34;:
                                return int(eval(str(self.width) + op))
                        elif t== &#34;h&#34;:
                                return int(eval(str(self.height) + op))
                        else:
                                return dimension

        def OSKInit(
                        self,
                        onKeyPress = None,
                        area = None,
                        keymapPath = None
                ):
                if not area:
                        area = [(0,int(2*self.view_height/3)),(self.view_width,int(self.view_height/3))]
                self.onKeyPress = onKeyPress
                self.osk = OSK(onkeyPress = self.onKeyPress, area = area, keymapPath = keymapPath)

        def OSKShow(self):
                if not self.osk:
                        print(&#34;OSK not initialized, it can&#39;t be shown&#34;)
                        return None
                self.addElt(self.osk)   # It has already been generated
                self.isKeyboardShown = True

        def OSKHide(self):
                self.removeElt(elt=self.osk)
                self.isKeyboardShown = False

        def startListenerThread(self,grabInput=False):
                &#34;&#34;&#34;
                Starts the touch listener as a separate thread
                &gt; grabInput : (boolean) Whether to do an EVIOCGRAB IOCTL call to prevent
                        another software from registering touch events
                &#34;&#34;&#34;
                self.isInputThreadStarted = True
                self.device.isInputThreadStarted = True
                print(&#34;[PSSM - Touch handler] : Input thread started&#34;)
                args = [self.clickHandler,True,grabInput]
                inputThread = threading.Thread(target=self.device.eventBindings,args=args)
                inputThread.start()

        def clickHandler(self,x,y):
                n = len(self.stack)
                for i in range(n):
                        j = n-1-i       # We go through the stack in descending order
                        elt = self.stack[j]
                        if elt.area == None:
                                # An object without area, it should not happen, but if it does,
                                # it can be skipped
                                continue
                        if coordsInArea(x,y,elt.area):
                                if elt.onclickInside != None:
                                        self.lastX = x
                                        self.lastY = y
                                        if elt != None:
                                                self.dispatchClickToElt((x,y),elt)
                                break           # we quit the for loop

        def dispatchClickToElt(self,coords,elt):
                &#34;&#34;&#34;
                Once given an object on which the user clicked, this function calls the
                appropriate function on the object (ie elt.onclickInside or elt.dispatchClick)
                It also handles inversion.
                &#34;&#34;&#34;
                if elt.isLayout:
                        if elt.onclickInside != None:
                                elt.onclickInside(elt,coords)
                        if elt.invertOnClick:
                                self.invertArea(elt.area,elt.default_invertDuration)
                        elt.dispatchClick(coords)
                else:
                        if elt.invertOnClick:
                                self.invertArea(elt.area,elt.default_invertDuration)
                        elt.onclickInside(elt,coords)

        def stopListenerThread(self):
                self.isInputThreadStarted = False
                self.device.isInputThreadStarted = False
                print(&#34;[PSSM - Touch handler] : Input thread stopped&#34;)


############################# - Core Element    - ##############################
class Element:
        &#34;&#34;&#34;
        Everything which is going to be displayed on the screen is an Element.

        Args:
                isInverted (bool): Is the element inverted
                data (dict, or whatever): A parameter for you to store whatever you want
                area (list): a [(x,y),(w,h)] list. If used in a Layout, the layout will take care of calculating the area.
                imgData (PILImage): the PIL image of the object (None by default, the generator function takes care of generating one on supported Elements)
                onclickInside (function): A function to be executed when the user clicks on the Element
                tags (set): A set of tags the element has. (deprecated)
                invertOnClick (bool): Invert the element when a click is registered ?
                invertDuration (int): Duration in seconds of the element invertion after a click is registered (use 0 for infinite)
        &#34;&#34;&#34;
        def __init__(
                        self,
                        area                    = None,
                        imgData                 = None,
                        onclickInside   = returnFalse,
                        isInverted              = False,
                        data                    = {},
                        tags                    = set(),
                        invertOnClick   = False,
                        invertDuration  = 0.2
                ):
                global lastUsedId
                self.id = lastUsedId
                lastUsedId += 1
                self.isLayout = False
                self.imgData = imgData
                self.area = area
                self.onclickInside = onclickInside
                self.isInverted = isInverted
                self.user_data = data
                self.invertOnClick = invertOnClick
                self.tags=tags
                self.default_invertDuration = invertDuration
                self.parentLayouts = []
                self.parentPSSMScreen = None

        def __hash__(self):
                return hash(self.id)

        def __eq__(self, other):
                if isinstance(other, self.__class__):
                        return self.id == other.id
                return NotImplemented

        def update(self,newAttributes,skipGeneration=False,skipThisEltGeneration=False,skipPrint=False):
                &#34;&#34;&#34;
                Pass a dict as argument, and it will update the Element&#39;s attributes accordingly
                Args :
                        newAttributes (dict): The element&#39;s new attributes
                        skipGeneration (bool): Just update the element&#39;s attribute, but do not do any generation or printing
                        skipThisEltGeneration (bool): Do not regenerate this element but do update the parent layouts
                        skipPrint (bool): Do not update the screen, but do regenerate.
                &#34;&#34;&#34;
                # First, we set the attributes
                for param in newAttributes:
                        setattr(self, param, newAttributes[param])
                if not skipGeneration:
                        # Then we recreate the pillow image of this particular object
                        if not skipThisEltGeneration:
                                self.generator()
                        if len(self.parentLayouts) &gt; 0:
                                # We recreate the pillow image of the oldest parent
                                # And it is not needed to regenerate standard objects, since
                                oldest_parent = self.parentLayouts[0]
                                oldest_parent.generator(skipNonLayoutEltGeneration=True)
                        #then, let&#39;s reprint the stack
                        if not skipPrint:
                                self.parentPSSMScreen.printStack(area=self.area)
                return True

        def generator(self):
                &#34;&#34;&#34;
                The generator is the function which is called when the container layout wants to
                build an image. It therefore returns a pillow image.
                &#34;&#34;&#34;
                return NotImplemented

        def setInverted(self,mode):
                # TODO : actually invert it ? or delete this function
                self.isInverted = mode


############################# - Layout Elements - ##############################
class Layout(Element):
        &#34;&#34;&#34;
        A layout is a quite general kind of Element :
        If must be given the working area, and a layout, and will generate every element of the layout

        Args:
                layout (list): The given layout (see example below). It is basically a list of rows. Each row is a list containing : the height of the row, then as many tuples as you want, each tuple being a (pssm.Element, width) instance
                background_color
                area
                ... all other arguments from the pssm.Element class

        Example of usage:
                layout_demo = [
                [30                                                                                         ],
                [&#34;h*0.1&#34;, (None,&#34;?/2&#34;),        (pssm.Button(&#34;But1&#34;),200),        (None,&#34;?/2&#34;)               ],
                [&#34;?&#34;                                                                                        ],
                [&#34;p*100&#34;, (None,&#34;w*0.3&#34;),       (pssm.Button(&#34;But2&#34;),200),        (None,&#34;w*0.3&#34;)            ],
                [30                                                                                         ],
                [100, (None,20), (pssm.Button(&#34;But3&#34;),200), (None,20), (pssm.Button(&#34;nope&#34;),300), (None,10) ],
                [40                                                                                         ]
            ]
            myLayout = pssm.Layout(layout_demo,screen.area)
            screen.addElt(myLayout)
        &#34;&#34;&#34;
        def __init__(self,layout,area=None,background_color=&#34;white&#34;,**kwargs):
                super().__init__(area=area)
                self.layout      = layout
                self.isValid = self.isLayoutValid()
                self.background_color = background_color
                self.areaMatrix = None
                self.imgMatrix  = None
                self.borders    = None
                self.isLayout   = True
                for param in kwargs:
                        setattr(self, param, kwargs[param])

        def isLayoutValid(self):
                # TODO : to be tested
                l = self.layout
                if not isinstance(l,list):
                        raise Exception(&#34;Layout Element is supposed to be a list&#34;)
                for row in l:
                        if not isinstance(row,list):
                                raise Exception(&#34;A layout row is supposed to be a list&#34;)
                        elif len(row) == 0:
                                raise Exception(&#34;A layout row cannot be empty&#34;)
                        elif not isinstance(row[0],str) and not isinstance(row[0],int):
                                raise Exception(&#34;The first element of a row (its height) should be a string or an integer&#34;)
                        for j in range(1,len(row)):
                                eltTuple = row[j]
                                if not (isinstance(eltTuple,tuple) or isinstance(eltTuple,list)):
                                        raise Exception(&#34;A layout row should be a list of Tuple (except for its first element)&#34;)
                                if len(eltTuple) != 2:
                                        raise Exception(&#34;A layout element should be a Tuple : (Element, elementWidth)&#34;)
                                if not (isinstance(eltTuple[1],str) or isinstance(eltTuple[1],int)):
                                        raise Exception(&#34;An element width should be a string or an integer&#34;)
                                if not (isinstance(eltTuple[0],Element) or eltTuple[0] == None):
                                        raise Exception(&#34;A layout element should be a Tuple : (Element, elementWidth), with Element designating a PSSM Element&#34;)
                return True

        def generator(self,area=None, skipNonLayoutEltGeneration=False):
                &#34;&#34;&#34;
                Builds one img out of all the Elements it is being given
                &#34;&#34;&#34;
                if area != None:
                        self.area = area
                self.createAreaMatrix()
                self.createImgMatrix(skipNonLayoutEltGeneration=skipNonLayoutEltGeneration)
                [(x,y),(w,h)] = self.area
                placeholder = Image.new(
                        self.parentPSSMScreen.colorType,
                        (w,h),
                        color=get_Color(self.background_color,self.parentPSSMScreen.colorType)
                )
                for i in range(len(self.areaMatrix)):
                        for j in range(len(self.areaMatrix[i])):
                                [(elt_x,elt_y),(elt_w,elt_h)] = self.areaMatrix[i][j]
                                relative_x = elt_x - x
                                relative_y = elt_y - y
                                elt_img = self.imgMatrix[i][j]
                                if elt_img != None:
                                        placeholder.paste(self.imgMatrix[i][j],(relative_x,relative_y))
                self.imgData = placeholder
                return self.imgData

        def createImgMatrix(self,skipNonLayoutEltGeneration=False):
                matrix = []
                if not self.areaMatrix:
                        print(&#34;[PSSM Layout Element] Error, areaMatrix has to be defined first&#34;)
                        return None
                for i in range(len(self.layout)):
                        row = []
                        for j in range(1,len(self.layout[i])):
                                myElement,_   = self.layout[i][j]
                                if myElement == None:
                                        myElement_area  = self.areaMatrix[i][j-1]
                                        myElement_img   = None
                                else:
                                        myElement_area  = self.areaMatrix[i][j-1]
                                        if not myElement.isLayout and skipNonLayoutEltGeneration:
                                                myElement_img = myElement.imgData
                                        else:
                                                myElement_img   = myElement.generator(area=myElement_area)
                                row.append(myElement_img)
                        matrix.append(row)
                self.imgMatrix = matrix

        def createAreaMatrix(self):
                # TODO : must honor min and max
                matrix = []
                n_rows = len(self.layout)
                [(x,y),(w,h)] = self.area[:]
                x0,y0=x,y
                for i in range(len(self.layout)):     # Lets loop through the rows
                        row = self.layout[i]
                        row_cols = []           # All the columns of this particular row
                        row_height = row[0]
                        converted_height = self.parentPSSMScreen.convertDimension(row_height)
                        if isinstance(converted_height,int):
                                true_row_height = converted_height
                        else:
                                remaining_height = self.calculate_remainingHeight()
                                true_row_height = int(eval(str(remaining_height) + converted_height[1:]))
                        for j in range(1,len(row)):
                                (element,element_width) = row[j]
                                converted_width = self.parentPSSMScreen.convertDimension(element_width)
                                if element != None:
                                        for parent in self.parentLayouts:
                                                self.layout[i][j][0].parentLayouts.append(parent)
                                        self.layout[i][j][0].parentLayouts.append(self)
                                        self.layout[i][j][0].parentPSSMScreen = self.parentPSSMScreen
                                if isinstance(converted_width,int):
                                        true_element_width = converted_width
                                else:
                                        remaining_width = self.calculate_remainingWidth(i)
                                        true_element_width = int(eval(str(remaining_width) + converted_width[1:]))
                                        self.layout[i][j] = (self.layout[i][j][0], true_element_width)
                                element_area = [(x0,y0),(true_element_width,true_row_height)]
                                x0 += true_element_width
                                row_cols.append(element_area)
                        y0 += true_row_height
                        x0 = x
                        matrix.append(row_cols)
                self.areaMatrix = matrix

        def createEltList(self):
                &#34;&#34;&#34;
                Returns a list of all the elements the Layout Element contains
                &#34;&#34;&#34;
                eltList=[]
                for row in self.layout:
                        for i in range(1,len(row)):
                                elt,_ = row[i]
                                if elt != None:
                                        eltList.append(elt)
                return eltList

        def calculate_remainingHeight(self):
                rows = self.extract_rowsHeight()
                total_questionMarks_weight = 0
                total_height = 0
                for dimension in rows:
                        converted_dimension = self.parentPSSMScreen.convertDimension(dimension)
                        if isinstance(converted_dimension,int):
                                total_height += converted_dimension
                        else:
                                weight = eval(&#34;1&#34; + converted_dimension[1:])
                                total_questionMarks_weight += weight
                layout_height = self.area[1][1]
                return int((layout_height - total_height)/total_questionMarks_weight)

        def calculate_remainingWidth(self,rowIndex):
                cols = self.extract_colsWidth(rowIndex)
                total_width = 0
                total_questionMarks_weight = 0
                for dimension in cols:
                        converted_dimension = self.parentPSSMScreen.convertDimension(dimension)
                        if isinstance(converted_dimension,int):
                                total_width += converted_dimension
                        else:
                                weight = eval(&#34;1&#34; + converted_dimension[1:])
                                total_questionMarks_weight += weight
                layout_width = self.area[1][0]
                return int((layout_width - total_width)/total_questionMarks_weight)

        def extract_rowsHeight(self):
                rows = []
                for row in self.layout:
                        rows.append(row[0])
                return rows

        def extract_colsWidth(self,rowIndex):
                cols = []
                for col in self.layout[rowIndex]:
                        if isinstance(col,tuple):
                                cols.append(col[1])
                return cols

        def dispatchClick(self,coords):
                &#34;&#34;&#34;
                Finds the element on which the user clicked
                &#34;&#34;&#34;
                self.dispatchClick_DICHOTOMY_colsOnly(coords)

        def dispatchClick_LINEAR(self,coords):
                &#34;&#34;&#34;
                Linear search throuh both the rows and the columns
                &#34;&#34;&#34;
                click_x,click_y = coords
                for i in range(len(self.areaMatrix)):                   # Linear search though the rows
                        if len(self.areaMatrix[i]) == 0:
                                # That&#39;s a fake row (a margin row)
                                continue
                        first_row_elt = self.areaMatrix[i][0]
                        last_row_elt = self.areaMatrix[i][-1]
                        x = first_row_elt[0][0]
                        y = first_row_elt[0][1]
                        w = last_row_elt[0][0] + last_row_elt[1][0] - first_row_elt[0][0]
                        h = last_row_elt[0][1] + last_row_elt[1][1] - first_row_elt[0][1]
                        if coordsInArea(click_x, click_y, [(x,y),(w,h)]):               # CLick was in that row
                                for j in range(len(self.areaMatrix[i])):                        # Linear search through the columns
                                        if coordsInArea(click_x,click_y,self.areaMatrix[i][j]):
                                                # Click was on that element
                                                elt,_ = self.layout[i][j+1]
                                                if elt != None and elt.onclickInside != None:
                                                        self.parentPSSMScreen.dispatchClickToElt(coords,elt)
                                                return True
                return False

        def dispatchClick_DICHOTOMY_colsOnly(self,coords):
                &#34;&#34;&#34;
                Linear search through the rows, dichotomy for the columns
                (Because of the empty rows, a dichotomy for the rows doesn&#39;t work)
                &#34;&#34;&#34;
                click_x,click_y = coords
                row_A = -1
                for i in range(len(self.areaMatrix)):                                           # Linear search though the rows
                        if len(self.areaMatrix[i]) == 0:
                                # That&#39;s a fake row (a margin row)
                                continue
                        first_row_elt = self.areaMatrix[i][0]
                        last_row_elt = self.areaMatrix[i][-1]
                        x = first_row_elt[0][0]
                        y = first_row_elt[0][1]
                        w = last_row_elt[0][0] + last_row_elt[1][0] - first_row_elt[0][0]
                        h = last_row_elt[0][1] + last_row_elt[1][1] - first_row_elt[0][1]
                        if coordsInArea(click_x, click_y, [(x,y),(w,h)]):               # CLick was in that row
                                row_A = i
                                break
                if row_A ==-1:
                        return None
                col_A = 0
                col_C = max(len(self.areaMatrix[row_A]) - 1,0)
                xA = self.areaMatrix[row_A][col_A][0][0]
                xC = self.areaMatrix[row_A][col_C][0][0]
                if click_x &lt; xA:
                        return None
                if click_x &gt; xC + self.areaMatrix[row_A][col_C][1][0]:
                        return None
                while col_C &gt; col_A +1:
                        col_B = int(0.5*(col_A+col_C))          # The average of the two
                        xB = self.areaMatrix[row_A][col_B][0][0]
                        if click_x &gt;= xB or col_B==col_C:
                                col_A = col_B
                                xA = xB
                        else:
                                col_C = col_B
                                xC = xB
                ## Element is at indexes row_A, col_A
                elt,_ = self.layout[row_A][col_A+1]
                if elt != None and elt.onclickInside != None:
                        self.parentPSSMScreen.dispatchClickToElt(coords,elt)
                return True

        def dispatchClick_DICHOTOMY_Full_ToBeFixed(self,coords):
                &#34;&#34;&#34;
                Finds the element on which the user clicked
                Implemented with dichotomy search (with the hope of making things faster,
                especially the integrated keyboard)
                &#34;&#34;&#34;
                # TODO : To be fixed
                # For now it does not work, because there are empty rows which break the loop
                click_x,click_y = coords
                row_A = 0
                row_C = max(len(self.areaMatrix) - 1,0)
                print(self.areaMatrix[row_C])
                while len(self.areaMatrix[row_A])==0:
                        row_A += 1
                while len(self.areaMatrix[row_C])==0:
                        row_C -= 1
                yA = self.areaMatrix[row_A][0][0][1]  # First column THEN first row , [(x,y),(w,h)] THUS first tuple of list THEN second coordinate of tuple
                yC = self.areaMatrix[row_C][0][0][1]
                if click_y &lt; yA:
                        return None
                if click_y &gt; yC + self.areaMatrix[row_C][0][1][1]:
                        return None
                while row_C &gt; row_A+1:
                        row_B = int(0.5*(row_A+row_C))          # The average of the two
                        while len(self.areaMatrix[row_B])==0:
                                row_B += 1
                        yB = self.areaMatrix[row_B][0][0][1]
                        if click_y &gt;= yB or row_B==row_C:
                                row_A = row_B
                                yA = yB
                        else:
                                row_C = row_B
                                yC = yB
                # User clicked on element ar row of index row_A
                # Let&#39;s do the same for the column
                col_A = 0
                col_C = max(len(self.areaMatrix[row_A]) - 1,0)
                xA = self.areaMatrix[row_A][col_A][0][0]
                xC = self.areaMatrix[row_A][col_C][0][0]
                if click_x &lt; xA:
                        return None
                if click_x &gt; xC + self.areaMatrix[row_A][col_C][1][0]:
                        return None
                while col_C &gt; col_A +1:
                        col_B = int(0.5*(col_A+col_C))          # The average of the two
                        xB = self.areaMatrix[row_A][col_B][0][0]
                        if click_x &gt;= xB or col_B==col_C:
                                col_A = col_B
                                xA = xB
                        else:
                                col_C = col_B
                                xC = xB
                ## Element is at indexes row_A, col_A
                elt,_ = self.layout[row_A-2][col_A+1]
                if elt != None and elt.onclickInside != None:
                        self.parentPSSMScreen.dispatchClickToElt(coords,elt)
                return True


class ButtonList(Layout):
        &#34;&#34;&#34;
        Generates a Layout with only one item per row, all the same type (buttons) and same height and width
        Args:
                button (list): a [{&#34;text&#34;:&#34;my text&#34;,&#34;onclickInside&#34;:onclickInside},someOtherDict,someOtherDict] array. Each dict will contain the parameters of each button of the button list
                borders (list): a [top,bottom,left,right] array
        &#34;&#34;&#34;
        def __init__(self,buttons, margins=[0,0,0,0],spacing=0,**kwargs):
                self.buttons = buttons
                self.margins = margins
                self.spacing = spacing
                layout = self.build_layoutFromButtons()
                super().__init__(layout)
                for param in kwargs:
                        setattr(self, param, kwargs[param])

        def build_layoutFromButtons(self):
                #TODO : must honor min_width,max_width etc
                [top,bottom,left,right] = self.margins
                buttonLayout = [[top-self.spacing]]
                for button in self.buttons:
                        buttonElt = Button(text=button[&#39;text&#39;])
                        for param in button:
                                setattr(buttonElt, param, button[param])
                        row_height = &#34;?&#34;
                        buttonLayout.append([self.spacing])
                        row = [row_height,(None,left),(buttonElt,&#34;?&#34;),(None,right)]
                        buttonLayout.append(row)
                buttonLayout.append([bottom])
                return buttonLayout


class OSK(Layout):
        &#34;&#34;&#34;
        A PSSM Layout element which builds an on-screen keyboard
        Args:
                keymapPath (str): a path to a PSSMOSK keymap (like the one included)
                onkeyPress (function): A callback function. Will be given keyType and keyChar as argument
        &#34;&#34;&#34;
        def __init__(self,keymapPath=DEFAULT_KEYMAP_PATH,onkeyPress = None, area=None,**kwargs):
                if not keymapPath:
                        keymapPath = DEFAULT_KEYMAP_PATH
                self.keymapPaths = keymapPath
                self.keymap = {&#39;standard&#39;:None,&#39;caps&#39;:None,&#39;alt&#39;:None}
                self.keymap_layouts = {&#39;standard&#39;:None,&#39;caps&#39;:None,&#39;alt&#39;:None}
                self.keymap_imgs = {&#39;standard&#39;:None,&#39;caps&#39;:None,&#39;alt&#39;:None}
                with open(self.keymapPaths[&#39;standard&#39;]) as json_file:
                        self.keymap[&#39;standard&#39;] = json.load(json_file)
                with open(self.keymapPaths[&#39;caps&#39;]) as json_file:
                        self.keymap[&#39;caps&#39;] = json.load(json_file)
                with open(self.keymapPaths[&#39;alt&#39;]) as json_file:
                        self.keymap[&#39;alt&#39;] = json.load(json_file)
                self.lang       = self.keymap[&#39;standard&#39;][&#34;lang&#34;]
                self.onkeyPress = onkeyPress
                for param in kwargs:
                        setattr(self, param, kwargs[param])
                self.view = &#39;standard&#39;
                self.keymap_layouts[&#39;standard&#39;] = self.build_layout(self.keymap[&#39;standard&#39;])
                self.keymap_layouts[&#39;caps&#39;] = self.build_layout(self.keymap[&#39;caps&#39;])
                self.keymap_layouts[&#39;alt&#39;] = self.build_layout(self.keymap[&#39;alt&#39;])
                # Initialize layout with standard view
                self.layout = self.keymap_layouts[&#39;standard&#39;]
                super().__init__(self.layout)
                self.area       = area

        def generator(self, area=None, forceRegenerate = False):
                &#34;&#34;&#34;
                This generator is a bit special : we don&#39;t want it to regenerate everything
                everytime we change view. So we will generate all the views at once the first time.
                Then, unless asked to, we will only return the appropriate image
                &#34;&#34;&#34;
                if forceRegenerate or (not self.keymap_imgs[&#39;standard&#39;]) or (not self.keymap_imgs[&#39;caps&#39;]) or (not self.keymap_imgs[&#39;alt&#39;]):
                        print(&#34;[PSSM OSK] Regenration started&#34;)
                        # Let&#39;s create all the Images
                        # Standard view is created last, because it is the one which is to be displayed
                        self.layout = self.keymap_layouts[&#39;caps&#39;]
                        self.keymap_imgs[&#39;caps&#39;] = super(OSK, self).generator(area=area)
                        self.layout = self.keymap_layouts[&#39;alt&#39;]
                        self.keymap_imgs[&#39;alt&#39;] = super(OSK, self).generator(area=area)
                        self.layout = self.keymap_layouts[&#39;standard&#39;]
                        self.keymap_imgs[&#39;standard&#39;] = super(OSK, self).generator(area=area)
                self.imgData = self.keymap_imgs[self.view]
                return self.keymap_imgs[self.view]

        def build_layout(self,keymap):
                oskLayout = []
                spacing = keymap[&#34;spacing&#34;]
                for row in keymap[&#34;rows&#34;]:
                        buttonRow = [&#34;?&#34;,(None,spacing)]
                        for key in row:
                                label = self.getKeyLabel(key)
                                color_condition         = key[&#34;keyType&#34;] != KTstandardChar
                                background_color        = &#34;gray12&#34; if color_condition else &#34;white&#34;
                                outline_color           = &#34;white&#34; if key[&#34;isPadding&#34;] else &#34;black&#34;
                                buttonElt = Button(
                                        text                            = label,
                                        font_size                       = &#34;h*0.02&#34;,
                                        background_color        = background_color,
                                        outline_color           = outline_color,
                                        onclickInside           = self.handleKeyPress,
                                        user_data                       = key,
                                        wrap_textOverflow       = False,
                                        invertOnClick           = True
                                )
                                key_width = key[&#34;keyWidth&#34;]
                                buttonRow.append((buttonElt,key_width))
                                buttonRow.append((None,spacing))
                        oskLayout.append(buttonRow)
                        oskLayout.append([spacing])
                return oskLayout

        def handleKeyPress(self,elt,coords):
                keyType = elt.user_data[&#34;keyType&#34;]
                keyChar = elt.user_data[&#34;char&#34;]
                if keyType == KTcapsLock:
                        ## In this particular case, we can assume the keyboard will always be on top
                        ## Therefore, no need to print everything, let&#39;s just print the keyboard
                        self.view = &#39;caps&#39; if self.view != &#39;caps&#39; else &#39;standard&#39;
                        self.layout = self.keymap_layouts[self.view]
                        self.createAreaMatrix()
                        self.update(
                            newAttributes={},
                            skipGeneration = True
                        )
                        self.parentPSSMScreen.simplePrintElt(self)
                elif keyType == KTalt:
                        ## In this particular case, we can assume the keyboard will always be on top
                        ## Therefore, no need to print everything, let&#39;s just print the keyboard
                        self.view = &#39;alt&#39; if self.view != &#39;alt&#39; else &#39;standard&#39;
                        self.layout = self.keymap_layouts[self.view]
                        self.createAreaMatrix()
                        self.update(
                            newAttributes={},
                            skipGeneration = True
                        )
                        self.parentPSSMScreen.simplePrintElt(self)
                if self.onkeyPress:
                        self.onkeyPress(keyType,keyChar)


        def getKeyLabel(self,key):
                kt = key[&#34;keyType&#34;]
                if kt == KTstandardChar:
                        return key[&#34;char&#34;]
                elif kt == KTalt:
                        return &#34;ALT&#34;
                elif kt == KTbackspace:
                        return &#34;BACK&#34;
                elif kt == KTcapsLock:
                        return &#34;CAPS&#34;
                elif kt == KTcarriageReturn:
                        return &#34;RET&#34;
                elif kt == KTcontrol:
                        return &#34;CTRL&#34;
                elif kt == KTdelete:
                        return &#34;DEL&#34;
                return &#34;&#34;

############################# - Simple Elements - ##############################
class Rectangle(Element):
        &#34;&#34;&#34;
        A rectangle
        Args:
                background_color (str): The background color
                outline_color (str): The border color
        &#34;&#34;&#34;
        def __init__(self,background_color=&#34;white&#34;,outline_color=&#34;gray3&#34;,parentPSSMScreen=None):
                super().__init__()
                self.background_color = background_color
                self.outline_color = outline_color
                self.parentPSSMScreen = parentPSSMScreen

        def generator(self,area):
                [(x,y),(w,h)] = area
                self.area = area
                img = Image.new(
                        self.parentPSSMScreen.colorType,
                        (w+1,h+1),
                        color=get_Color(&#34;white&#34;,self.parentPSSMScreen.colorType)
                )
                rect = ImageDraw.Draw(img, self.parentPSSMScreen.colorType)
                rect.rectangle(
                        [(0,0),(w,h)],
                        fill=get_Color(self.background_color,self.parentPSSMScreen.colorType),
                        outline=get_Color(self.outline_color,self.parentPSSMScreen.colorType)
                )
                self.imgData = img
                return self.imgData

class RectangleRounded(Element):
        &#34;&#34;&#34;
        A rectangle, but with rounded corners
        &#34;&#34;&#34;
        def __init__(
                        self,
                        radius=20,
                        background_color=&#34;white&#34;,
                        outline_color=&#34;gray3&#34;,
                        parentPSSMScreen=None
                ):
                super().__init__()
                self.radius = radius
                self.background_color = background_color
                self.outline_color = outline_color
                self.parentPSSMScreen = parentPSSMScreen

        def generator(self,area):
                [(x,y),(w,h)] = area
                self.area = area
                rectangle = Image.new(
                        self.parentPSSMScreen.colorType,
                        (w,h),
                        color=get_Color(&#34;white&#34;,self.parentPSSMScreen.colorType)
                )
                draw = ImageDraw.Draw(rectangle)
                draw.rectangle(
                        [(0,0),(w,h)],
                        fill=get_Color(self.background_color,self.parentPSSMScreen.colorType),
                        outline=get_Color(self.outline_color,self.parentPSSMScreen.colorType)
                )
                draw.line(
                        [(self.radius,h-1),(w-self.radius,h-1)],
                        fill  = get_Color(self.outline_color, self.parentPSSMScreen.colorType),
                        width = 1
                )
                draw.line(
                        [(w-1,self.radius),(w-1,h-self.radius)],
                        fill  = get_Color(self.outline_color, self.parentPSSMScreen.colorType),
                        width = 1
                )
                corner = roundedCorner(
                        self.radius,
                        self.background_color,
                        self.outline_color,
                        self.parentPSSMScreen.colorType
                )
                rectangle.paste(corner, (0, 0))
                rectangle.paste(corner.rotate(90), (0, h - self.radius)) # Rotate the corner and paste it
                rectangle.paste(corner.rotate(180), (w - self.radius, h - self.radius))
                rectangle.paste(corner.rotate(270), (w - self.radius, 0))
                self.imgData = rectangle
                return self.imgData

class Button(Element):
        &#34;&#34;&#34;
        Basically a rectangle (or rounded rectangle) with text printed on it
        Args:
                font (str): Path to a font file
                font_size (int): The font size
                font_color (str): The color of the font : &#34;white&#34;, &#34;black&#34;, &#34;gray0&#34; to &#34;gray15&#34; or a (red, green, blue, transparency) tuple
                wrap_textOverflow (bool): (True by default) Wrap text in order to avoid it overflowing. The cuts are made between words.
                text_xPosition (str or int): can be left, center, right, or an integer value, or a pssm string dimension
                text_yPosition (str or int): can be left, center, right, or an integer value, or a pssm string dimension
                background_color (str): The background color
                outline_color (str): The border color
                radius (int): If not 0, then add rounded corners of this radius
        &#34;&#34;&#34;
        def __init__(
                        self,
                        text,
                        font=DEFAULT_FONT,
                        font_size=STANDARD_FONT_SIZE,
                        background_color=&#34;white&#34;,
                        outline_color=&#34;black&#34;,
                        radius=0,
                        font_color=&#34;black&#34;,
                        text_xPosition=&#34;center&#34;,
                        text_yPosition=&#34;center&#34;,
                        wrap_textOverflow = True,
                        **kwargs
                ):
                super().__init__()
                self.background_color   = background_color
                self.outline_color      = outline_color
                self.text                       = text
                self.font                       = font
                self.font_size                  = font_size
                self.radius                     = radius
                self.font_color                 = font_color
                self.text_xPosition     = text_xPosition
                self.text_yPosition     = text_yPosition
                self.wrap_textOverflow  = wrap_textOverflow
                for param in kwargs:
                        setattr(self, param, kwargs[param])

        def generator(self,area=None):
                if area==None:
                        area = self.area
                [(x,y),(w,h)] = area
                self.area = area
                if not isinstance(self.font_size,int):
                        self.font_size = self.parentPSSMScreen.convertDimension(self.font_size)
                        if not isinstance(self.font_size,int):
                                # That&#39;s a question mark dimension, or an invalid dimension. Rollback to default font size
                                self.font_size = self.parentPSSMScreen.convertDimension(STANDARD_FONT_SIZE)
                loaded_font = ImageFont.truetype(self.font, self.font_size)
                if self.radius&gt;0:
                        rect = RectangleRounded(
                                radius=self.radius,
                                background_color        = self.background_color,
                                outline_color           = self.outline_color,
                                parentPSSMScreen        = self.parentPSSMScreen
                        )
                else:
                        rect = Rectangle(
                                background_color        = self.background_color,
                                outline_color           = self.outline_color,
                                parentPSSMScreen        = self.parentPSSMScreen
                        )
                rect_img = rect.generator(self.area)
                imgDraw  = ImageDraw.Draw(rect_img, self.parentPSSMScreen.colorType)
                myText   = self.wrapText(self.text,loaded_font,imgDraw) if self.wrap_textOverflow else self.text
                text_w,text_h = imgDraw.textsize(self.text, font=loaded_font)
                x = tools_convertXArgsToPX(self.text_xPosition, w,text_w , parentPSSMScreen = self.parentPSSMScreen)
                y = tools_convertYArgsToPX(self.text_yPosition,h ,text_h , parentPSSMScreen = self.parentPSSMScreen)
                imgDraw.text(
                        (x,y),
                        myText,
                        font=loaded_font,
                        fill=get_Color(self.font_color, self.parentPSSMScreen.colorType)
                )
                self.imgData = rect_img
                return self.imgData

        def wrapText(self,text,loaded_font,imgDraw):
                def get_text_width(text):
                        return imgDraw.textsize(text=text,font=loaded_font)[0]

                [(x,y),(max_width,h)] = self.area
                text_lines = [
                        &#39; &#39;.join([w.strip() for w in l.split(&#39; &#39;) if w])
                        for l in text.split(&#39;\n&#39;)
                        if l
                ]
                space_width = get_text_width(&#34; &#34;)
                wrapped_lines = []
                buf = []
                buf_width = 0

                for line in text_lines:
                        for word in line.split(&#39; &#39;):
                                word_width = get_text_width(word)

                                expected_width = word_width if not buf else \
                                        buf_width + space_width + word_width

                                if expected_width &lt;= max_width:
                                        # word fits in line
                                        buf_width = expected_width
                                        buf.append(word)
                                else:
                                        # word doesn&#39;t fit in line
                                        wrapped_lines.append(&#39; &#39;.join(buf))
                                        buf = [word]
                                        buf_width = word_width
                        if buf:
                                wrapped_lines.append(&#39; &#39;.join(buf))
                                buf = []
                                buf_width = 0
                return &#39;\n&#39;.join(wrapped_lines)

class Icon(Element):
        &#34;&#34;&#34;
        An icon, built from an image
        Args:
                file (str): Path to a file, or one of the integrated image (see the icon folder for the name of each image). &#39;reboot&#39; for instance points to the integrated reboot image.
                centered (bool): Center the icon?
        &#34;&#34;&#34;
        def __init__(self,file,centered=True,**kwargs):
                super().__init__()
                self.file = file
                self.centered = centered
                self.path_to_file = tools_parseKnownImageFile(self.file)
                for param in kwargs:
                        setattr(self, param, kwargs[param])

        def generator(self,area):
                self.area = area
                [(x,y),(w,h)] = area
                icon_size = min(area[1][0],area[1][1])
                iconImg = Image.open(self.path_to_file).convert(self.parentPSSMScreen.colorType).resize((icon_size,icon_size))
                if not self.centered:
                        self.imgData = iconImg
                        return iconImg
                else:
                        img = Image.new(
                                self.parentPSSMScreen.colorType,
                                (w+1,h+1),
                                color=get_Color(&#34;white&#34;,self.parentPSSMScreen.colorType)
                        )
                        img.paste(iconImg, (int(0.5*w-0.5*icon_size), int(0.5*h-0.5*icon_size)))
                        self.imgData = img
                        return img

class Static(Element):
        &#34;&#34;&#34;
        A very simple element which only displays a pillow image
        Args:
                pil_image (str or pil image): path to an image or a pillow image
                centered (bool): Center the image ?
                resize (bool): Make it fit the area ? (proportions are respected)
                rotation (int): an integer rotation angle
                background_color (str): &#34;white&#34;, &#34;black&#34;, &#34;gray0&#34; to &#34;gray15&#34; or a (red, green, blue, transparency) tuple
        &#34;&#34;&#34;
        def __init__(self,pil_image,centered=True,resize=True,background_color=&#34;white&#34;,rotation=0,**kwargs):
                super().__init__()
                if isinstance(pil_image,str):
                        self.pil_image = Image.open(pil_image)
                else:
                        self.pil_image = pil_image
                self.background_color = background_color
                self.centered = centered
                self.resize   = resize
                self.rotation = rotation
                for param in kwargs:
                        setattr(self, param, kwargs[param])

        def generator(self,area=None):
                # TODO : crop or resize the image to make it fit the area
                (x,y),(w,h) = area
                pil_image = self.pil_image.convert(self.parentPSSMScreen.colorType)
                if self.resize:
                        r = min(w/pil_image.width, h/pil_image.height)
                        size = (int(pil_image.width*r), int(pil_image.height*r))
                        pil_image = self.pil_image.resize(size)
                if self.rotation != 0:
                        pil_image = pil_image.rotate(self.rotation,fillcolor=self.background_color)
                if not self.centered:
                        return pil_image
                else:
                        img = Image.new(
                                self.parentPSSMScreen.colorType,
                                (w+1,h+1),
                                color=get_Color(self.background_color,self.parentPSSMScreen.colorType)
                        )
                        img.paste(pil_image, (int(0.5*w-0.5*pil_image.width), int(0.5*h-0.5*pil_image.height)))
                        self.imgData = img
                        return img

class Line(Element):
        &#34;&#34;&#34;
    Draws a simple line
    Args:
        color (str or tuple): &#34;white&#34;, &#34;black&#34;, &#34;gray0&#34; to &#34;gray15&#34; or a (red, green, blue, transparency) tuple
        width (int): The width of the line
        type (str): can be &#34;horizontal&#34;, &#34;vertical&#34;, &#34;diagonal1&#34; (top-left to bottom right) or &#34;diagonal2&#34; (top-right to bottom-left)
    &#34;&#34;&#34;
        def __init__(self,color=&#34;black&#34;,width=1,type=&#34;horizontal&#34;):
                super().__init__()
                self.color = color
                self.width = width
                self.type  = type

        def generator(self,area):
                (x,y),(w,h) = area
                self.area = area
                if self.type == &#34;horizontal&#34;:
                        coo = [(0,0),(w,0)]
                elif self.type == &#34;vertical&#34;:
                        coo = [(0,0),(0,h)]
                elif self.type == &#34;diagonal1&#34;:
                        coo = [(0,0),(w,h)]
                else: # Assuming diagonal2
                        coo = [(w,0),(0,h)]
                rectangle = Image.new(
                        self.parentPSSMScreen.colorType,
                        (w,h),
                        color=get_Color(&#34;white&#34;,self.parentPSSMScreen.colorType)
                )
                draw = ImageDraw.Draw(rectangle)
                draw.line(
                        coo,
                        fill  = get_Color(self.color, self.parentPSSMScreen.colorType),
                        width = self.width
                )
                self.imgData = rectangle
                return self.imgData


############################# -         Tools           - ##############################
def coordsInArea(click_x,click_y,area):
    &#34;&#34;&#34;
    Returns a boolean indicating if the click was in the given area
    Args:
        click_x (str): The x coordinate of the click
        click_y (str): The y coordinate of the click
        area (list): The area (of shape : [(x,y),(w,h)])
    &#34;&#34;&#34;
    [(x,y),(w,h)] = area
    if click_x&gt;=x and click_x&lt;x+w and click_y&gt;=y and click_y&lt;y+h:
        return True
    else:
        return False

def getRectanglesIntersection(area1,area2):
        (x1,y1),(w1,h1) = area1
        (x2,y2),(w2,h2) = area2
        x0a = max(x1,x2)
        x0b = min(x1+w1,x2+w2)
        y0a = max(y1,y2)
        y0b = min(y1+h1,y2+h2)
        w0 = x0b-x0a
        h0 = y0b-y0a
        if  w0 &gt; 0 and h0 &gt; 0:
                return [(x0a,y0a),(w0,h0)]
        else:
                return None

def roundedCorner(radius, fill=&#34;white&#34;,outline_color=&#34;gray3&#34;,colorType=&#39;L&#39;):
        &#34;&#34;&#34;
        Draw a round corner
        &#34;&#34;&#34;
        corner = Image.new(colorType, (radius, radius), &#34;white&#34;)
        draw = ImageDraw.Draw(corner)
        draw.pieslice(
                (0, 0, radius * 2, radius * 2),
                180,
                270,
                fill=get_Color(fill,colorType),
                outline=get_Color(outline_color,colorType)
        )
        return corner

def tools_convertXArgsToPX(xPosition,objw,textw,parentPSSMScreen=None):
        &#34;&#34;&#34;
        Converts xPosition string arguments to numerical values
        &#34;&#34;&#34;
        xPosition = xPosition.lower()
        if xPosition == &#34;left&#34;:
                x = 0
        elif xPosition == &#34;center&#34;:
                x = int(0.5*objw-0.5*textw)
        elif xPosition == &#34;right&#34;:
                x = int(objw-textw)
        else:
                try:
                        converted = parentPSSMScreen.convertDimension(xPosition)
                        x = int(converted)
                except:
                        print(&#34;[PSSM] Invalid input for xPosition&#34;)
                        return False
        return x

def tools_convertYArgsToPX(yPosition,objh,texth,parentPSSMScreen=None):
        &#34;&#34;&#34;
        Converts yPosition string arguments to numerical values
        &#34;&#34;&#34;
        yPosition = yPosition.lower()
        if yPosition == &#34;top&#34;:
                y = 0
        elif yPosition == &#34;center&#34;:
                y = int(0.5*objh-0.5*texth)
        elif yPosition == &#34;bottom&#34;:
                y = int(objh-texth)
        else:
                try:
                        converted = parentPSSMScreen.convertDimension(xPosition)
                        y = int(converted)
                except:
                        print(&#34;[PSSM] Invalid input for yPosition&#34;)
                        return False
        return y

def tools_parseKnownImageFile(file):
        files={
                &#39;back&#39;          : PATH_TO_PSSM + &#34;/icons/back.png&#34;,
                &#39;delete&#39;        : PATH_TO_PSSM + &#34;/icons/delete.jpg&#34;,
                &#34;frontlight-down&#34;       : PATH_TO_PSSM + &#34;/icons/frontlight-down.jpg&#34;,
                &#34;frontlight-up&#34;         : PATH_TO_PSSM + &#34;/icons/frontlight-up.jpg&#34;,
                &#34;invert&#34;        : PATH_TO_PSSM + &#34;/icons/invert.jpg&#34;,
                &#34;reboot&#34;        : PATH_TO_PSSM + &#34;/icons/reboot.jpg&#34;,
                &#34;save&#34;          : PATH_TO_PSSM + &#34;/icons/save.png&#34;,
                &#34;touch-off&#34;     : PATH_TO_PSSM + &#34;/icons/touch-off.png&#34;,
                &#34;touch-on&#34;      : PATH_TO_PSSM + &#34;/icons/touch-on.png&#34;,
                &#34;wifi-lock&#34;     : PATH_TO_PSSM + &#34;/icons/wifi-lock.jpg&#34;,
                &#34;wifi-on&#34;       : PATH_TO_PSSM + &#34;/icons/wifi-on.jpg&#34;,
                &#34;wifi-off&#34;      : PATH_TO_PSSM + &#34;/icons/wifi-off.jpg&#34;
        }
        if file in files:
                return files[file]
        else:
                return file


colorsL = {&#39;black&#39;:0,&#39;white&#39;:255}
colorsRGBA = {&#39;black&#39;:(0,0,0,0),&#39;white&#39;:(255,255,255,1)}
for i in range(16):
        s = int(i*255/15)
        colorsL[&#39;gray&#39; + str(i)]        = s
        colorsRGBA[&#39;gray&#39; + str(i)] = (s,s,s,1)

def get_Color(color,deviceColorType):
        if isinstance(color,str):
                if deviceColorType == &#34;L&#34;:
                        try:
                                return colorsL[color]
                        except:
                                print(&#34;Invalid color, &#34;,color)
                                return color
                elif deviceColorType == &#34;RGBA&#34;:
                        try:
                                return colorsRGBA[color]
                        except:
                                print(&#34;Invalid color, &#34;,color)
                                return color
        elif isinstance(color,list) or isinstance(color,tuple):
                if deviceColorType == &#34;RGBA&#34;:
                        if len(color) == 4:
                                return color
                        else:
                                #That&#39;s probably RGB
                                try:
                                        return color + [1]
                                except:
                                        return color + (1)
                else:
                        r, g, b = color[0], color[1], color[2]
                        gray = 0.2989 * r + 0.5870 * g + 0.1140 * b
                        return gray


################################ - DOCUMENTATION - #############################
__pdoc__ = {}                   # For the documentation
ignoreList  =[
        &#39;returnFalse&#39;,
        &#39;coordsInArea&#39;,
        &#39;getRectanglesIntersection&#39;,
        &#39;roundedCorner&#39;,
        &#39;tools_convertXArgsToPX&#39;,
        &#39;tools_convertYArgsToPX&#39;,
        &#39;tools_parseKnownImageFile&#39;,
        &#39;get_Color&#39;,
        &#39;PSSMScreen.getPartialEltImg&#39;,
        &#39;PSSMScreen.convertDimension&#39;,
        &#39;Layout.generator&#39;,
        &#39;Layout.createImgMatrix&#39;,
        &#39;Layout.createAreaMatrix&#39;,
        &#39;Layout.calculate_remainingHeight&#39;,
        &#39;Layout.calculate_remainingWidth&#39;,
        &#39;Layout.extract_rowsHeight&#39;,
        &#39;Layout.extract_colsWidth&#39;,
        &#39;Layout.dispatchClick&#39;,
        &#39;Layout.dispatchClick_LINEAR&#39;,
        &#39;Layout.dispatchClick_DICHOTOMY_colsOnly&#39;,
        &#39;Layout.dispatchClick_DICHOTOMY_Full_ToBeFixed&#39;
]
for f in ignoreList:
        __pdoc__[f] = False</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="Python-Screen-Stack-Manager.pssm.Button"><code class="flex name class">
<span>class <span class="ident">Button</span></span>
<span>(</span><span>text, font=DEFAULT_FONT, font_size='h*0.036', background_color='white', outline_color='black', radius=0, font_color='black', text_xPosition='center', text_yPosition='center', wrap_textOverflow=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Basically a rectangle (or rounded rectangle) with text printed on it</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>font</code></strong> :&ensp;<code>str</code></dt>
<dd>Path to a font file</dd>
<dt><strong><code>font_size</code></strong> :&ensp;<code>int</code></dt>
<dd>The font size</dd>
<dt><strong><code>font_color</code></strong> :&ensp;<code>str</code></dt>
<dd>The color of the font : "white", "black", "gray0" to "gray15" or a (red, green, blue, transparency) tuple</dd>
<dt><strong><code>wrap_textOverflow</code></strong> :&ensp;<code>bool</code></dt>
<dd>(True by default) Wrap text in order to avoid it overflowing. The cuts are made between words.</dd>
<dt><strong><code>text_xPosition</code></strong> :&ensp;<code>str</code> or <code>int</code></dt>
<dd>can be left, center, right, or an integer value, or a pssm string dimension</dd>
<dt><strong><code>text_yPosition</code></strong> :&ensp;<code>str</code> or <code>int</code></dt>
<dd>can be left, center, right, or an integer value, or a pssm string dimension</dd>
<dt><strong><code>background_color</code></strong> :&ensp;<code>str</code></dt>
<dd>The background color</dd>
<dt><strong><code>outline_color</code></strong> :&ensp;<code>str</code></dt>
<dd>The border color</dd>
<dt><strong><code>radius</code></strong> :&ensp;<code>int</code></dt>
<dd>If not 0, then add rounded corners of this radius</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Button(Element):
        &#34;&#34;&#34;
        Basically a rectangle (or rounded rectangle) with text printed on it
        Args:
                font (str): Path to a font file
                font_size (int): The font size
                font_color (str): The color of the font : &#34;white&#34;, &#34;black&#34;, &#34;gray0&#34; to &#34;gray15&#34; or a (red, green, blue, transparency) tuple
                wrap_textOverflow (bool): (True by default) Wrap text in order to avoid it overflowing. The cuts are made between words.
                text_xPosition (str or int): can be left, center, right, or an integer value, or a pssm string dimension
                text_yPosition (str or int): can be left, center, right, or an integer value, or a pssm string dimension
                background_color (str): The background color
                outline_color (str): The border color
                radius (int): If not 0, then add rounded corners of this radius
        &#34;&#34;&#34;
        def __init__(
                        self,
                        text,
                        font=DEFAULT_FONT,
                        font_size=STANDARD_FONT_SIZE,
                        background_color=&#34;white&#34;,
                        outline_color=&#34;black&#34;,
                        radius=0,
                        font_color=&#34;black&#34;,
                        text_xPosition=&#34;center&#34;,
                        text_yPosition=&#34;center&#34;,
                        wrap_textOverflow = True,
                        **kwargs
                ):
                super().__init__()
                self.background_color   = background_color
                self.outline_color      = outline_color
                self.text                       = text
                self.font                       = font
                self.font_size                  = font_size
                self.radius                     = radius
                self.font_color                 = font_color
                self.text_xPosition     = text_xPosition
                self.text_yPosition     = text_yPosition
                self.wrap_textOverflow  = wrap_textOverflow
                for param in kwargs:
                        setattr(self, param, kwargs[param])

        def generator(self,area=None):
                if area==None:
                        area = self.area
                [(x,y),(w,h)] = area
                self.area = area
                if not isinstance(self.font_size,int):
                        self.font_size = self.parentPSSMScreen.convertDimension(self.font_size)
                        if not isinstance(self.font_size,int):
                                # That&#39;s a question mark dimension, or an invalid dimension. Rollback to default font size
                                self.font_size = self.parentPSSMScreen.convertDimension(STANDARD_FONT_SIZE)
                loaded_font = ImageFont.truetype(self.font, self.font_size)
                if self.radius&gt;0:
                        rect = RectangleRounded(
                                radius=self.radius,
                                background_color        = self.background_color,
                                outline_color           = self.outline_color,
                                parentPSSMScreen        = self.parentPSSMScreen
                        )
                else:
                        rect = Rectangle(
                                background_color        = self.background_color,
                                outline_color           = self.outline_color,
                                parentPSSMScreen        = self.parentPSSMScreen
                        )
                rect_img = rect.generator(self.area)
                imgDraw  = ImageDraw.Draw(rect_img, self.parentPSSMScreen.colorType)
                myText   = self.wrapText(self.text,loaded_font,imgDraw) if self.wrap_textOverflow else self.text
                text_w,text_h = imgDraw.textsize(self.text, font=loaded_font)
                x = tools_convertXArgsToPX(self.text_xPosition, w,text_w , parentPSSMScreen = self.parentPSSMScreen)
                y = tools_convertYArgsToPX(self.text_yPosition,h ,text_h , parentPSSMScreen = self.parentPSSMScreen)
                imgDraw.text(
                        (x,y),
                        myText,
                        font=loaded_font,
                        fill=get_Color(self.font_color, self.parentPSSMScreen.colorType)
                )
                self.imgData = rect_img
                return self.imgData

        def wrapText(self,text,loaded_font,imgDraw):
                def get_text_width(text):
                        return imgDraw.textsize(text=text,font=loaded_font)[0]

                [(x,y),(max_width,h)] = self.area
                text_lines = [
                        &#39; &#39;.join([w.strip() for w in l.split(&#39; &#39;) if w])
                        for l in text.split(&#39;\n&#39;)
                        if l
                ]
                space_width = get_text_width(&#34; &#34;)
                wrapped_lines = []
                buf = []
                buf_width = 0

                for line in text_lines:
                        for word in line.split(&#39; &#39;):
                                word_width = get_text_width(word)

                                expected_width = word_width if not buf else \
                                        buf_width + space_width + word_width

                                if expected_width &lt;= max_width:
                                        # word fits in line
                                        buf_width = expected_width
                                        buf.append(word)
                                else:
                                        # word doesn&#39;t fit in line
                                        wrapped_lines.append(&#39; &#39;.join(buf))
                                        buf = [word]
                                        buf_width = word_width
                        if buf:
                                wrapped_lines.append(&#39; &#39;.join(buf))
                                buf = []
                                buf_width = 0
                return &#39;\n&#39;.join(wrapped_lines)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="Python-Screen-Stack-Manager.pssm.Element" href="#Python-Screen-Stack-Manager.pssm.Element">Element</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="Python-Screen-Stack-Manager.pssm.Button.wrapText"><code class="name flex">
<span>def <span class="ident">wrapText</span></span>(<span>self, text, loaded_font, imgDraw)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def wrapText(self,text,loaded_font,imgDraw):
        def get_text_width(text):
                return imgDraw.textsize(text=text,font=loaded_font)[0]

        [(x,y),(max_width,h)] = self.area
        text_lines = [
                &#39; &#39;.join([w.strip() for w in l.split(&#39; &#39;) if w])
                for l in text.split(&#39;\n&#39;)
                if l
        ]
        space_width = get_text_width(&#34; &#34;)
        wrapped_lines = []
        buf = []
        buf_width = 0

        for line in text_lines:
                for word in line.split(&#39; &#39;):
                        word_width = get_text_width(word)

                        expected_width = word_width if not buf else \
                                buf_width + space_width + word_width

                        if expected_width &lt;= max_width:
                                # word fits in line
                                buf_width = expected_width
                                buf.append(word)
                        else:
                                # word doesn&#39;t fit in line
                                wrapped_lines.append(&#39; &#39;.join(buf))
                                buf = [word]
                                buf_width = word_width
                if buf:
                        wrapped_lines.append(&#39; &#39;.join(buf))
                        buf = []
                        buf_width = 0
        return &#39;\n&#39;.join(wrapped_lines)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="Python-Screen-Stack-Manager.pssm.Element" href="#Python-Screen-Stack-Manager.pssm.Element">Element</a></b></code>:
<ul class="hlist">
<li><code><a title="Python-Screen-Stack-Manager.pssm.Element.generator" href="#Python-Screen-Stack-Manager.pssm.Element.generator">generator</a></code></li>
<li><code><a title="Python-Screen-Stack-Manager.pssm.Element.update" href="#Python-Screen-Stack-Manager.pssm.Element.update">update</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="Python-Screen-Stack-Manager.pssm.ButtonList"><code class="flex name class">
<span>class <span class="ident">ButtonList</span></span>
<span>(</span><span>buttons, margins=[0, 0, 0, 0], spacing=0, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Generates a Layout with only one item per row, all the same type (buttons) and same height and width</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>button</code></strong> :&ensp;<code>list</code></dt>
<dd>a [{"text":"my text","onclickInside":onclickInside},someOtherDict,someOtherDict] array. Each dict will contain the parameters of each button of the button list</dd>
<dt><strong><code>borders</code></strong> :&ensp;<code>list</code></dt>
<dd>a [top,bottom,left,right] array</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ButtonList(Layout):
        &#34;&#34;&#34;
        Generates a Layout with only one item per row, all the same type (buttons) and same height and width
        Args:
                button (list): a [{&#34;text&#34;:&#34;my text&#34;,&#34;onclickInside&#34;:onclickInside},someOtherDict,someOtherDict] array. Each dict will contain the parameters of each button of the button list
                borders (list): a [top,bottom,left,right] array
        &#34;&#34;&#34;
        def __init__(self,buttons, margins=[0,0,0,0],spacing=0,**kwargs):
                self.buttons = buttons
                self.margins = margins
                self.spacing = spacing
                layout = self.build_layoutFromButtons()
                super().__init__(layout)
                for param in kwargs:
                        setattr(self, param, kwargs[param])

        def build_layoutFromButtons(self):
                #TODO : must honor min_width,max_width etc
                [top,bottom,left,right] = self.margins
                buttonLayout = [[top-self.spacing]]
                for button in self.buttons:
                        buttonElt = Button(text=button[&#39;text&#39;])
                        for param in button:
                                setattr(buttonElt, param, button[param])
                        row_height = &#34;?&#34;
                        buttonLayout.append([self.spacing])
                        row = [row_height,(None,left),(buttonElt,&#34;?&#34;),(None,right)]
                        buttonLayout.append(row)
                buttonLayout.append([bottom])
                return buttonLayout</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="Python-Screen-Stack-Manager.pssm.Layout" href="#Python-Screen-Stack-Manager.pssm.Layout">Layout</a></li>
<li><a title="Python-Screen-Stack-Manager.pssm.Element" href="#Python-Screen-Stack-Manager.pssm.Element">Element</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="Python-Screen-Stack-Manager.pssm.ButtonList.build_layoutFromButtons"><code class="name flex">
<span>def <span class="ident">build_layoutFromButtons</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def build_layoutFromButtons(self):
        #TODO : must honor min_width,max_width etc
        [top,bottom,left,right] = self.margins
        buttonLayout = [[top-self.spacing]]
        for button in self.buttons:
                buttonElt = Button(text=button[&#39;text&#39;])
                for param in button:
                        setattr(buttonElt, param, button[param])
                row_height = &#34;?&#34;
                buttonLayout.append([self.spacing])
                row = [row_height,(None,left),(buttonElt,&#34;?&#34;),(None,right)]
                buttonLayout.append(row)
        buttonLayout.append([bottom])
        return buttonLayout</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="Python-Screen-Stack-Manager.pssm.Layout" href="#Python-Screen-Stack-Manager.pssm.Layout">Layout</a></b></code>:
<ul class="hlist">
<li><code><a title="Python-Screen-Stack-Manager.pssm.Layout.createEltList" href="#Python-Screen-Stack-Manager.pssm.Layout.createEltList">createEltList</a></code></li>
<li><code><a title="Python-Screen-Stack-Manager.pssm.Layout.dispatchClick" href="#Python-Screen-Stack-Manager.pssm.Layout.dispatchClick">dispatchClick</a></code></li>
<li><code><a title="Python-Screen-Stack-Manager.pssm.Layout.dispatchClick_DICHOTOMY_Full_ToBeFixed" href="#Python-Screen-Stack-Manager.pssm.Layout.dispatchClick_DICHOTOMY_Full_ToBeFixed">dispatchClick_DICHOTOMY_Full_ToBeFixed</a></code></li>
<li><code><a title="Python-Screen-Stack-Manager.pssm.Layout.dispatchClick_DICHOTOMY_colsOnly" href="#Python-Screen-Stack-Manager.pssm.Layout.dispatchClick_DICHOTOMY_colsOnly">dispatchClick_DICHOTOMY_colsOnly</a></code></li>
<li><code><a title="Python-Screen-Stack-Manager.pssm.Layout.dispatchClick_LINEAR" href="#Python-Screen-Stack-Manager.pssm.Layout.dispatchClick_LINEAR">dispatchClick_LINEAR</a></code></li>
<li><code><a title="Python-Screen-Stack-Manager.pssm.Layout.generator" href="#Python-Screen-Stack-Manager.pssm.Layout.generator">generator</a></code></li>
<li><code><a title="Python-Screen-Stack-Manager.pssm.Layout.update" href="#Python-Screen-Stack-Manager.pssm.Element.update">update</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="Python-Screen-Stack-Manager.pssm.Element"><code class="flex name class">
<span>class <span class="ident">Element</span></span>
<span>(</span><span>area=None, imgData=None, onclickInside=&lt;function returnFalse&gt;, isInverted=False, data={}, tags=set(), invertOnClick=False, invertDuration=0.2)</span>
</code></dt>
<dd>
<div class="desc"><p>Everything which is going to be displayed on the screen is an Element.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>isInverted</code></strong> :&ensp;<code>bool</code></dt>
<dd>Is the element inverted</dd>
<dt><strong><code>data</code></strong> :&ensp;<code>dict,</code> or <code>whatever</code></dt>
<dd>A parameter for you to store whatever you want</dd>
<dt><strong><code>area</code></strong> :&ensp;<code>list</code></dt>
<dd>a [(x,y),(w,h)] list. If used in a Layout, the layout will take care of calculating the area.</dd>
<dt><strong><code>imgData</code></strong> :&ensp;<code>PILImage</code></dt>
<dd>the PIL image of the object (None by default, the generator function takes care of generating one on supported Elements)</dd>
<dt><strong><code>onclickInside</code></strong> :&ensp;<code>function</code></dt>
<dd>A function to be executed when the user clicks on the Element</dd>
<dt><strong><code>tags</code></strong> :&ensp;<code>set</code></dt>
<dd>A set of tags the element has. (deprecated)</dd>
<dt><strong><code>invertOnClick</code></strong> :&ensp;<code>bool</code></dt>
<dd>Invert the element when a click is registered ?</dd>
<dt><strong><code>invertDuration</code></strong> :&ensp;<code>int</code></dt>
<dd>Duration in seconds of the element invertion after a click is registered (use 0 for infinite)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Element:
        &#34;&#34;&#34;
        Everything which is going to be displayed on the screen is an Element.

        Args:
                isInverted (bool): Is the element inverted
                data (dict, or whatever): A parameter for you to store whatever you want
                area (list): a [(x,y),(w,h)] list. If used in a Layout, the layout will take care of calculating the area.
                imgData (PILImage): the PIL image of the object (None by default, the generator function takes care of generating one on supported Elements)
                onclickInside (function): A function to be executed when the user clicks on the Element
                tags (set): A set of tags the element has. (deprecated)
                invertOnClick (bool): Invert the element when a click is registered ?
                invertDuration (int): Duration in seconds of the element invertion after a click is registered (use 0 for infinite)
        &#34;&#34;&#34;
        def __init__(
                        self,
                        area                    = None,
                        imgData                 = None,
                        onclickInside   = returnFalse,
                        isInverted              = False,
                        data                    = {},
                        tags                    = set(),
                        invertOnClick   = False,
                        invertDuration  = 0.2
                ):
                global lastUsedId
                self.id = lastUsedId
                lastUsedId += 1
                self.isLayout = False
                self.imgData = imgData
                self.area = area
                self.onclickInside = onclickInside
                self.isInverted = isInverted
                self.user_data = data
                self.invertOnClick = invertOnClick
                self.tags=tags
                self.default_invertDuration = invertDuration
                self.parentLayouts = []
                self.parentPSSMScreen = None

        def __hash__(self):
                return hash(self.id)

        def __eq__(self, other):
                if isinstance(other, self.__class__):
                        return self.id == other.id
                return NotImplemented

        def update(self,newAttributes,skipGeneration=False,skipThisEltGeneration=False,skipPrint=False):
                &#34;&#34;&#34;
                Pass a dict as argument, and it will update the Element&#39;s attributes accordingly
                Args :
                        newAttributes (dict): The element&#39;s new attributes
                        skipGeneration (bool): Just update the element&#39;s attribute, but do not do any generation or printing
                        skipThisEltGeneration (bool): Do not regenerate this element but do update the parent layouts
                        skipPrint (bool): Do not update the screen, but do regenerate.
                &#34;&#34;&#34;
                # First, we set the attributes
                for param in newAttributes:
                        setattr(self, param, newAttributes[param])
                if not skipGeneration:
                        # Then we recreate the pillow image of this particular object
                        if not skipThisEltGeneration:
                                self.generator()
                        if len(self.parentLayouts) &gt; 0:
                                # We recreate the pillow image of the oldest parent
                                # And it is not needed to regenerate standard objects, since
                                oldest_parent = self.parentLayouts[0]
                                oldest_parent.generator(skipNonLayoutEltGeneration=True)
                        #then, let&#39;s reprint the stack
                        if not skipPrint:
                                self.parentPSSMScreen.printStack(area=self.area)
                return True

        def generator(self):
                &#34;&#34;&#34;
                The generator is the function which is called when the container layout wants to
                build an image. It therefore returns a pillow image.
                &#34;&#34;&#34;
                return NotImplemented

        def setInverted(self,mode):
                # TODO : actually invert it ? or delete this function
                self.isInverted = mode</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="Python-Screen-Stack-Manager.pssm.Button" href="#Python-Screen-Stack-Manager.pssm.Button">Button</a></li>
<li><a title="Python-Screen-Stack-Manager.pssm.Icon" href="#Python-Screen-Stack-Manager.pssm.Icon">Icon</a></li>
<li><a title="Python-Screen-Stack-Manager.pssm.Layout" href="#Python-Screen-Stack-Manager.pssm.Layout">Layout</a></li>
<li><a title="Python-Screen-Stack-Manager.pssm.Line" href="#Python-Screen-Stack-Manager.pssm.Line">Line</a></li>
<li><a title="Python-Screen-Stack-Manager.pssm.Rectangle" href="#Python-Screen-Stack-Manager.pssm.Rectangle">Rectangle</a></li>
<li><a title="Python-Screen-Stack-Manager.pssm.RectangleRounded" href="#Python-Screen-Stack-Manager.pssm.RectangleRounded">RectangleRounded</a></li>
<li><a title="Python-Screen-Stack-Manager.pssm.Static" href="#Python-Screen-Stack-Manager.pssm.Static">Static</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="Python-Screen-Stack-Manager.pssm.Element.generator"><code class="name flex">
<span>def <span class="ident">generator</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>The generator is the function which is called when the container layout wants to
build an image. It therefore returns a pillow image.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generator(self):
        &#34;&#34;&#34;
        The generator is the function which is called when the container layout wants to
        build an image. It therefore returns a pillow image.
        &#34;&#34;&#34;
        return NotImplemented</code></pre>
</details>
</dd>
<dt id="Python-Screen-Stack-Manager.pssm.Element.setInverted"><code class="name flex">
<span>def <span class="ident">setInverted</span></span>(<span>self, mode)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setInverted(self,mode):
        # TODO : actually invert it ? or delete this function
        self.isInverted = mode</code></pre>
</details>
</dd>
<dt id="Python-Screen-Stack-Manager.pssm.Element.update"><code class="name flex">
<span>def <span class="ident">update</span></span>(<span>self, newAttributes, skipGeneration=False, skipThisEltGeneration=False, skipPrint=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Pass a dict as argument, and it will update the Element's attributes accordingly
Args :
newAttributes (dict): The element's new attributes
skipGeneration (bool): Just update the element's attribute, but do not do any generation or printing
skipThisEltGeneration (bool): Do not regenerate this element but do update the parent layouts
skipPrint (bool): Do not update the screen, but do regenerate.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update(self,newAttributes,skipGeneration=False,skipThisEltGeneration=False,skipPrint=False):
        &#34;&#34;&#34;
        Pass a dict as argument, and it will update the Element&#39;s attributes accordingly
        Args :
                newAttributes (dict): The element&#39;s new attributes
                skipGeneration (bool): Just update the element&#39;s attribute, but do not do any generation or printing
                skipThisEltGeneration (bool): Do not regenerate this element but do update the parent layouts
                skipPrint (bool): Do not update the screen, but do regenerate.
        &#34;&#34;&#34;
        # First, we set the attributes
        for param in newAttributes:
                setattr(self, param, newAttributes[param])
        if not skipGeneration:
                # Then we recreate the pillow image of this particular object
                if not skipThisEltGeneration:
                        self.generator()
                if len(self.parentLayouts) &gt; 0:
                        # We recreate the pillow image of the oldest parent
                        # And it is not needed to regenerate standard objects, since
                        oldest_parent = self.parentLayouts[0]
                        oldest_parent.generator(skipNonLayoutEltGeneration=True)
                #then, let&#39;s reprint the stack
                if not skipPrint:
                        self.parentPSSMScreen.printStack(area=self.area)
        return True</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="Python-Screen-Stack-Manager.pssm.Icon"><code class="flex name class">
<span>class <span class="ident">Icon</span></span>
<span>(</span><span>file, centered=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>An icon, built from an image</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>file</code></strong> :&ensp;<code>str</code></dt>
<dd>Path to a file, or one of the integrated image (see the icon folder for the name of each image). 'reboot' for instance points to the integrated reboot image.</dd>
<dt><strong><code>centered</code></strong> :&ensp;<code>bool</code></dt>
<dd>Center the icon?</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Icon(Element):
        &#34;&#34;&#34;
        An icon, built from an image
        Args:
                file (str): Path to a file, or one of the integrated image (see the icon folder for the name of each image). &#39;reboot&#39; for instance points to the integrated reboot image.
                centered (bool): Center the icon?
        &#34;&#34;&#34;
        def __init__(self,file,centered=True,**kwargs):
                super().__init__()
                self.file = file
                self.centered = centered
                self.path_to_file = tools_parseKnownImageFile(self.file)
                for param in kwargs:
                        setattr(self, param, kwargs[param])

        def generator(self,area):
                self.area = area
                [(x,y),(w,h)] = area
                icon_size = min(area[1][0],area[1][1])
                iconImg = Image.open(self.path_to_file).convert(self.parentPSSMScreen.colorType).resize((icon_size,icon_size))
                if not self.centered:
                        self.imgData = iconImg
                        return iconImg
                else:
                        img = Image.new(
                                self.parentPSSMScreen.colorType,
                                (w+1,h+1),
                                color=get_Color(&#34;white&#34;,self.parentPSSMScreen.colorType)
                        )
                        img.paste(iconImg, (int(0.5*w-0.5*icon_size), int(0.5*h-0.5*icon_size)))
                        self.imgData = img
                        return img</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="Python-Screen-Stack-Manager.pssm.Element" href="#Python-Screen-Stack-Manager.pssm.Element">Element</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="Python-Screen-Stack-Manager.pssm.Element" href="#Python-Screen-Stack-Manager.pssm.Element">Element</a></b></code>:
<ul class="hlist">
<li><code><a title="Python-Screen-Stack-Manager.pssm.Element.generator" href="#Python-Screen-Stack-Manager.pssm.Element.generator">generator</a></code></li>
<li><code><a title="Python-Screen-Stack-Manager.pssm.Element.update" href="#Python-Screen-Stack-Manager.pssm.Element.update">update</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="Python-Screen-Stack-Manager.pssm.Layout"><code class="flex name class">
<span>class <span class="ident">Layout</span></span>
<span>(</span><span>layout, area=None, background_color='white', **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>A layout is a quite general kind of Element :
If must be given the working area, and a layout, and will generate every element of the layout</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>layout</code></strong> :&ensp;<code>list</code></dt>
<dd>The given layout (see example below). It is basically a list of rows. Each row is a list containing : the height of the row, then as many tuples as you want, each tuple being a (pssm.Element, width) instance</dd>
<dt><strong><code>background_color</code></strong></dt>
<dd>&nbsp;</dd>
<dt><strong><code>area</code></strong></dt>
<dd>&nbsp;</dd>
</dl>
<p>&hellip; all other arguments from the pssm.Element class
Example of usage:
layout_demo = [
[30
],
["h<em>0.1", (None,"?/2"),
(pssm.Button("But1"),200),
(None,"?/2")
],
["?"
],
["p</em>100", (None,"w<em>0.3"),
(pssm.Button("But2"),200),
(None,"w</em>0.3")
],
[30
],
[100, (None,20), (pssm.Button("But3"),200), (None,20), (pssm.Button("nope"),300), (None,10) ],
[40
]
]
myLayout = pssm.Layout(layout_demo,screen.area)
screen.addElt(myLayout)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Layout(Element):
        &#34;&#34;&#34;
        A layout is a quite general kind of Element :
        If must be given the working area, and a layout, and will generate every element of the layout

        Args:
                layout (list): The given layout (see example below). It is basically a list of rows. Each row is a list containing : the height of the row, then as many tuples as you want, each tuple being a (pssm.Element, width) instance
                background_color
                area
                ... all other arguments from the pssm.Element class

        Example of usage:
                layout_demo = [
                [30                                                                                         ],
                [&#34;h*0.1&#34;, (None,&#34;?/2&#34;),        (pssm.Button(&#34;But1&#34;),200),        (None,&#34;?/2&#34;)               ],
                [&#34;?&#34;                                                                                        ],
                [&#34;p*100&#34;, (None,&#34;w*0.3&#34;),       (pssm.Button(&#34;But2&#34;),200),        (None,&#34;w*0.3&#34;)            ],
                [30                                                                                         ],
                [100, (None,20), (pssm.Button(&#34;But3&#34;),200), (None,20), (pssm.Button(&#34;nope&#34;),300), (None,10) ],
                [40                                                                                         ]
            ]
            myLayout = pssm.Layout(layout_demo,screen.area)
            screen.addElt(myLayout)
        &#34;&#34;&#34;
        def __init__(self,layout,area=None,background_color=&#34;white&#34;,**kwargs):
                super().__init__(area=area)
                self.layout      = layout
                self.isValid = self.isLayoutValid()
                self.background_color = background_color
                self.areaMatrix = None
                self.imgMatrix  = None
                self.borders    = None
                self.isLayout   = True
                for param in kwargs:
                        setattr(self, param, kwargs[param])

        def isLayoutValid(self):
                # TODO : to be tested
                l = self.layout
                if not isinstance(l,list):
                        raise Exception(&#34;Layout Element is supposed to be a list&#34;)
                for row in l:
                        if not isinstance(row,list):
                                raise Exception(&#34;A layout row is supposed to be a list&#34;)
                        elif len(row) == 0:
                                raise Exception(&#34;A layout row cannot be empty&#34;)
                        elif not isinstance(row[0],str) and not isinstance(row[0],int):
                                raise Exception(&#34;The first element of a row (its height) should be a string or an integer&#34;)
                        for j in range(1,len(row)):
                                eltTuple = row[j]
                                if not (isinstance(eltTuple,tuple) or isinstance(eltTuple,list)):
                                        raise Exception(&#34;A layout row should be a list of Tuple (except for its first element)&#34;)
                                if len(eltTuple) != 2:
                                        raise Exception(&#34;A layout element should be a Tuple : (Element, elementWidth)&#34;)
                                if not (isinstance(eltTuple[1],str) or isinstance(eltTuple[1],int)):
                                        raise Exception(&#34;An element width should be a string or an integer&#34;)
                                if not (isinstance(eltTuple[0],Element) or eltTuple[0] == None):
                                        raise Exception(&#34;A layout element should be a Tuple : (Element, elementWidth), with Element designating a PSSM Element&#34;)
                return True

        def generator(self,area=None, skipNonLayoutEltGeneration=False):
                &#34;&#34;&#34;
                Builds one img out of all the Elements it is being given
                &#34;&#34;&#34;
                if area != None:
                        self.area = area
                self.createAreaMatrix()
                self.createImgMatrix(skipNonLayoutEltGeneration=skipNonLayoutEltGeneration)
                [(x,y),(w,h)] = self.area
                placeholder = Image.new(
                        self.parentPSSMScreen.colorType,
                        (w,h),
                        color=get_Color(self.background_color,self.parentPSSMScreen.colorType)
                )
                for i in range(len(self.areaMatrix)):
                        for j in range(len(self.areaMatrix[i])):
                                [(elt_x,elt_y),(elt_w,elt_h)] = self.areaMatrix[i][j]
                                relative_x = elt_x - x
                                relative_y = elt_y - y
                                elt_img = self.imgMatrix[i][j]
                                if elt_img != None:
                                        placeholder.paste(self.imgMatrix[i][j],(relative_x,relative_y))
                self.imgData = placeholder
                return self.imgData

        def createImgMatrix(self,skipNonLayoutEltGeneration=False):
                matrix = []
                if not self.areaMatrix:
                        print(&#34;[PSSM Layout Element] Error, areaMatrix has to be defined first&#34;)
                        return None
                for i in range(len(self.layout)):
                        row = []
                        for j in range(1,len(self.layout[i])):
                                myElement,_   = self.layout[i][j]
                                if myElement == None:
                                        myElement_area  = self.areaMatrix[i][j-1]
                                        myElement_img   = None
                                else:
                                        myElement_area  = self.areaMatrix[i][j-1]
                                        if not myElement.isLayout and skipNonLayoutEltGeneration:
                                                myElement_img = myElement.imgData
                                        else:
                                                myElement_img   = myElement.generator(area=myElement_area)
                                row.append(myElement_img)
                        matrix.append(row)
                self.imgMatrix = matrix

        def createAreaMatrix(self):
                # TODO : must honor min and max
                matrix = []
                n_rows = len(self.layout)
                [(x,y),(w,h)] = self.area[:]
                x0,y0=x,y
                for i in range(len(self.layout)):     # Lets loop through the rows
                        row = self.layout[i]
                        row_cols = []           # All the columns of this particular row
                        row_height = row[0]
                        converted_height = self.parentPSSMScreen.convertDimension(row_height)
                        if isinstance(converted_height,int):
                                true_row_height = converted_height
                        else:
                                remaining_height = self.calculate_remainingHeight()
                                true_row_height = int(eval(str(remaining_height) + converted_height[1:]))
                        for j in range(1,len(row)):
                                (element,element_width) = row[j]
                                converted_width = self.parentPSSMScreen.convertDimension(element_width)
                                if element != None:
                                        for parent in self.parentLayouts:
                                                self.layout[i][j][0].parentLayouts.append(parent)
                                        self.layout[i][j][0].parentLayouts.append(self)
                                        self.layout[i][j][0].parentPSSMScreen = self.parentPSSMScreen
                                if isinstance(converted_width,int):
                                        true_element_width = converted_width
                                else:
                                        remaining_width = self.calculate_remainingWidth(i)
                                        true_element_width = int(eval(str(remaining_width) + converted_width[1:]))
                                        self.layout[i][j] = (self.layout[i][j][0], true_element_width)
                                element_area = [(x0,y0),(true_element_width,true_row_height)]
                                x0 += true_element_width
                                row_cols.append(element_area)
                        y0 += true_row_height
                        x0 = x
                        matrix.append(row_cols)
                self.areaMatrix = matrix

        def createEltList(self):
                &#34;&#34;&#34;
                Returns a list of all the elements the Layout Element contains
                &#34;&#34;&#34;
                eltList=[]
                for row in self.layout:
                        for i in range(1,len(row)):
                                elt,_ = row[i]
                                if elt != None:
                                        eltList.append(elt)
                return eltList

        def calculate_remainingHeight(self):
                rows = self.extract_rowsHeight()
                total_questionMarks_weight = 0
                total_height = 0
                for dimension in rows:
                        converted_dimension = self.parentPSSMScreen.convertDimension(dimension)
                        if isinstance(converted_dimension,int):
                                total_height += converted_dimension
                        else:
                                weight = eval(&#34;1&#34; + converted_dimension[1:])
                                total_questionMarks_weight += weight
                layout_height = self.area[1][1]
                return int((layout_height - total_height)/total_questionMarks_weight)

        def calculate_remainingWidth(self,rowIndex):
                cols = self.extract_colsWidth(rowIndex)
                total_width = 0
                total_questionMarks_weight = 0
                for dimension in cols:
                        converted_dimension = self.parentPSSMScreen.convertDimension(dimension)
                        if isinstance(converted_dimension,int):
                                total_width += converted_dimension
                        else:
                                weight = eval(&#34;1&#34; + converted_dimension[1:])
                                total_questionMarks_weight += weight
                layout_width = self.area[1][0]
                return int((layout_width - total_width)/total_questionMarks_weight)

        def extract_rowsHeight(self):
                rows = []
                for row in self.layout:
                        rows.append(row[0])
                return rows

        def extract_colsWidth(self,rowIndex):
                cols = []
                for col in self.layout[rowIndex]:
                        if isinstance(col,tuple):
                                cols.append(col[1])
                return cols

        def dispatchClick(self,coords):
                &#34;&#34;&#34;
                Finds the element on which the user clicked
                &#34;&#34;&#34;
                self.dispatchClick_DICHOTOMY_colsOnly(coords)

        def dispatchClick_LINEAR(self,coords):
                &#34;&#34;&#34;
                Linear search throuh both the rows and the columns
                &#34;&#34;&#34;
                click_x,click_y = coords
                for i in range(len(self.areaMatrix)):                   # Linear search though the rows
                        if len(self.areaMatrix[i]) == 0:
                                # That&#39;s a fake row (a margin row)
                                continue
                        first_row_elt = self.areaMatrix[i][0]
                        last_row_elt = self.areaMatrix[i][-1]
                        x = first_row_elt[0][0]
                        y = first_row_elt[0][1]
                        w = last_row_elt[0][0] + last_row_elt[1][0] - first_row_elt[0][0]
                        h = last_row_elt[0][1] + last_row_elt[1][1] - first_row_elt[0][1]
                        if coordsInArea(click_x, click_y, [(x,y),(w,h)]):               # CLick was in that row
                                for j in range(len(self.areaMatrix[i])):                        # Linear search through the columns
                                        if coordsInArea(click_x,click_y,self.areaMatrix[i][j]):
                                                # Click was on that element
                                                elt,_ = self.layout[i][j+1]
                                                if elt != None and elt.onclickInside != None:
                                                        self.parentPSSMScreen.dispatchClickToElt(coords,elt)
                                                return True
                return False

        def dispatchClick_DICHOTOMY_colsOnly(self,coords):
                &#34;&#34;&#34;
                Linear search through the rows, dichotomy for the columns
                (Because of the empty rows, a dichotomy for the rows doesn&#39;t work)
                &#34;&#34;&#34;
                click_x,click_y = coords
                row_A = -1
                for i in range(len(self.areaMatrix)):                                           # Linear search though the rows
                        if len(self.areaMatrix[i]) == 0:
                                # That&#39;s a fake row (a margin row)
                                continue
                        first_row_elt = self.areaMatrix[i][0]
                        last_row_elt = self.areaMatrix[i][-1]
                        x = first_row_elt[0][0]
                        y = first_row_elt[0][1]
                        w = last_row_elt[0][0] + last_row_elt[1][0] - first_row_elt[0][0]
                        h = last_row_elt[0][1] + last_row_elt[1][1] - first_row_elt[0][1]
                        if coordsInArea(click_x, click_y, [(x,y),(w,h)]):               # CLick was in that row
                                row_A = i
                                break
                if row_A ==-1:
                        return None
                col_A = 0
                col_C = max(len(self.areaMatrix[row_A]) - 1,0)
                xA = self.areaMatrix[row_A][col_A][0][0]
                xC = self.areaMatrix[row_A][col_C][0][0]
                if click_x &lt; xA:
                        return None
                if click_x &gt; xC + self.areaMatrix[row_A][col_C][1][0]:
                        return None
                while col_C &gt; col_A +1:
                        col_B = int(0.5*(col_A+col_C))          # The average of the two
                        xB = self.areaMatrix[row_A][col_B][0][0]
                        if click_x &gt;= xB or col_B==col_C:
                                col_A = col_B
                                xA = xB
                        else:
                                col_C = col_B
                                xC = xB
                ## Element is at indexes row_A, col_A
                elt,_ = self.layout[row_A][col_A+1]
                if elt != None and elt.onclickInside != None:
                        self.parentPSSMScreen.dispatchClickToElt(coords,elt)
                return True

        def dispatchClick_DICHOTOMY_Full_ToBeFixed(self,coords):
                &#34;&#34;&#34;
                Finds the element on which the user clicked
                Implemented with dichotomy search (with the hope of making things faster,
                especially the integrated keyboard)
                &#34;&#34;&#34;
                # TODO : To be fixed
                # For now it does not work, because there are empty rows which break the loop
                click_x,click_y = coords
                row_A = 0
                row_C = max(len(self.areaMatrix) - 1,0)
                print(self.areaMatrix[row_C])
                while len(self.areaMatrix[row_A])==0:
                        row_A += 1
                while len(self.areaMatrix[row_C])==0:
                        row_C -= 1
                yA = self.areaMatrix[row_A][0][0][1]  # First column THEN first row , [(x,y),(w,h)] THUS first tuple of list THEN second coordinate of tuple
                yC = self.areaMatrix[row_C][0][0][1]
                if click_y &lt; yA:
                        return None
                if click_y &gt; yC + self.areaMatrix[row_C][0][1][1]:
                        return None
                while row_C &gt; row_A+1:
                        row_B = int(0.5*(row_A+row_C))          # The average of the two
                        while len(self.areaMatrix[row_B])==0:
                                row_B += 1
                        yB = self.areaMatrix[row_B][0][0][1]
                        if click_y &gt;= yB or row_B==row_C:
                                row_A = row_B
                                yA = yB
                        else:
                                row_C = row_B
                                yC = yB
                # User clicked on element ar row of index row_A
                # Let&#39;s do the same for the column
                col_A = 0
                col_C = max(len(self.areaMatrix[row_A]) - 1,0)
                xA = self.areaMatrix[row_A][col_A][0][0]
                xC = self.areaMatrix[row_A][col_C][0][0]
                if click_x &lt; xA:
                        return None
                if click_x &gt; xC + self.areaMatrix[row_A][col_C][1][0]:
                        return None
                while col_C &gt; col_A +1:
                        col_B = int(0.5*(col_A+col_C))          # The average of the two
                        xB = self.areaMatrix[row_A][col_B][0][0]
                        if click_x &gt;= xB or col_B==col_C:
                                col_A = col_B
                                xA = xB
                        else:
                                col_C = col_B
                                xC = xB
                ## Element is at indexes row_A, col_A
                elt,_ = self.layout[row_A-2][col_A+1]
                if elt != None and elt.onclickInside != None:
                        self.parentPSSMScreen.dispatchClickToElt(coords,elt)
                return True</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="Python-Screen-Stack-Manager.pssm.Element" href="#Python-Screen-Stack-Manager.pssm.Element">Element</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="Python-Screen-Stack-Manager.pssm.ButtonList" href="#Python-Screen-Stack-Manager.pssm.ButtonList">ButtonList</a></li>
<li><a title="Python-Screen-Stack-Manager.pssm.OSK" href="#Python-Screen-Stack-Manager.pssm.OSK">OSK</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="Python-Screen-Stack-Manager.pssm.Layout.createEltList"><code class="name flex">
<span>def <span class="ident">createEltList</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a list of all the elements the Layout Element contains</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def createEltList(self):
        &#34;&#34;&#34;
        Returns a list of all the elements the Layout Element contains
        &#34;&#34;&#34;
        eltList=[]
        for row in self.layout:
                for i in range(1,len(row)):
                        elt,_ = row[i]
                        if elt != None:
                                eltList.append(elt)
        return eltList</code></pre>
</details>
</dd>
<dt id="Python-Screen-Stack-Manager.pssm.Layout.isLayoutValid"><code class="name flex">
<span>def <span class="ident">isLayoutValid</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def isLayoutValid(self):
        # TODO : to be tested
        l = self.layout
        if not isinstance(l,list):
                raise Exception(&#34;Layout Element is supposed to be a list&#34;)
        for row in l:
                if not isinstance(row,list):
                        raise Exception(&#34;A layout row is supposed to be a list&#34;)
                elif len(row) == 0:
                        raise Exception(&#34;A layout row cannot be empty&#34;)
                elif not isinstance(row[0],str) and not isinstance(row[0],int):
                        raise Exception(&#34;The first element of a row (its height) should be a string or an integer&#34;)
                for j in range(1,len(row)):
                        eltTuple = row[j]
                        if not (isinstance(eltTuple,tuple) or isinstance(eltTuple,list)):
                                raise Exception(&#34;A layout row should be a list of Tuple (except for its first element)&#34;)
                        if len(eltTuple) != 2:
                                raise Exception(&#34;A layout element should be a Tuple : (Element, elementWidth)&#34;)
                        if not (isinstance(eltTuple[1],str) or isinstance(eltTuple[1],int)):
                                raise Exception(&#34;An element width should be a string or an integer&#34;)
                        if not (isinstance(eltTuple[0],Element) or eltTuple[0] == None):
                                raise Exception(&#34;A layout element should be a Tuple : (Element, elementWidth), with Element designating a PSSM Element&#34;)
        return True</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="Python-Screen-Stack-Manager.pssm.Element" href="#Python-Screen-Stack-Manager.pssm.Element">Element</a></b></code>:
<ul class="hlist">
<li><code><a title="Python-Screen-Stack-Manager.pssm.Element.update" href="#Python-Screen-Stack-Manager.pssm.Element.update">update</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="Python-Screen-Stack-Manager.pssm.Line"><code class="flex name class">
<span>class <span class="ident">Line</span></span>
<span>(</span><span>color='black', width=1, type='horizontal')</span>
</code></dt>
<dd>
<div class="desc"><p>Draws a simple line</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>color</code></strong> :&ensp;<code>str</code> or <code>tuple</code></dt>
<dd>"white", "black", "gray0" to "gray15" or a (red, green, blue, transparency) tuple</dd>
<dt><strong><code>width</code></strong> :&ensp;<code>int</code></dt>
<dd>The width of the line</dd>
<dt><strong><code>type</code></strong> :&ensp;<code>str</code></dt>
<dd>can be "horizontal", "vertical", "diagonal1" (top-left to bottom right) or "diagonal2" (top-right to bottom-left)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Line(Element):
        &#34;&#34;&#34;
    Draws a simple line
    Args:
        color (str or tuple): &#34;white&#34;, &#34;black&#34;, &#34;gray0&#34; to &#34;gray15&#34; or a (red, green, blue, transparency) tuple
        width (int): The width of the line
        type (str): can be &#34;horizontal&#34;, &#34;vertical&#34;, &#34;diagonal1&#34; (top-left to bottom right) or &#34;diagonal2&#34; (top-right to bottom-left)
    &#34;&#34;&#34;
        def __init__(self,color=&#34;black&#34;,width=1,type=&#34;horizontal&#34;):
                super().__init__()
                self.color = color
                self.width = width
                self.type  = type

        def generator(self,area):
                (x,y),(w,h) = area
                self.area = area
                if self.type == &#34;horizontal&#34;:
                        coo = [(0,0),(w,0)]
                elif self.type == &#34;vertical&#34;:
                        coo = [(0,0),(0,h)]
                elif self.type == &#34;diagonal1&#34;:
                        coo = [(0,0),(w,h)]
                else: # Assuming diagonal2
                        coo = [(w,0),(0,h)]
                rectangle = Image.new(
                        self.parentPSSMScreen.colorType,
                        (w,h),
                        color=get_Color(&#34;white&#34;,self.parentPSSMScreen.colorType)
                )
                draw = ImageDraw.Draw(rectangle)
                draw.line(
                        coo,
                        fill  = get_Color(self.color, self.parentPSSMScreen.colorType),
                        width = self.width
                )
                self.imgData = rectangle
                return self.imgData</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="Python-Screen-Stack-Manager.pssm.Element" href="#Python-Screen-Stack-Manager.pssm.Element">Element</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="Python-Screen-Stack-Manager.pssm.Element" href="#Python-Screen-Stack-Manager.pssm.Element">Element</a></b></code>:
<ul class="hlist">
<li><code><a title="Python-Screen-Stack-Manager.pssm.Element.generator" href="#Python-Screen-Stack-Manager.pssm.Element.generator">generator</a></code></li>
<li><code><a title="Python-Screen-Stack-Manager.pssm.Element.update" href="#Python-Screen-Stack-Manager.pssm.Element.update">update</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="Python-Screen-Stack-Manager.pssm.OSK"><code class="flex name class">
<span>class <span class="ident">OSK</span></span>
<span>(</span><span>keymapPath={'standard': DEFAULT_KEYMAP_PATH, 'caps': DEFAULT_KEYMAP_PATH_CAPS, 'alt': DEFAULT_KEYMAP_PATH_ALT}, onkeyPress=None, area=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>A PSSM Layout element which builds an on-screen keyboard</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>keymapPath</code></strong> :&ensp;<code>str</code></dt>
<dd>a path to a PSSMOSK keymap (like the one included)</dd>
<dt><strong><code>onkeyPress</code></strong> :&ensp;<code>function</code></dt>
<dd>A callback function. Will be given keyType and keyChar as argument</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class OSK(Layout):
        &#34;&#34;&#34;
        A PSSM Layout element which builds an on-screen keyboard
        Args:
                keymapPath (str): a path to a PSSMOSK keymap (like the one included)
                onkeyPress (function): A callback function. Will be given keyType and keyChar as argument
        &#34;&#34;&#34;
        def __init__(self,keymapPath=DEFAULT_KEYMAP_PATH,onkeyPress = None, area=None,**kwargs):
                if not keymapPath:
                        keymapPath = DEFAULT_KEYMAP_PATH
                self.keymapPaths = keymapPath
                self.keymap = {&#39;standard&#39;:None,&#39;caps&#39;:None,&#39;alt&#39;:None}
                self.keymap_layouts = {&#39;standard&#39;:None,&#39;caps&#39;:None,&#39;alt&#39;:None}
                self.keymap_imgs = {&#39;standard&#39;:None,&#39;caps&#39;:None,&#39;alt&#39;:None}
                with open(self.keymapPaths[&#39;standard&#39;]) as json_file:
                        self.keymap[&#39;standard&#39;] = json.load(json_file)
                with open(self.keymapPaths[&#39;caps&#39;]) as json_file:
                        self.keymap[&#39;caps&#39;] = json.load(json_file)
                with open(self.keymapPaths[&#39;alt&#39;]) as json_file:
                        self.keymap[&#39;alt&#39;] = json.load(json_file)
                self.lang       = self.keymap[&#39;standard&#39;][&#34;lang&#34;]
                self.onkeyPress = onkeyPress
                for param in kwargs:
                        setattr(self, param, kwargs[param])
                self.view = &#39;standard&#39;
                self.keymap_layouts[&#39;standard&#39;] = self.build_layout(self.keymap[&#39;standard&#39;])
                self.keymap_layouts[&#39;caps&#39;] = self.build_layout(self.keymap[&#39;caps&#39;])
                self.keymap_layouts[&#39;alt&#39;] = self.build_layout(self.keymap[&#39;alt&#39;])
                # Initialize layout with standard view
                self.layout = self.keymap_layouts[&#39;standard&#39;]
                super().__init__(self.layout)
                self.area       = area

        def generator(self, area=None, forceRegenerate = False):
                &#34;&#34;&#34;
                This generator is a bit special : we don&#39;t want it to regenerate everything
                everytime we change view. So we will generate all the views at once the first time.
                Then, unless asked to, we will only return the appropriate image
                &#34;&#34;&#34;
                if forceRegenerate or (not self.keymap_imgs[&#39;standard&#39;]) or (not self.keymap_imgs[&#39;caps&#39;]) or (not self.keymap_imgs[&#39;alt&#39;]):
                        print(&#34;[PSSM OSK] Regenration started&#34;)
                        # Let&#39;s create all the Images
                        # Standard view is created last, because it is the one which is to be displayed
                        self.layout = self.keymap_layouts[&#39;caps&#39;]
                        self.keymap_imgs[&#39;caps&#39;] = super(OSK, self).generator(area=area)
                        self.layout = self.keymap_layouts[&#39;alt&#39;]
                        self.keymap_imgs[&#39;alt&#39;] = super(OSK, self).generator(area=area)
                        self.layout = self.keymap_layouts[&#39;standard&#39;]
                        self.keymap_imgs[&#39;standard&#39;] = super(OSK, self).generator(area=area)
                self.imgData = self.keymap_imgs[self.view]
                return self.keymap_imgs[self.view]

        def build_layout(self,keymap):
                oskLayout = []
                spacing = keymap[&#34;spacing&#34;]
                for row in keymap[&#34;rows&#34;]:
                        buttonRow = [&#34;?&#34;,(None,spacing)]
                        for key in row:
                                label = self.getKeyLabel(key)
                                color_condition         = key[&#34;keyType&#34;] != KTstandardChar
                                background_color        = &#34;gray12&#34; if color_condition else &#34;white&#34;
                                outline_color           = &#34;white&#34; if key[&#34;isPadding&#34;] else &#34;black&#34;
                                buttonElt = Button(
                                        text                            = label,
                                        font_size                       = &#34;h*0.02&#34;,
                                        background_color        = background_color,
                                        outline_color           = outline_color,
                                        onclickInside           = self.handleKeyPress,
                                        user_data                       = key,
                                        wrap_textOverflow       = False,
                                        invertOnClick           = True
                                )
                                key_width = key[&#34;keyWidth&#34;]
                                buttonRow.append((buttonElt,key_width))
                                buttonRow.append((None,spacing))
                        oskLayout.append(buttonRow)
                        oskLayout.append([spacing])
                return oskLayout

        def handleKeyPress(self,elt,coords):
                keyType = elt.user_data[&#34;keyType&#34;]
                keyChar = elt.user_data[&#34;char&#34;]
                if keyType == KTcapsLock:
                        ## In this particular case, we can assume the keyboard will always be on top
                        ## Therefore, no need to print everything, let&#39;s just print the keyboard
                        self.view = &#39;caps&#39; if self.view != &#39;caps&#39; else &#39;standard&#39;
                        self.layout = self.keymap_layouts[self.view]
                        self.createAreaMatrix()
                        self.update(
                            newAttributes={},
                            skipGeneration = True
                        )
                        self.parentPSSMScreen.simplePrintElt(self)
                elif keyType == KTalt:
                        ## In this particular case, we can assume the keyboard will always be on top
                        ## Therefore, no need to print everything, let&#39;s just print the keyboard
                        self.view = &#39;alt&#39; if self.view != &#39;alt&#39; else &#39;standard&#39;
                        self.layout = self.keymap_layouts[self.view]
                        self.createAreaMatrix()
                        self.update(
                            newAttributes={},
                            skipGeneration = True
                        )
                        self.parentPSSMScreen.simplePrintElt(self)
                if self.onkeyPress:
                        self.onkeyPress(keyType,keyChar)


        def getKeyLabel(self,key):
                kt = key[&#34;keyType&#34;]
                if kt == KTstandardChar:
                        return key[&#34;char&#34;]
                elif kt == KTalt:
                        return &#34;ALT&#34;
                elif kt == KTbackspace:
                        return &#34;BACK&#34;
                elif kt == KTcapsLock:
                        return &#34;CAPS&#34;
                elif kt == KTcarriageReturn:
                        return &#34;RET&#34;
                elif kt == KTcontrol:
                        return &#34;CTRL&#34;
                elif kt == KTdelete:
                        return &#34;DEL&#34;
                return &#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="Python-Screen-Stack-Manager.pssm.Layout" href="#Python-Screen-Stack-Manager.pssm.Layout">Layout</a></li>
<li><a title="Python-Screen-Stack-Manager.pssm.Element" href="#Python-Screen-Stack-Manager.pssm.Element">Element</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="Python-Screen-Stack-Manager.pssm.OSK.build_layout"><code class="name flex">
<span>def <span class="ident">build_layout</span></span>(<span>self, keymap)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def build_layout(self,keymap):
        oskLayout = []
        spacing = keymap[&#34;spacing&#34;]
        for row in keymap[&#34;rows&#34;]:
                buttonRow = [&#34;?&#34;,(None,spacing)]
                for key in row:
                        label = self.getKeyLabel(key)
                        color_condition         = key[&#34;keyType&#34;] != KTstandardChar
                        background_color        = &#34;gray12&#34; if color_condition else &#34;white&#34;
                        outline_color           = &#34;white&#34; if key[&#34;isPadding&#34;] else &#34;black&#34;
                        buttonElt = Button(
                                text                            = label,
                                font_size                       = &#34;h*0.02&#34;,
                                background_color        = background_color,
                                outline_color           = outline_color,
                                onclickInside           = self.handleKeyPress,
                                user_data                       = key,
                                wrap_textOverflow       = False,
                                invertOnClick           = True
                        )
                        key_width = key[&#34;keyWidth&#34;]
                        buttonRow.append((buttonElt,key_width))
                        buttonRow.append((None,spacing))
                oskLayout.append(buttonRow)
                oskLayout.append([spacing])
        return oskLayout</code></pre>
</details>
</dd>
<dt id="Python-Screen-Stack-Manager.pssm.OSK.generator"><code class="name flex">
<span>def <span class="ident">generator</span></span>(<span>self, area=None, forceRegenerate=False)</span>
</code></dt>
<dd>
<div class="desc"><p>This generator is a bit special : we don't want it to regenerate everything
everytime we change view. So we will generate all the views at once the first time.
Then, unless asked to, we will only return the appropriate image</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generator(self, area=None, forceRegenerate = False):
        &#34;&#34;&#34;
        This generator is a bit special : we don&#39;t want it to regenerate everything
        everytime we change view. So we will generate all the views at once the first time.
        Then, unless asked to, we will only return the appropriate image
        &#34;&#34;&#34;
        if forceRegenerate or (not self.keymap_imgs[&#39;standard&#39;]) or (not self.keymap_imgs[&#39;caps&#39;]) or (not self.keymap_imgs[&#39;alt&#39;]):
                print(&#34;[PSSM OSK] Regenration started&#34;)
                # Let&#39;s create all the Images
                # Standard view is created last, because it is the one which is to be displayed
                self.layout = self.keymap_layouts[&#39;caps&#39;]
                self.keymap_imgs[&#39;caps&#39;] = super(OSK, self).generator(area=area)
                self.layout = self.keymap_layouts[&#39;alt&#39;]
                self.keymap_imgs[&#39;alt&#39;] = super(OSK, self).generator(area=area)
                self.layout = self.keymap_layouts[&#39;standard&#39;]
                self.keymap_imgs[&#39;standard&#39;] = super(OSK, self).generator(area=area)
        self.imgData = self.keymap_imgs[self.view]
        return self.keymap_imgs[self.view]</code></pre>
</details>
</dd>
<dt id="Python-Screen-Stack-Manager.pssm.OSK.getKeyLabel"><code class="name flex">
<span>def <span class="ident">getKeyLabel</span></span>(<span>self, key)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getKeyLabel(self,key):
        kt = key[&#34;keyType&#34;]
        if kt == KTstandardChar:
                return key[&#34;char&#34;]
        elif kt == KTalt:
                return &#34;ALT&#34;
        elif kt == KTbackspace:
                return &#34;BACK&#34;
        elif kt == KTcapsLock:
                return &#34;CAPS&#34;
        elif kt == KTcarriageReturn:
                return &#34;RET&#34;
        elif kt == KTcontrol:
                return &#34;CTRL&#34;
        elif kt == KTdelete:
                return &#34;DEL&#34;
        return &#34;&#34;</code></pre>
</details>
</dd>
<dt id="Python-Screen-Stack-Manager.pssm.OSK.handleKeyPress"><code class="name flex">
<span>def <span class="ident">handleKeyPress</span></span>(<span>self, elt, coords)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def handleKeyPress(self,elt,coords):
        keyType = elt.user_data[&#34;keyType&#34;]
        keyChar = elt.user_data[&#34;char&#34;]
        if keyType == KTcapsLock:
                ## In this particular case, we can assume the keyboard will always be on top
                ## Therefore, no need to print everything, let&#39;s just print the keyboard
                self.view = &#39;caps&#39; if self.view != &#39;caps&#39; else &#39;standard&#39;
                self.layout = self.keymap_layouts[self.view]
                self.createAreaMatrix()
                self.update(
                    newAttributes={},
                    skipGeneration = True
                )
                self.parentPSSMScreen.simplePrintElt(self)
        elif keyType == KTalt:
                ## In this particular case, we can assume the keyboard will always be on top
                ## Therefore, no need to print everything, let&#39;s just print the keyboard
                self.view = &#39;alt&#39; if self.view != &#39;alt&#39; else &#39;standard&#39;
                self.layout = self.keymap_layouts[self.view]
                self.createAreaMatrix()
                self.update(
                    newAttributes={},
                    skipGeneration = True
                )
                self.parentPSSMScreen.simplePrintElt(self)
        if self.onkeyPress:
                self.onkeyPress(keyType,keyChar)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="Python-Screen-Stack-Manager.pssm.Layout" href="#Python-Screen-Stack-Manager.pssm.Layout">Layout</a></b></code>:
<ul class="hlist">
<li><code><a title="Python-Screen-Stack-Manager.pssm.Layout.createEltList" href="#Python-Screen-Stack-Manager.pssm.Layout.createEltList">createEltList</a></code></li>
<li><code><a title="Python-Screen-Stack-Manager.pssm.Layout.dispatchClick" href="#Python-Screen-Stack-Manager.pssm.Layout.dispatchClick">dispatchClick</a></code></li>
<li><code><a title="Python-Screen-Stack-Manager.pssm.Layout.dispatchClick_DICHOTOMY_Full_ToBeFixed" href="#Python-Screen-Stack-Manager.pssm.Layout.dispatchClick_DICHOTOMY_Full_ToBeFixed">dispatchClick_DICHOTOMY_Full_ToBeFixed</a></code></li>
<li><code><a title="Python-Screen-Stack-Manager.pssm.Layout.dispatchClick_DICHOTOMY_colsOnly" href="#Python-Screen-Stack-Manager.pssm.Layout.dispatchClick_DICHOTOMY_colsOnly">dispatchClick_DICHOTOMY_colsOnly</a></code></li>
<li><code><a title="Python-Screen-Stack-Manager.pssm.Layout.dispatchClick_LINEAR" href="#Python-Screen-Stack-Manager.pssm.Layout.dispatchClick_LINEAR">dispatchClick_LINEAR</a></code></li>
<li><code><a title="Python-Screen-Stack-Manager.pssm.Layout.update" href="#Python-Screen-Stack-Manager.pssm.Element.update">update</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="Python-Screen-Stack-Manager.pssm.PSSMScreen"><code class="flex name class">
<span>class <span class="ident">PSSMScreen</span></span>
<span>(</span><span>deviceName, name='screen', stack=[], isInverted=False)</span>
</code></dt>
<dd>
<div class="desc"><p>This is the class which handles most of the logic.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>deviceName</code></strong> :&ensp;<code>str</code></dt>
<dd>"Kobo" for Kobo ereaders (and probably all FBInk supported devices)</dd>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>The name of the class instance (deprecated, I will eventually remove it)</dd>
<dt><strong><code>stack</code></strong> :&ensp;<code>list</code></dt>
<dd>Do not use it unless you know what you are doing. It is the list of all the pssm Elements which are on the screen</dd>
</dl>
<p>isInverted (bool)
Example of usage:
screen = pssm.PSSMScreen("Kobo","Main"))</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PSSMScreen:
        &#34;&#34;&#34;
        This is the class which handles most of the logic.

        Args:
                deviceName (str): &#34;Kobo&#34; for Kobo ereaders (and probably all FBInk supported devices)
                name (str): The name of the class instance (deprecated, I will eventually remove it)
                stack (list): Do not use it unless you know what you are doing. It is the list of all the pssm Elements which are on the screen
                isInverted (bool)

        Example of usage:
                screen = pssm.PSSMScreen(&#34;Kobo&#34;,&#34;Main&#34;))

        &#34;&#34;&#34;
        def __init__(
                        self,
                        deviceName,
                        name=&#34;screen&#34;,
                        stack=[],
                        isInverted=False
                ):
                if deviceName == &#34;Kobo&#34;:
                        import devices.kobo.device as pssm_device
                else:
                        import devices.emulator.device as pssm_device
                self.device = pssm_device
                self.colorType = self.device.colorType
                self.width = self.device.screen_width
                self.height = self.device.screen_height
                self.view_width = self.device.view_width
                self.view_height = self.device.view_height
                self.w_offset = self.device.w_offset
                self.h_offset = self.device.h_offset
                self.area = [(0,0),(self.view_width,self.view_height)]
                self.name = name
                self.stack = stack
                self.isInverted = isInverted
                self.isInputThreadStarted = False
                self.lastX = -1
                self.lastY = -1
                self.osk = None
                self.onKeyPress = None
                self.isKeyboardShown = False

        def findEltWithId(self,myElementId,stack=None):
                &#34;&#34;&#34;
                Returns the element which has such an ID.
                Avoid using this function as much as possible, as it is really not Performance-friendly
                (Recursive search through all the elements of the stack)
                And anyway there is no reason why you should use it.
                &#34;&#34;&#34;
                if stack == None:
                        stack = self.stack
                for elt in stack:
                        if elt.id == myElementId:
                                return elt
                        elif elt.isLayout:
                                layoutEltList = elt.createEltList()
                                search = self.findEltWithId(myElementId,stack=layoutEltList)
                                if search != None:
                                        return search
                return None

        def printStack(self,area=None):
                &#34;&#34;&#34;
                Prints the stack Elements in the stack order
                If a area is set, then, we only display
                the part of the stack which is in this area
                &#34;&#34;&#34;
                #TODO : Must be retought to work with the new nested structure
                #TODO : Must honor the &#39;area&#39; argument
                # for now it will just reprint the whole stack
                white = get_Color(&#34;white&#34;,self.colorType)
                placeholder = Image.new(self.colorType, (self.width, self.height), color=white)
                for elt in self.stack:
                        [(x,y),(w,h)] = elt.area
                        placeholder.paste(elt.imgData, (x,y))
                [(x,y),(w,h)] = self.area
                self.device.print_pil(placeholder,x, y, w, h, isInverted=self.isInverted)

        def getPartialEltImg(self,elt,rectIntersection):
                &#34;&#34;&#34;
                Returns a PIL image of the the interesection of the Element image and the
                rectangle coordinated given as parameter.
                        elt : a PSSM Element
                        rectIntersection : a [[x1,y1],[x2,y2]] array
                &#34;&#34;&#34;
                #TODO : MUST HONOR INVERSION
                # We crop and print a part of the Element
                # First, lets make a PILLOW Element:
                [(x,y),(w,h)] = elt.area
                img = deepcopy(elt.imgData)
                # Then, lets crop it:
                img = img.crop((rectIntersection[0][0]-x, rectIntersection[0][1]-y, rectIntersection[1][0]-x, rectIntersection[1][1]-y))
                if elt.isInverted:
                        inverted_img = PILInvert(img)
                        return inverted_img
                else:
                        return img

        def simplePrintElt(self,myElement,skipGeneration = False):
                &#34;&#34;&#34;
                Prints the Element without adding it to the stack.
                Args:
                        myElement (PSSM Element): The element you want to display
                        skipGeneration (bool): Do you want to regenerate the image?
                &#34;&#34;&#34;
                if not skipGeneration:
                        # First, the element must be generated
                        myElement.generator()
                # Then, we print it
                [(x,y),(w,h)] = myElement.area
                # What follows is a Workaround :
                # TODO : this Workaround must be investigated
                if not myElement.isLayout:
                        w += 1
                        h += 1
                self.device.print_pil(myElement.imgData,x, y, w, h, isInverted=myElement.isInverted)

        def createCanvas(self,color=&#34;white&#34;):
                &#34;&#34;&#34;
                (Deprecated)
                Creates a white Element at the bottom of the stack, displays it while refreshing the screen.
                &#34;&#34;&#34;
                color = get_Color(color,self.colorType)
                img = Image.new(self.colorType, (self.width,self.height), color=color)
                background = Static(img,0,0,name=&#34;Canvas&#34;)
                self.addElt(background)

        def addElt(self,myElement,skipPrint=False,skipRegistration=False):
                &#34;&#34;&#34;
                Adds Element to the stack and prints it
                        myElement (PSSM Element): The Element you want to add
                        skipPrint (bool): True if you don&#39;t want to update the screen
                        skipRegistration (bool): True if you don&#39;t want to add the Element to the stack
                &#34;&#34;&#34;
                for i in range(len(self.stack)):
                        elt=self.stack[i]
                        if elt.id == myElement.id:
                                # There is already an Element in the stack with the same ID.
                                # Let&#39;s update the Element in the stack
                                if not skipPrint:
                                        self.stack[i] = myElement
                                        self.printStack(area=myElement.area)
                                break   #The Element is already in the stack
                else:
                        # the Element is not already in the stack
                        if not skipRegistration:
                                # We append the element to the stack
                                myElement.parentPSSMScreen = self
                                self.stack.append(myElement)
                                if not skipPrint:
                                        if self.isKeyboardShown:
                                                #TODO : make it faster, we only need to display the image behind the keyboard, not reprint everything
                                                myElement.generator()
                                                self.printStack(area=myElement.area)
                                        else:
                                                #No keyboard on the horizon, let&#39;s do it
                                                self.simplePrintElt(myElement)

        def removeElt(self,elt=None,eltid=None,skipPrint=False):
                &#34;&#34;&#34;
                Removes the Element from the stack and hides it from the screen
                &#34;&#34;&#34;
                if elt:
                        self.stack.remove(elt)
                        if not skipPrint:
                                self.printStack(area=elt.area)
                elif eltid :
                        elt = self.findEltWithId(myElementId)
                        if elt:
                                self.stack.remove(elt)
                                if not skipPrint:
                                        self.printStack(area=elt.area)
                else:
                        print(&#39;No element given&#39;)

        def getTagList(self):
                &#34;&#34;&#34;
                Returns the set of all tags from all Elements in the stack
                &#34;&#34;&#34;
                tags={}
                for elt in self.stack:
                        tags.update(elt.tags)
                return tags

        def removeAllWithTag(self,tag):
                &#34;&#34;&#34;
                Removes every Element from the stack which have the specified tag
                &#34;&#34;&#34;
                stackCopy = deepcopy(self.stack) #It is unsage to loop through a mutable list which is being edited afterwards : some items are skipped
                for elt in stackCopy:
                        if tag in elt.tags:
                                self.removeElt(elt.id,skipPrint=True,weAlreadyHaveTheElt=elt)
                #Then we reprint the whole screen (yeah, the *whole* screen... Performance is not our goal)
                self.printStack()

        def invertAllWithTag(self,tag,invertDuration=-1):
                &#34;&#34;&#34;
                Removes all the Element which have a specific tag
                &#34;&#34;&#34;
                stackCopy = deepcopy(self.stack) #It is unsage to loop through a mutable list which is being edited afterwards : some items are skipped
                for elt in stackCopy:
                        if tag in elt.tags:
                                self.invertElt(myElementId=elt.id,invertDuration=-1,skipPrint=True)
                #Then we reprint the whole screen (yeah, the *whole* screen... Performance is not our goal)
                self.printStack()
                # If an invert duration is given, then start a timer to go back to the original state
                if invertDuration&gt;0:
                        threading.Timer(invertDuration,self.invertAllWithTag,[tag,-1]).start()

        def getStackLevel(self,myElementId):
                elt = self.findEltWithId(myElementId)
                return self.stack.index(elt)

        def setStackLevel(self,myElementId,stackLevel=&#34;last&#34;):
                &#34;&#34;&#34;
                Set the position of said Element
                Then prints every Element above it (including itself)
                &#34;&#34;&#34;
                #TODO : Must be able to accept another stackLevel
                if stackLevel==&#34;last&#34; or stackLevel==-1:
                        stackLevel=len(self.stack)
                        elt = self.findEltWithId(myElementId)
                        self.removeElt(myElementId,skipPrint=True)
                        self.stack.insert(stackLevel,elt)
                        self.printStack(area=[elt.xy,elt.xy2])
                        return True

        def invertElt(self,myElementId,invertDuration=-1,skipPrint=False):
                &#34;&#34;&#34;
                Inverts an Element
                &gt; myElementId
                &gt; invertDuration (int) : -1 or 0 if permanent, else an integer
                &#34;&#34;&#34;
                myElement = self.findEltWithId(myElementId)
                if myElement==None:
                        return False
                # First, let&#39;s get the Element&#39;s initial inverted state
                Element_initial_state = bool(myElement.isInverted)
                # Then, we change the Element&#39;s state
                myElement.setInverted(not Element_initial_state)
                if not skipPrint:
                        # Then we print the inverted version
                        self.printStack(skipEltId=None, area=myElement.area)
                # Then, if an invertDuration is given, we setup a timer to go back to the original state
                if invertDuration and invertDuration&gt;0:
                        #Then, we start a timer to set it back to its intial state
                        threading.Timer(invertDuration,myElement.setInverted,[Element_initial_state]).start()
                        threading.Timer(invertDuration,self.invertElt,[myElementId,-1]).start()

        def invertArea(self,area,invertDuration,isInverted=False):
                &#34;&#34;&#34;
                Inverts an area
                &#34;&#34;&#34;
                # TODO: To be tested
                initial_mode = isInverted
                self.device.do_screen_refresh(
                        isInverted      = not isInverted,
                        area            = area,
                        isPermanent     = False,
                        isFlashing      = False,
                        w_offset        = self.w_offset,
                        h_offset        = self.h_offset
                )
                if invertDuration&gt;0:
                        # Now we call this funcion, without starting a timer
                        # And the screen is now in an opposite state as the initial one
                        threading.Timer(invertDuration,self.invertArea,[area,-1,not initial_mode]).start()
                return True

        def invert(self):
                &#34;&#34;&#34;
                Inverts the whole screen
                &#34;&#34;&#34;
                self.isInverted = not self.isInverted
                self.device.do_screen_refresh(self.isInverted)
                return True

        def refresh(self):
                &#34;&#34;&#34;
                Refreshes the screeen
                &#34;&#34;&#34;
                self.device.do_screen_refresh()
                return True

        def clear(self):
                &#34;&#34;&#34;
                Clears the screen
                &#34;&#34;&#34;
                self.device.do_screen_clear()
                return True

        def convertDimension(self,dimension):
                if isinstance(dimension,int):
                        return dimension
                else:
                        t  = dimension[0]
                        op = dimension[1:]
                        if t == &#34;p&#34;:
                                return int(eval(&#34;1&#34; + op))
                        elif t== &#34;w&#34;:
                                return int(eval(str(self.width) + op))
                        elif t== &#34;h&#34;:
                                return int(eval(str(self.height) + op))
                        else:
                                return dimension

        def OSKInit(
                        self,
                        onKeyPress = None,
                        area = None,
                        keymapPath = None
                ):
                if not area:
                        area = [(0,int(2*self.view_height/3)),(self.view_width,int(self.view_height/3))]
                self.onKeyPress = onKeyPress
                self.osk = OSK(onkeyPress = self.onKeyPress, area = area, keymapPath = keymapPath)

        def OSKShow(self):
                if not self.osk:
                        print(&#34;OSK not initialized, it can&#39;t be shown&#34;)
                        return None
                self.addElt(self.osk)   # It has already been generated
                self.isKeyboardShown = True

        def OSKHide(self):
                self.removeElt(elt=self.osk)
                self.isKeyboardShown = False

        def startListenerThread(self,grabInput=False):
                &#34;&#34;&#34;
                Starts the touch listener as a separate thread
                &gt; grabInput : (boolean) Whether to do an EVIOCGRAB IOCTL call to prevent
                        another software from registering touch events
                &#34;&#34;&#34;
                self.isInputThreadStarted = True
                self.device.isInputThreadStarted = True
                print(&#34;[PSSM - Touch handler] : Input thread started&#34;)
                args = [self.clickHandler,True,grabInput]
                inputThread = threading.Thread(target=self.device.eventBindings,args=args)
                inputThread.start()

        def clickHandler(self,x,y):
                n = len(self.stack)
                for i in range(n):
                        j = n-1-i       # We go through the stack in descending order
                        elt = self.stack[j]
                        if elt.area == None:
                                # An object without area, it should not happen, but if it does,
                                # it can be skipped
                                continue
                        if coordsInArea(x,y,elt.area):
                                if elt.onclickInside != None:
                                        self.lastX = x
                                        self.lastY = y
                                        if elt != None:
                                                self.dispatchClickToElt((x,y),elt)
                                break           # we quit the for loop

        def dispatchClickToElt(self,coords,elt):
                &#34;&#34;&#34;
                Once given an object on which the user clicked, this function calls the
                appropriate function on the object (ie elt.onclickInside or elt.dispatchClick)
                It also handles inversion.
                &#34;&#34;&#34;
                if elt.isLayout:
                        if elt.onclickInside != None:
                                elt.onclickInside(elt,coords)
                        if elt.invertOnClick:
                                self.invertArea(elt.area,elt.default_invertDuration)
                        elt.dispatchClick(coords)
                else:
                        if elt.invertOnClick:
                                self.invertArea(elt.area,elt.default_invertDuration)
                        elt.onclickInside(elt,coords)

        def stopListenerThread(self):
                self.isInputThreadStarted = False
                self.device.isInputThreadStarted = False
                print(&#34;[PSSM - Touch handler] : Input thread stopped&#34;)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="Python-Screen-Stack-Manager.pssm.PSSMScreen.OSKHide"><code class="name flex">
<span>def <span class="ident">OSKHide</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def OSKHide(self):
        self.removeElt(elt=self.osk)
        self.isKeyboardShown = False</code></pre>
</details>
</dd>
<dt id="Python-Screen-Stack-Manager.pssm.PSSMScreen.OSKInit"><code class="name flex">
<span>def <span class="ident">OSKInit</span></span>(<span>self, onKeyPress=None, area=None, keymapPath=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def OSKInit(
                self,
                onKeyPress = None,
                area = None,
                keymapPath = None
        ):
        if not area:
                area = [(0,int(2*self.view_height/3)),(self.view_width,int(self.view_height/3))]
        self.onKeyPress = onKeyPress
        self.osk = OSK(onkeyPress = self.onKeyPress, area = area, keymapPath = keymapPath)</code></pre>
</details>
</dd>
<dt id="Python-Screen-Stack-Manager.pssm.PSSMScreen.OSKShow"><code class="name flex">
<span>def <span class="ident">OSKShow</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def OSKShow(self):
        if not self.osk:
                print(&#34;OSK not initialized, it can&#39;t be shown&#34;)
                return None
        self.addElt(self.osk)   # It has already been generated
        self.isKeyboardShown = True</code></pre>
</details>
</dd>
<dt id="Python-Screen-Stack-Manager.pssm.PSSMScreen.addElt"><code class="name flex">
<span>def <span class="ident">addElt</span></span>(<span>self, myElement, skipPrint=False, skipRegistration=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Adds Element to the stack and prints it
myElement (PSSM Element): The Element you want to add
skipPrint (bool): True if you don't want to update the screen
skipRegistration (bool): True if you don't want to add the Element to the stack</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def addElt(self,myElement,skipPrint=False,skipRegistration=False):
        &#34;&#34;&#34;
        Adds Element to the stack and prints it
                myElement (PSSM Element): The Element you want to add
                skipPrint (bool): True if you don&#39;t want to update the screen
                skipRegistration (bool): True if you don&#39;t want to add the Element to the stack
        &#34;&#34;&#34;
        for i in range(len(self.stack)):
                elt=self.stack[i]
                if elt.id == myElement.id:
                        # There is already an Element in the stack with the same ID.
                        # Let&#39;s update the Element in the stack
                        if not skipPrint:
                                self.stack[i] = myElement
                                self.printStack(area=myElement.area)
                        break   #The Element is already in the stack
        else:
                # the Element is not already in the stack
                if not skipRegistration:
                        # We append the element to the stack
                        myElement.parentPSSMScreen = self
                        self.stack.append(myElement)
                        if not skipPrint:
                                if self.isKeyboardShown:
                                        #TODO : make it faster, we only need to display the image behind the keyboard, not reprint everything
                                        myElement.generator()
                                        self.printStack(area=myElement.area)
                                else:
                                        #No keyboard on the horizon, let&#39;s do it
                                        self.simplePrintElt(myElement)</code></pre>
</details>
</dd>
<dt id="Python-Screen-Stack-Manager.pssm.PSSMScreen.clear"><code class="name flex">
<span>def <span class="ident">clear</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Clears the screen</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clear(self):
        &#34;&#34;&#34;
        Clears the screen
        &#34;&#34;&#34;
        self.device.do_screen_clear()
        return True</code></pre>
</details>
</dd>
<dt id="Python-Screen-Stack-Manager.pssm.PSSMScreen.clickHandler"><code class="name flex">
<span>def <span class="ident">clickHandler</span></span>(<span>self, x, y)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clickHandler(self,x,y):
        n = len(self.stack)
        for i in range(n):
                j = n-1-i       # We go through the stack in descending order
                elt = self.stack[j]
                if elt.area == None:
                        # An object without area, it should not happen, but if it does,
                        # it can be skipped
                        continue
                if coordsInArea(x,y,elt.area):
                        if elt.onclickInside != None:
                                self.lastX = x
                                self.lastY = y
                                if elt != None:
                                        self.dispatchClickToElt((x,y),elt)
                        break           # we quit the for loop</code></pre>
</details>
</dd>
<dt id="Python-Screen-Stack-Manager.pssm.PSSMScreen.createCanvas"><code class="name flex">
<span>def <span class="ident">createCanvas</span></span>(<span>self, color='white')</span>
</code></dt>
<dd>
<div class="desc"><p>(Deprecated)
Creates a white Element at the bottom of the stack, displays it while refreshing the screen.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def createCanvas(self,color=&#34;white&#34;):
        &#34;&#34;&#34;
        (Deprecated)
        Creates a white Element at the bottom of the stack, displays it while refreshing the screen.
        &#34;&#34;&#34;
        color = get_Color(color,self.colorType)
        img = Image.new(self.colorType, (self.width,self.height), color=color)
        background = Static(img,0,0,name=&#34;Canvas&#34;)
        self.addElt(background)</code></pre>
</details>
</dd>
<dt id="Python-Screen-Stack-Manager.pssm.PSSMScreen.dispatchClickToElt"><code class="name flex">
<span>def <span class="ident">dispatchClickToElt</span></span>(<span>self, coords, elt)</span>
</code></dt>
<dd>
<div class="desc"><p>Once given an object on which the user clicked, this function calls the
appropriate function on the object (ie elt.onclickInside or elt.dispatchClick)
It also handles inversion.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dispatchClickToElt(self,coords,elt):
        &#34;&#34;&#34;
        Once given an object on which the user clicked, this function calls the
        appropriate function on the object (ie elt.onclickInside or elt.dispatchClick)
        It also handles inversion.
        &#34;&#34;&#34;
        if elt.isLayout:
                if elt.onclickInside != None:
                        elt.onclickInside(elt,coords)
                if elt.invertOnClick:
                        self.invertArea(elt.area,elt.default_invertDuration)
                elt.dispatchClick(coords)
        else:
                if elt.invertOnClick:
                        self.invertArea(elt.area,elt.default_invertDuration)
                elt.onclickInside(elt,coords)</code></pre>
</details>
</dd>
<dt id="Python-Screen-Stack-Manager.pssm.PSSMScreen.findEltWithId"><code class="name flex">
<span>def <span class="ident">findEltWithId</span></span>(<span>self, myElementId, stack=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the element which has such an ID.
Avoid using this function as much as possible, as it is really not Performance-friendly
(Recursive search through all the elements of the stack)
And anyway there is no reason why you should use it.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def findEltWithId(self,myElementId,stack=None):
        &#34;&#34;&#34;
        Returns the element which has such an ID.
        Avoid using this function as much as possible, as it is really not Performance-friendly
        (Recursive search through all the elements of the stack)
        And anyway there is no reason why you should use it.
        &#34;&#34;&#34;
        if stack == None:
                stack = self.stack
        for elt in stack:
                if elt.id == myElementId:
                        return elt
                elif elt.isLayout:
                        layoutEltList = elt.createEltList()
                        search = self.findEltWithId(myElementId,stack=layoutEltList)
                        if search != None:
                                return search
        return None</code></pre>
</details>
</dd>
<dt id="Python-Screen-Stack-Manager.pssm.PSSMScreen.getStackLevel"><code class="name flex">
<span>def <span class="ident">getStackLevel</span></span>(<span>self, myElementId)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getStackLevel(self,myElementId):
        elt = self.findEltWithId(myElementId)
        return self.stack.index(elt)</code></pre>
</details>
</dd>
<dt id="Python-Screen-Stack-Manager.pssm.PSSMScreen.getTagList"><code class="name flex">
<span>def <span class="ident">getTagList</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the set of all tags from all Elements in the stack</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getTagList(self):
        &#34;&#34;&#34;
        Returns the set of all tags from all Elements in the stack
        &#34;&#34;&#34;
        tags={}
        for elt in self.stack:
                tags.update(elt.tags)
        return tags</code></pre>
</details>
</dd>
<dt id="Python-Screen-Stack-Manager.pssm.PSSMScreen.invert"><code class="name flex">
<span>def <span class="ident">invert</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Inverts the whole screen</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def invert(self):
        &#34;&#34;&#34;
        Inverts the whole screen
        &#34;&#34;&#34;
        self.isInverted = not self.isInverted
        self.device.do_screen_refresh(self.isInverted)
        return True</code></pre>
</details>
</dd>
<dt id="Python-Screen-Stack-Manager.pssm.PSSMScreen.invertAllWithTag"><code class="name flex">
<span>def <span class="ident">invertAllWithTag</span></span>(<span>self, tag, invertDuration=-1)</span>
</code></dt>
<dd>
<div class="desc"><p>Removes all the Element which have a specific tag</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def invertAllWithTag(self,tag,invertDuration=-1):
        &#34;&#34;&#34;
        Removes all the Element which have a specific tag
        &#34;&#34;&#34;
        stackCopy = deepcopy(self.stack) #It is unsage to loop through a mutable list which is being edited afterwards : some items are skipped
        for elt in stackCopy:
                if tag in elt.tags:
                        self.invertElt(myElementId=elt.id,invertDuration=-1,skipPrint=True)
        #Then we reprint the whole screen (yeah, the *whole* screen... Performance is not our goal)
        self.printStack()
        # If an invert duration is given, then start a timer to go back to the original state
        if invertDuration&gt;0:
                threading.Timer(invertDuration,self.invertAllWithTag,[tag,-1]).start()</code></pre>
</details>
</dd>
<dt id="Python-Screen-Stack-Manager.pssm.PSSMScreen.invertArea"><code class="name flex">
<span>def <span class="ident">invertArea</span></span>(<span>self, area, invertDuration, isInverted=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Inverts an area</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def invertArea(self,area,invertDuration,isInverted=False):
        &#34;&#34;&#34;
        Inverts an area
        &#34;&#34;&#34;
        # TODO: To be tested
        initial_mode = isInverted
        self.device.do_screen_refresh(
                isInverted      = not isInverted,
                area            = area,
                isPermanent     = False,
                isFlashing      = False,
                w_offset        = self.w_offset,
                h_offset        = self.h_offset
        )
        if invertDuration&gt;0:
                # Now we call this funcion, without starting a timer
                # And the screen is now in an opposite state as the initial one
                threading.Timer(invertDuration,self.invertArea,[area,-1,not initial_mode]).start()
        return True</code></pre>
</details>
</dd>
<dt id="Python-Screen-Stack-Manager.pssm.PSSMScreen.invertElt"><code class="name flex">
<span>def <span class="ident">invertElt</span></span>(<span>self, myElementId, invertDuration=-1, skipPrint=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Inverts an Element</p>
<blockquote>
<p>myElementId
invertDuration (int) : -1 or 0 if permanent, else an integer</p>
</blockquote></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def invertElt(self,myElementId,invertDuration=-1,skipPrint=False):
        &#34;&#34;&#34;
        Inverts an Element
        &gt; myElementId
        &gt; invertDuration (int) : -1 or 0 if permanent, else an integer
        &#34;&#34;&#34;
        myElement = self.findEltWithId(myElementId)
        if myElement==None:
                return False
        # First, let&#39;s get the Element&#39;s initial inverted state
        Element_initial_state = bool(myElement.isInverted)
        # Then, we change the Element&#39;s state
        myElement.setInverted(not Element_initial_state)
        if not skipPrint:
                # Then we print the inverted version
                self.printStack(skipEltId=None, area=myElement.area)
        # Then, if an invertDuration is given, we setup a timer to go back to the original state
        if invertDuration and invertDuration&gt;0:
                #Then, we start a timer to set it back to its intial state
                threading.Timer(invertDuration,myElement.setInverted,[Element_initial_state]).start()
                threading.Timer(invertDuration,self.invertElt,[myElementId,-1]).start()</code></pre>
</details>
</dd>
<dt id="Python-Screen-Stack-Manager.pssm.PSSMScreen.printStack"><code class="name flex">
<span>def <span class="ident">printStack</span></span>(<span>self, area=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Prints the stack Elements in the stack order
If a area is set, then, we only display
the part of the stack which is in this area</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def printStack(self,area=None):
        &#34;&#34;&#34;
        Prints the stack Elements in the stack order
        If a area is set, then, we only display
        the part of the stack which is in this area
        &#34;&#34;&#34;
        #TODO : Must be retought to work with the new nested structure
        #TODO : Must honor the &#39;area&#39; argument
        # for now it will just reprint the whole stack
        white = get_Color(&#34;white&#34;,self.colorType)
        placeholder = Image.new(self.colorType, (self.width, self.height), color=white)
        for elt in self.stack:
                [(x,y),(w,h)] = elt.area
                placeholder.paste(elt.imgData, (x,y))
        [(x,y),(w,h)] = self.area
        self.device.print_pil(placeholder,x, y, w, h, isInverted=self.isInverted)</code></pre>
</details>
</dd>
<dt id="Python-Screen-Stack-Manager.pssm.PSSMScreen.refresh"><code class="name flex">
<span>def <span class="ident">refresh</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Refreshes the screeen</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def refresh(self):
        &#34;&#34;&#34;
        Refreshes the screeen
        &#34;&#34;&#34;
        self.device.do_screen_refresh()
        return True</code></pre>
</details>
</dd>
<dt id="Python-Screen-Stack-Manager.pssm.PSSMScreen.removeAllWithTag"><code class="name flex">
<span>def <span class="ident">removeAllWithTag</span></span>(<span>self, tag)</span>
</code></dt>
<dd>
<div class="desc"><p>Removes every Element from the stack which have the specified tag</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def removeAllWithTag(self,tag):
        &#34;&#34;&#34;
        Removes every Element from the stack which have the specified tag
        &#34;&#34;&#34;
        stackCopy = deepcopy(self.stack) #It is unsage to loop through a mutable list which is being edited afterwards : some items are skipped
        for elt in stackCopy:
                if tag in elt.tags:
                        self.removeElt(elt.id,skipPrint=True,weAlreadyHaveTheElt=elt)
        #Then we reprint the whole screen (yeah, the *whole* screen... Performance is not our goal)
        self.printStack()</code></pre>
</details>
</dd>
<dt id="Python-Screen-Stack-Manager.pssm.PSSMScreen.removeElt"><code class="name flex">
<span>def <span class="ident">removeElt</span></span>(<span>self, elt=None, eltid=None, skipPrint=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Removes the Element from the stack and hides it from the screen</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def removeElt(self,elt=None,eltid=None,skipPrint=False):
        &#34;&#34;&#34;
        Removes the Element from the stack and hides it from the screen
        &#34;&#34;&#34;
        if elt:
                self.stack.remove(elt)
                if not skipPrint:
                        self.printStack(area=elt.area)
        elif eltid :
                elt = self.findEltWithId(myElementId)
                if elt:
                        self.stack.remove(elt)
                        if not skipPrint:
                                self.printStack(area=elt.area)
        else:
                print(&#39;No element given&#39;)</code></pre>
</details>
</dd>
<dt id="Python-Screen-Stack-Manager.pssm.PSSMScreen.setStackLevel"><code class="name flex">
<span>def <span class="ident">setStackLevel</span></span>(<span>self, myElementId, stackLevel='last')</span>
</code></dt>
<dd>
<div class="desc"><p>Set the position of said Element
Then prints every Element above it (including itself)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setStackLevel(self,myElementId,stackLevel=&#34;last&#34;):
        &#34;&#34;&#34;
        Set the position of said Element
        Then prints every Element above it (including itself)
        &#34;&#34;&#34;
        #TODO : Must be able to accept another stackLevel
        if stackLevel==&#34;last&#34; or stackLevel==-1:
                stackLevel=len(self.stack)
                elt = self.findEltWithId(myElementId)
                self.removeElt(myElementId,skipPrint=True)
                self.stack.insert(stackLevel,elt)
                self.printStack(area=[elt.xy,elt.xy2])
                return True</code></pre>
</details>
</dd>
<dt id="Python-Screen-Stack-Manager.pssm.PSSMScreen.simplePrintElt"><code class="name flex">
<span>def <span class="ident">simplePrintElt</span></span>(<span>self, myElement, skipGeneration=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Prints the Element without adding it to the stack.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>myElement</code></strong> :&ensp;<code>PSSM <a title="Python-Screen-Stack-Manager.pssm.Element" href="#Python-Screen-Stack-Manager.pssm.Element">Element</a></code></dt>
<dd>The element you want to display</dd>
<dt><strong><code>skipGeneration</code></strong> :&ensp;<code>bool</code></dt>
<dd>Do you want to regenerate the image?</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def simplePrintElt(self,myElement,skipGeneration = False):
        &#34;&#34;&#34;
        Prints the Element without adding it to the stack.
        Args:
                myElement (PSSM Element): The element you want to display
                skipGeneration (bool): Do you want to regenerate the image?
        &#34;&#34;&#34;
        if not skipGeneration:
                # First, the element must be generated
                myElement.generator()
        # Then, we print it
        [(x,y),(w,h)] = myElement.area
        # What follows is a Workaround :
        # TODO : this Workaround must be investigated
        if not myElement.isLayout:
                w += 1
                h += 1
        self.device.print_pil(myElement.imgData,x, y, w, h, isInverted=myElement.isInverted)</code></pre>
</details>
</dd>
<dt id="Python-Screen-Stack-Manager.pssm.PSSMScreen.startListenerThread"><code class="name flex">
<span>def <span class="ident">startListenerThread</span></span>(<span>self, grabInput=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Starts the touch listener as a separate thread</p>
<blockquote>
<p>grabInput : (boolean) Whether to do an EVIOCGRAB IOCTL call to prevent
another software from registering touch events</p>
</blockquote></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def startListenerThread(self,grabInput=False):
        &#34;&#34;&#34;
        Starts the touch listener as a separate thread
        &gt; grabInput : (boolean) Whether to do an EVIOCGRAB IOCTL call to prevent
                another software from registering touch events
        &#34;&#34;&#34;
        self.isInputThreadStarted = True
        self.device.isInputThreadStarted = True
        print(&#34;[PSSM - Touch handler] : Input thread started&#34;)
        args = [self.clickHandler,True,grabInput]
        inputThread = threading.Thread(target=self.device.eventBindings,args=args)
        inputThread.start()</code></pre>
</details>
</dd>
<dt id="Python-Screen-Stack-Manager.pssm.PSSMScreen.stopListenerThread"><code class="name flex">
<span>def <span class="ident">stopListenerThread</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def stopListenerThread(self):
        self.isInputThreadStarted = False
        self.device.isInputThreadStarted = False
        print(&#34;[PSSM - Touch handler] : Input thread stopped&#34;)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="Python-Screen-Stack-Manager.pssm.Rectangle"><code class="flex name class">
<span>class <span class="ident">Rectangle</span></span>
<span>(</span><span>background_color='white', outline_color='gray3', parentPSSMScreen=None)</span>
</code></dt>
<dd>
<div class="desc"><p>A rectangle</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>background_color</code></strong> :&ensp;<code>str</code></dt>
<dd>The background color</dd>
<dt><strong><code>outline_color</code></strong> :&ensp;<code>str</code></dt>
<dd>The border color</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Rectangle(Element):
        &#34;&#34;&#34;
        A rectangle
        Args:
                background_color (str): The background color
                outline_color (str): The border color
        &#34;&#34;&#34;
        def __init__(self,background_color=&#34;white&#34;,outline_color=&#34;gray3&#34;,parentPSSMScreen=None):
                super().__init__()
                self.background_color = background_color
                self.outline_color = outline_color
                self.parentPSSMScreen = parentPSSMScreen

        def generator(self,area):
                [(x,y),(w,h)] = area
                self.area = area
                img = Image.new(
                        self.parentPSSMScreen.colorType,
                        (w+1,h+1),
                        color=get_Color(&#34;white&#34;,self.parentPSSMScreen.colorType)
                )
                rect = ImageDraw.Draw(img, self.parentPSSMScreen.colorType)
                rect.rectangle(
                        [(0,0),(w,h)],
                        fill=get_Color(self.background_color,self.parentPSSMScreen.colorType),
                        outline=get_Color(self.outline_color,self.parentPSSMScreen.colorType)
                )
                self.imgData = img
                return self.imgData</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="Python-Screen-Stack-Manager.pssm.Element" href="#Python-Screen-Stack-Manager.pssm.Element">Element</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="Python-Screen-Stack-Manager.pssm.Element" href="#Python-Screen-Stack-Manager.pssm.Element">Element</a></b></code>:
<ul class="hlist">
<li><code><a title="Python-Screen-Stack-Manager.pssm.Element.generator" href="#Python-Screen-Stack-Manager.pssm.Element.generator">generator</a></code></li>
<li><code><a title="Python-Screen-Stack-Manager.pssm.Element.update" href="#Python-Screen-Stack-Manager.pssm.Element.update">update</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="Python-Screen-Stack-Manager.pssm.RectangleRounded"><code class="flex name class">
<span>class <span class="ident">RectangleRounded</span></span>
<span>(</span><span>radius=20, background_color='white', outline_color='gray3', parentPSSMScreen=None)</span>
</code></dt>
<dd>
<div class="desc"><p>A rectangle, but with rounded corners</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RectangleRounded(Element):
        &#34;&#34;&#34;
        A rectangle, but with rounded corners
        &#34;&#34;&#34;
        def __init__(
                        self,
                        radius=20,
                        background_color=&#34;white&#34;,
                        outline_color=&#34;gray3&#34;,
                        parentPSSMScreen=None
                ):
                super().__init__()
                self.radius = radius
                self.background_color = background_color
                self.outline_color = outline_color
                self.parentPSSMScreen = parentPSSMScreen

        def generator(self,area):
                [(x,y),(w,h)] = area
                self.area = area
                rectangle = Image.new(
                        self.parentPSSMScreen.colorType,
                        (w,h),
                        color=get_Color(&#34;white&#34;,self.parentPSSMScreen.colorType)
                )
                draw = ImageDraw.Draw(rectangle)
                draw.rectangle(
                        [(0,0),(w,h)],
                        fill=get_Color(self.background_color,self.parentPSSMScreen.colorType),
                        outline=get_Color(self.outline_color,self.parentPSSMScreen.colorType)
                )
                draw.line(
                        [(self.radius,h-1),(w-self.radius,h-1)],
                        fill  = get_Color(self.outline_color, self.parentPSSMScreen.colorType),
                        width = 1
                )
                draw.line(
                        [(w-1,self.radius),(w-1,h-self.radius)],
                        fill  = get_Color(self.outline_color, self.parentPSSMScreen.colorType),
                        width = 1
                )
                corner = roundedCorner(
                        self.radius,
                        self.background_color,
                        self.outline_color,
                        self.parentPSSMScreen.colorType
                )
                rectangle.paste(corner, (0, 0))
                rectangle.paste(corner.rotate(90), (0, h - self.radius)) # Rotate the corner and paste it
                rectangle.paste(corner.rotate(180), (w - self.radius, h - self.radius))
                rectangle.paste(corner.rotate(270), (w - self.radius, 0))
                self.imgData = rectangle
                return self.imgData</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="Python-Screen-Stack-Manager.pssm.Element" href="#Python-Screen-Stack-Manager.pssm.Element">Element</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="Python-Screen-Stack-Manager.pssm.Element" href="#Python-Screen-Stack-Manager.pssm.Element">Element</a></b></code>:
<ul class="hlist">
<li><code><a title="Python-Screen-Stack-Manager.pssm.Element.generator" href="#Python-Screen-Stack-Manager.pssm.Element.generator">generator</a></code></li>
<li><code><a title="Python-Screen-Stack-Manager.pssm.Element.update" href="#Python-Screen-Stack-Manager.pssm.Element.update">update</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="Python-Screen-Stack-Manager.pssm.Static"><code class="flex name class">
<span>class <span class="ident">Static</span></span>
<span>(</span><span>pil_image, centered=True, resize=True, background_color='white', rotation=0, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>A very simple element which only displays a pillow image</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>pil_image</code></strong> :&ensp;<code>str</code> or <code>pil image</code></dt>
<dd>path to an image or a pillow image</dd>
<dt><strong><code>centered</code></strong> :&ensp;<code>bool</code></dt>
<dd>Center the image ?</dd>
<dt><strong><code>resize</code></strong> :&ensp;<code>bool</code></dt>
<dd>Make it fit the area ? (proportions are respected)</dd>
<dt><strong><code>rotation</code></strong> :&ensp;<code>int</code></dt>
<dd>an integer rotation angle</dd>
<dt><strong><code>background_color</code></strong> :&ensp;<code>str</code></dt>
<dd>"white", "black", "gray0" to "gray15" or a (red, green, blue, transparency) tuple</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Static(Element):
        &#34;&#34;&#34;
        A very simple element which only displays a pillow image
        Args:
                pil_image (str or pil image): path to an image or a pillow image
                centered (bool): Center the image ?
                resize (bool): Make it fit the area ? (proportions are respected)
                rotation (int): an integer rotation angle
                background_color (str): &#34;white&#34;, &#34;black&#34;, &#34;gray0&#34; to &#34;gray15&#34; or a (red, green, blue, transparency) tuple
        &#34;&#34;&#34;
        def __init__(self,pil_image,centered=True,resize=True,background_color=&#34;white&#34;,rotation=0,**kwargs):
                super().__init__()
                if isinstance(pil_image,str):
                        self.pil_image = Image.open(pil_image)
                else:
                        self.pil_image = pil_image
                self.background_color = background_color
                self.centered = centered
                self.resize   = resize
                self.rotation = rotation
                for param in kwargs:
                        setattr(self, param, kwargs[param])

        def generator(self,area=None):
                # TODO : crop or resize the image to make it fit the area
                (x,y),(w,h) = area
                pil_image = self.pil_image.convert(self.parentPSSMScreen.colorType)
                if self.resize:
                        r = min(w/pil_image.width, h/pil_image.height)
                        size = (int(pil_image.width*r), int(pil_image.height*r))
                        pil_image = self.pil_image.resize(size)
                if self.rotation != 0:
                        pil_image = pil_image.rotate(self.rotation,fillcolor=self.background_color)
                if not self.centered:
                        return pil_image
                else:
                        img = Image.new(
                                self.parentPSSMScreen.colorType,
                                (w+1,h+1),
                                color=get_Color(self.background_color,self.parentPSSMScreen.colorType)
                        )
                        img.paste(pil_image, (int(0.5*w-0.5*pil_image.width), int(0.5*h-0.5*pil_image.height)))
                        self.imgData = img
                        return img</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="Python-Screen-Stack-Manager.pssm.Element" href="#Python-Screen-Stack-Manager.pssm.Element">Element</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="Python-Screen-Stack-Manager.pssm.Element" href="#Python-Screen-Stack-Manager.pssm.Element">Element</a></b></code>:
<ul class="hlist">
<li><code><a title="Python-Screen-Stack-Manager.pssm.Element.generator" href="#Python-Screen-Stack-Manager.pssm.Element.generator">generator</a></code></li>
<li><code><a title="Python-Screen-Stack-Manager.pssm.Element.update" href="#Python-Screen-Stack-Manager.pssm.Element.update">update</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="Python-Screen-Stack-Manager" href="index.html">Python-Screen-Stack-Manager</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="Python-Screen-Stack-Manager.pssm.Button" href="#Python-Screen-Stack-Manager.pssm.Button">Button</a></code></h4>
<ul class="">
<li><code><a title="Python-Screen-Stack-Manager.pssm.Button.wrapText" href="#Python-Screen-Stack-Manager.pssm.Button.wrapText">wrapText</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="Python-Screen-Stack-Manager.pssm.ButtonList" href="#Python-Screen-Stack-Manager.pssm.ButtonList">ButtonList</a></code></h4>
<ul class="">
<li><code><a title="Python-Screen-Stack-Manager.pssm.ButtonList.build_layoutFromButtons" href="#Python-Screen-Stack-Manager.pssm.ButtonList.build_layoutFromButtons">build_layoutFromButtons</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="Python-Screen-Stack-Manager.pssm.Element" href="#Python-Screen-Stack-Manager.pssm.Element">Element</a></code></h4>
<ul class="">
<li><code><a title="Python-Screen-Stack-Manager.pssm.Element.generator" href="#Python-Screen-Stack-Manager.pssm.Element.generator">generator</a></code></li>
<li><code><a title="Python-Screen-Stack-Manager.pssm.Element.setInverted" href="#Python-Screen-Stack-Manager.pssm.Element.setInverted">setInverted</a></code></li>
<li><code><a title="Python-Screen-Stack-Manager.pssm.Element.update" href="#Python-Screen-Stack-Manager.pssm.Element.update">update</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="Python-Screen-Stack-Manager.pssm.Icon" href="#Python-Screen-Stack-Manager.pssm.Icon">Icon</a></code></h4>
</li>
<li>
<h4><code><a title="Python-Screen-Stack-Manager.pssm.Layout" href="#Python-Screen-Stack-Manager.pssm.Layout">Layout</a></code></h4>
<ul class="">
<li><code><a title="Python-Screen-Stack-Manager.pssm.Layout.createEltList" href="#Python-Screen-Stack-Manager.pssm.Layout.createEltList">createEltList</a></code></li>
<li><code><a title="Python-Screen-Stack-Manager.pssm.Layout.isLayoutValid" href="#Python-Screen-Stack-Manager.pssm.Layout.isLayoutValid">isLayoutValid</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="Python-Screen-Stack-Manager.pssm.Line" href="#Python-Screen-Stack-Manager.pssm.Line">Line</a></code></h4>
</li>
<li>
<h4><code><a title="Python-Screen-Stack-Manager.pssm.OSK" href="#Python-Screen-Stack-Manager.pssm.OSK">OSK</a></code></h4>
<ul class="">
<li><code><a title="Python-Screen-Stack-Manager.pssm.OSK.build_layout" href="#Python-Screen-Stack-Manager.pssm.OSK.build_layout">build_layout</a></code></li>
<li><code><a title="Python-Screen-Stack-Manager.pssm.OSK.generator" href="#Python-Screen-Stack-Manager.pssm.OSK.generator">generator</a></code></li>
<li><code><a title="Python-Screen-Stack-Manager.pssm.OSK.getKeyLabel" href="#Python-Screen-Stack-Manager.pssm.OSK.getKeyLabel">getKeyLabel</a></code></li>
<li><code><a title="Python-Screen-Stack-Manager.pssm.OSK.handleKeyPress" href="#Python-Screen-Stack-Manager.pssm.OSK.handleKeyPress">handleKeyPress</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="Python-Screen-Stack-Manager.pssm.PSSMScreen" href="#Python-Screen-Stack-Manager.pssm.PSSMScreen">PSSMScreen</a></code></h4>
<ul class="two-column">
<li><code><a title="Python-Screen-Stack-Manager.pssm.PSSMScreen.OSKHide" href="#Python-Screen-Stack-Manager.pssm.PSSMScreen.OSKHide">OSKHide</a></code></li>
<li><code><a title="Python-Screen-Stack-Manager.pssm.PSSMScreen.OSKInit" href="#Python-Screen-Stack-Manager.pssm.PSSMScreen.OSKInit">OSKInit</a></code></li>
<li><code><a title="Python-Screen-Stack-Manager.pssm.PSSMScreen.OSKShow" href="#Python-Screen-Stack-Manager.pssm.PSSMScreen.OSKShow">OSKShow</a></code></li>
<li><code><a title="Python-Screen-Stack-Manager.pssm.PSSMScreen.addElt" href="#Python-Screen-Stack-Manager.pssm.PSSMScreen.addElt">addElt</a></code></li>
<li><code><a title="Python-Screen-Stack-Manager.pssm.PSSMScreen.clear" href="#Python-Screen-Stack-Manager.pssm.PSSMScreen.clear">clear</a></code></li>
<li><code><a title="Python-Screen-Stack-Manager.pssm.PSSMScreen.clickHandler" href="#Python-Screen-Stack-Manager.pssm.PSSMScreen.clickHandler">clickHandler</a></code></li>
<li><code><a title="Python-Screen-Stack-Manager.pssm.PSSMScreen.createCanvas" href="#Python-Screen-Stack-Manager.pssm.PSSMScreen.createCanvas">createCanvas</a></code></li>
<li><code><a title="Python-Screen-Stack-Manager.pssm.PSSMScreen.dispatchClickToElt" href="#Python-Screen-Stack-Manager.pssm.PSSMScreen.dispatchClickToElt">dispatchClickToElt</a></code></li>
<li><code><a title="Python-Screen-Stack-Manager.pssm.PSSMScreen.findEltWithId" href="#Python-Screen-Stack-Manager.pssm.PSSMScreen.findEltWithId">findEltWithId</a></code></li>
<li><code><a title="Python-Screen-Stack-Manager.pssm.PSSMScreen.getStackLevel" href="#Python-Screen-Stack-Manager.pssm.PSSMScreen.getStackLevel">getStackLevel</a></code></li>
<li><code><a title="Python-Screen-Stack-Manager.pssm.PSSMScreen.getTagList" href="#Python-Screen-Stack-Manager.pssm.PSSMScreen.getTagList">getTagList</a></code></li>
<li><code><a title="Python-Screen-Stack-Manager.pssm.PSSMScreen.invert" href="#Python-Screen-Stack-Manager.pssm.PSSMScreen.invert">invert</a></code></li>
<li><code><a title="Python-Screen-Stack-Manager.pssm.PSSMScreen.invertAllWithTag" href="#Python-Screen-Stack-Manager.pssm.PSSMScreen.invertAllWithTag">invertAllWithTag</a></code></li>
<li><code><a title="Python-Screen-Stack-Manager.pssm.PSSMScreen.invertArea" href="#Python-Screen-Stack-Manager.pssm.PSSMScreen.invertArea">invertArea</a></code></li>
<li><code><a title="Python-Screen-Stack-Manager.pssm.PSSMScreen.invertElt" href="#Python-Screen-Stack-Manager.pssm.PSSMScreen.invertElt">invertElt</a></code></li>
<li><code><a title="Python-Screen-Stack-Manager.pssm.PSSMScreen.printStack" href="#Python-Screen-Stack-Manager.pssm.PSSMScreen.printStack">printStack</a></code></li>
<li><code><a title="Python-Screen-Stack-Manager.pssm.PSSMScreen.refresh" href="#Python-Screen-Stack-Manager.pssm.PSSMScreen.refresh">refresh</a></code></li>
<li><code><a title="Python-Screen-Stack-Manager.pssm.PSSMScreen.removeAllWithTag" href="#Python-Screen-Stack-Manager.pssm.PSSMScreen.removeAllWithTag">removeAllWithTag</a></code></li>
<li><code><a title="Python-Screen-Stack-Manager.pssm.PSSMScreen.removeElt" href="#Python-Screen-Stack-Manager.pssm.PSSMScreen.removeElt">removeElt</a></code></li>
<li><code><a title="Python-Screen-Stack-Manager.pssm.PSSMScreen.setStackLevel" href="#Python-Screen-Stack-Manager.pssm.PSSMScreen.setStackLevel">setStackLevel</a></code></li>
<li><code><a title="Python-Screen-Stack-Manager.pssm.PSSMScreen.simplePrintElt" href="#Python-Screen-Stack-Manager.pssm.PSSMScreen.simplePrintElt">simplePrintElt</a></code></li>
<li><code><a title="Python-Screen-Stack-Manager.pssm.PSSMScreen.startListenerThread" href="#Python-Screen-Stack-Manager.pssm.PSSMScreen.startListenerThread">startListenerThread</a></code></li>
<li><code><a title="Python-Screen-Stack-Manager.pssm.PSSMScreen.stopListenerThread" href="#Python-Screen-Stack-Manager.pssm.PSSMScreen.stopListenerThread">stopListenerThread</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="Python-Screen-Stack-Manager.pssm.Rectangle" href="#Python-Screen-Stack-Manager.pssm.Rectangle">Rectangle</a></code></h4>
</li>
<li>
<h4><code><a title="Python-Screen-Stack-Manager.pssm.RectangleRounded" href="#Python-Screen-Stack-Manager.pssm.RectangleRounded">RectangleRounded</a></code></h4>
</li>
<li>
<h4><code><a title="Python-Screen-Stack-Manager.pssm.Static" href="#Python-Screen-Stack-Manager.pssm.Static">Static</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.1</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>