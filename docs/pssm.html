<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.1" />
<title>Python-Screen-Stack-Manager.pssm API documentation</title>
<meta name="description" content="" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>Python-Screen-Stack-Manager.pssm</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#!/usr/bin/env python
import os
import json
import threading
# Load Pillow
from PIL import Image, ImageDraw, ImageFont, ImageOps
from copy import deepcopy
# Load some useful functions
from tools import returnFalse, coordsInArea, insertStr, getPartialEltImg, \
    getRectanglesIntersection, tools_convertXArgsToPX, tools_convertYArgsToPX,\
    tools_parseKnownImageFile, tools_parseKnownFonts, get_Color, debug, timer


# ########################## - VARIABLES - ####################################
lastUsedId = 0

# GENERAL
PATH_TO_PSSM = os.path.dirname(os.path.abspath(__file__))
DEFAULT_FONT = &#34;default&#34;
DEFAULT_FONTBOLD = &#34;default-Bold&#34;
DEFAULT_FONT_SIZE = &#34;H*0.036&#34;
CURSOR_CHAR = &#34;|&#34;
DEFAULT_INVERT_DURATION = 0.2


# OSK CONSTANTS
DEFAULT_KEYMAP_PATH_STANDARD = os.path.join(PATH_TO_PSSM,
                                            &#34;config&#34;,
                                            &#34;default-keymap-en_us.json&#34;)
DEFAULT_KEYMAP_PATH_CAPS = os.path.join(PATH_TO_PSSM,
                                        &#34;config&#34;,
                                        &#34;default-keymap-en_us_CAPS.json&#34;)
DEFAULT_KEYMAP_PATH_ALT = os.path.join(PATH_TO_PSSM,
                                       &#34;config&#34;,
                                       &#34;default-keymap-en_us_ALT.json&#34;)
DEFAULT_KEYMAP_PATH = {
    &#39;standard&#39;: DEFAULT_KEYMAP_PATH_STANDARD,
    &#39;caps&#39;: DEFAULT_KEYMAP_PATH_CAPS,
    &#39;alt&#39;: DEFAULT_KEYMAP_PATH_ALT
}

KTstandardChar = 0
KTcarriageReturn = 1
KTbackspace = 2
KTdelete = 3
KTcapsLock = 4
KTcontrol = 5
KTalt = 6


# ########################## - StackManager    - ##############################
class PSSMScreen:
    &#34;&#34;&#34;
    This is the class which handles most of the logic.

    Args:
        deviceName (str): &#34;Kobo&#34; for Kobo ereaders
            (and probably all FBInk supported devices)
        name (str): The name of the class instance
            (deprecated, I will eventually remove it)
        stack (list): Do not use it unless you know what you are doing.
            The list of all the pssm Elements which are on the screen.
        isInverted (bool): ...

    Attributes:
        device: the device.py module.
            You can with it access a few useful functions like
            `self.device.readBatteryPercentage()`
        colorType: &#34;L&#34; for grayscale devices, &#34;RGBA&#34; for others
        width: The screen width
        height : The screen height
        view_width: The width of the screen portion not hidden behind bezels
        view_height: ...
        name: ...
        isInverted: ...

    Example of usage:
        screen = pssm.PSSMScreen(&#34;Kobo&#34;,&#34;Main&#34;))
    &#34;&#34;&#34;
    def __init__(self, deviceName, name=&#34;screen&#34;, stack=[], isInverted=False):
        self.name = name
        if deviceName == &#34;Kobo&#34;:
            import devices.kobo.device as pssm_device
        else:
            import devices.emulator.device as pssm_device
        self.device = pssm_device
        self.colorType = self.device.colorType
        self.width = self.device.screen_width
        self.height = self.device.screen_height
        self.view_width = self.device.view_width
        self.view_height = self.device.view_height
        self.w_offset = self.device.w_offset
        self.h_offset = self.device.h_offset
        self.area = [(0, 0), (self.view_width, self.view_height)]
        self.stack = stack
        self.isInverted = isInverted
        self.isInputThreadStarted = False
        self.lastX = -1
        self.lastY = -1
        self.osk = None
        self.numberEltOnTop = 0
        self.isOSKShown = False
        self.isBatch = False

    def findEltWithId(self, myElementId, stack=None):
        &#34;&#34;&#34;
        (Deprecated)
        Returns the element which has such an ID.
        Avoid using this function as much as possible:
        it has terrible performance.
        (Recursive search through all the elements of the stack)
        And anyway there is no reason why you should use it.
        &#34;&#34;&#34;
        if stack is None:
            stack = self.stack
        for elt in stack:
            if elt.id == myElementId:
                return elt
            elif elt.isLayout:
                layoutEltList = elt.createEltList()
                search = self.findEltWithId(myElementId, stack=layoutEltList)
                if search is not None:
                    return search
        return None

    def printStack(self, area=None, forceLayoutGen=False):
        &#34;&#34;&#34;
        Prints the stack Elements in the stack order
        If a area is set, then, we only display
        the part of the stack which is in this area
        &#34;&#34;&#34;
        if self.isBatch:
            # Do not do anything during batch mode
            return None
        pil_image = self.capture(area=area, forceLayoutGen=forceLayoutGen)
        if area:
            [(x, y), (w, h)] = area
        else:
            [(x, y), (w, h)] = self.area
        self.device.print_pil(pil_image, x, y, isInverted=self.isInverted)

    def capture(self,area=None, forceLayoutGen=False):
        &#34;&#34;&#34;
        Returns a screen capture of the current stack state.
        &#34;&#34;&#34;
        white = get_Color(&#34;white&#34;, self.colorType)
        dim = (self.width, self.height)
        img = Image.new(self.colorType, dim, color=white)
        for elt in self.stack:
            [(x, y), (w, h)] = elt.area
            if elt.isLayout and forceLayoutGen:
                elt.generator(area=elt.area, skipNonLayoutGen=True)
            if elt.isInverted:
                pil_image = ImageOps.invert(elt.imgData)
            else:
                pil_image = elt.imgData
            img.paste(pil_image, (x, y))
        if area:
            [(x, y), (w, h)] = area
            box = (x, y, x+w, y+h)
            return img.crop(box=box)
        else:
            return img

    def simplePrintElt(self, myElement, skipGen=False):
        &#34;&#34;&#34;
        Prints the Element without adding it to the stack.
        Does not honor isBatch (you can simplePrint even during batch mode)
        Args:
            myElement (PSSM Element): The element you want to display
            skipGen (bool): Do you want to regenerate the image?
        &#34;&#34;&#34;
        if not skipGen:
            # First, the element must be generated
            myElement.generator()
        # Then, we print it
        [(x, y), (w, h)] = myElement.area
        # What follows is a Workaround :
        self.device.print_pil(
            myElement.imgData,
            x, y,
            isInverted=myElement.isInverted
        )

    def startBatchWriting(self):
        &#34;&#34;&#34;
        Toggle batch writing: nothing will be displayed on the screen until
        you use screen.stopBatchWriting()
        &#34;&#34;&#34;
        self.isBatch = True

    def stopBatchWriting(self):
        &#34;&#34;&#34;
        Updates the screen after batch writing
        &#34;&#34;&#34;
        self.isBatch = False
        self.printStack(area=self.area, forceLayoutGen=True)

    def addElt(self, myElement, skipPrint=False, skipRegistration=False):
        &#34;&#34;&#34;
        Adds Element to the stack and prints it
            myElement (PSSM Element): The Element you want to add
            skipPrint (bool): True if you don&#39;t want to update the screen
            skipRegistration (bool): True if you don&#39;t want to add the Element
                to the stack
        &#34;&#34;&#34;
        for i in range(len(self.stack)):
            elt = self.stack[i]
            if elt.id == myElement.id:
                # There is already an Element in the stack with the same ID.
                # Let&#39;s update the Element in the stack
                if not skipPrint:
                    self.stack[i] = myElement
                    self.printStack(area=myElement.area)
                break   # The Element is already in the stack
        else:
            # the Element is not already in the stack
            if not skipRegistration:
                # We append the element to the stack
                myElement.parentPSSMScreen = self
                if self.numberEltOnTop &gt; 0:
                    # There is something on top, addnig it at position -2
                    # (before the last one)
                    pos = - 1 - self.numberEltOnTop
                    self.stack.insert(pos, myElement)
                else:
                    self.stack.append(myElement)
                if not skipPrint :
                    if self.numberEltOnTop &gt; 0 and not self.forcePrintOnTop:
                        # TODO : make it faster, we only need to display the
                        # image behind the keyboard, not reprint everything
                        myElement.generator()
                        self.printStack(area=myElement.area)
                    else:
                        # No keyboard on the horizon, let&#39;s do it
                        if self.isBatch:
                            # Then we only generate
                            myElement.generator()
                        else:
                            myElement.generator()
                            self.simplePrintElt(myElement, skipGen=True)

    def removeElt(self, elt=None, eltid=None, skipPrint=False):
        &#34;&#34;&#34;
        Removes the Element from the stack and hides it from the screen
        &#34;&#34;&#34;
        if elt:
            self.stack.remove(elt)
            if not skipPrint:
                self.printStack(area=elt.area)
        elif eltid:
            elt = self.findEltWithId(eltid)
            if elt:
                self.stack.remove(elt)
                if not skipPrint:
                    self.printStack(area=elt.area)
        else:
            print(&#39;No element given&#39;)

    def getStackLevel(self, myElementId):
        elt = self.findEltWithId(myElementId)
        return self.stack.index(elt)

    def setStackLevel(self, elt, stackLevel=&#34;last&#34;):
        &#34;&#34;&#34;
        Set the position of said Element
        Then prints every Element above it (including itself)
        &#34;&#34;&#34;
        # TODO : Must be able to accept another stackLevel
        if stackLevel == &#34;last&#34; or stackLevel == -1:
            stackLevel = len(self.stack)
            self.removeElt(elt, skipPrint=True)
            self.stack.insert(stackLevel, elt)
            self.printStack(area=[elt.xy, elt.xy2])
            return True

    def invertElt(self, elt, invertDuration=-1,
                  useFastPrint=True, skipPrint=False):
        &#34;&#34;&#34;
        Inverts an Element

        Args:
            elt (Element): The PSSM Element to invert
            invertDuration (int) : -1 or 0 if permanent, else an integer
            skipPrint (bool): Save only or save + print?
            useFastPrint (bool): Use FBInk&#39;s partial refresh with nightmode
                (much faster) instead of printing the whole stack.
        &#34;&#34;&#34;
        if elt is None:
            print(&#34;No element given&#34;)
            return False
        # First, let&#39;s get the Element&#39;s initial inverted state
        Element_initial_state = bool(elt.isInverted)
        elt.isInverted = not Element_initial_state
        if not skipPrint:
            if useFastPrint:
                # Run as thread to make things a bit faster
                args = [
                    elt.area,
                    invertDuration,
                    not Element_initial_state
                ]
                invertThread = threading.Thread(
                    target=self._invertArea_helper,
                    args=args
                )
                invertThread.start()
                # self._invertArea_helper(elt.area, invertDuration, True)
            else:
                elt.update()
        elt.isInverted = Element_initial_state

    def _invertArea_helper(self, area, invertDuration, isInverted=False):
        &#34;&#34;&#34;
        Helper function to properly setup the timer.
        &#34;&#34;&#34;
        # TODO: To be tested
        initial_mode = isInverted
        isTemporaryinvertion = bool(invertDuration &gt; 0)
        self.device.do_screen_refresh(
            isInverted=isInverted,
            area=area,
            isInvertionPermanent=False,
            isFlashing=False,
            useFastInvertion=True
        )
        if isTemporaryinvertion:
            # Now we call this funcion, without starting a timer
            # And the screen is now in an opposite state as the initial one
            myTimer = threading.Timer(
                interval=invertDuration,
                function=self._invertArea_helper,
                args=[area, -1, not initial_mode]
            )
            myTimer.start()
        return True

    def invert(self):
        &#34;&#34;&#34;
        Inverts the whole screen
        &#34;&#34;&#34;
        self.isInverted = not self.isInverted
        self.device.do_screen_refresh(self.isInverted)
        return True

    def refresh(self):
        &#34;&#34;&#34;
        Refreshes the screeen
        &#34;&#34;&#34;
        self.device.do_screen_refresh()
        return True

    def clear(self):
        &#34;&#34;&#34;
        Clears the screen
        &#34;&#34;&#34;
        self.device.do_screen_clear()
        return True

    def OSKInit(self, onKeyPress=None, area=None, keymapPath=None):
        if not area:
            x = 0
            y = int(2*self.view_height/3)
            w = self.view_width
            h = int(self.view_height/3)
            area = [(x, y), (w, h)]
        self.osk = OSK(onKeyPress=onKeyPress, area=area, keymapPath=keymapPath)

    def OSKShow(self, onKeyPress=None):
        if not self.osk:
            print(&#34;OSK not initialized, it can&#39;t be shown&#34;)
            return None
        if onKeyPress:
            self.osk.onKeyPress = onKeyPress
        self.addElt(self.osk)   # It has already been generated
        self.numberEltOnTop += 1
        self.isOSKShown = True

    def OSKHide(self):
        if self.isOSKShown:
            self.removeElt(elt=self.osk)
            self.numberEltOnTop -= 1
            self.isOSKShown = False

    def startListenerThread(self, grabInput=False):
        &#34;&#34;&#34;
        Starts the touch listener as a separate thread
        Args:
            grabInput (boolean): Do an EVIOCGRAB IOCTL call to prevent
                any other software from registering touch events
        &#34;&#34;&#34;
        self.isInputThreadStarted = True
        self.device.isInputThreadStarted = True
        print(&#34;[PSSM - Touch handler] : Input thread started&#34;)
        args = [self._clickHandler, True, grabInput]
        inputThread = threading.Thread(
            target=self.device.eventBindings,
            args=args
        )
        inputThread.start()

    def _clickHandler(self, x, y):
        n = len(self.stack)
        for i in range(n):
            j = n-1-i   # We go through the stack in descending order
            elt = self.stack[j]
            if elt.area is None:
                # An object without area, it should not happen, but if it does,
                # it can be skipped
                continue
            if coordsInArea(x, y, elt.area):
                if elt.onclickInside is not None:
                    self.lastX = x
                    self.lastY = y
                    if elt is not None:
                        self._dispatchClickToElt((x, y), elt)
                break

    def _dispatchClickToElt(self, coords, elt):
        &#34;&#34;&#34;
        Once given an object on which the user clicked, this function calls the
        appropriate function on the object
        (ie elt.onclickInside or elt._dispatchClick)
        It also handles invertion.
        &#34;&#34;&#34;
        if elt.isLayout:
            if elt.onclickInside is not None:
                elt.onclickInside(elt, coords)
            if elt.invertOnClick:
                self.invertElt(elt, elt.invertDuration)
            elt._dispatchClick(coords)
        else:
            if elt.invertOnClick:
                self.invertElt(elt, elt.invertDuration)
            # Execute PSSM action on click
            elt.pssmOnClickInside(coords)
            # Execute user action attached to it too
            elt.onclickInside(elt, coords)

    def stopListenerThread(self):
        self.isInputThreadStarted = False
        self.device.isInputThreadStarted = False
        print(&#34;[PSSM - Touch handler] : Input thread stopped&#34;)


# ########################## - Core Element    - ##############################
class Element:
    &#34;&#34;&#34;
    Everything which is going to be displayed on the screen is an Element.

    Args:
        isInverted (bool): Is the element inverted
        data (dict, or any): A parameter for you to store whatever you want
        area (list): a [(x, y), (w, h)] list. If used in a Layout, the layout
            will take care of calculating the area.
        imgData (PILImage): the PIL image of the object (None by default, the
            generator function takes care of generating one)
        onclickInside (function): A function to be executed when the user
            clicks on the Element
        invertOnClick (bool): Invert the element when a click is registered ?
        invertDuration (int): Duration in seconds of the element invertion
            after a click is registered (use 0 for infinite)
        forcePrintOnTop (bool): Force the element to be printed on top of the
            stack, even if there is an on-screen keyboard or a popup
    &#34;&#34;&#34;
    def __init__(self, area=None, imgData=None, onclickInside=returnFalse,
                 isInverted=False, data={}, invertOnClick=False,
                 invertDuration=DEFAULT_INVERT_DURATION, forcePrintOnTop=False
                 ):
        global lastUsedId
        self.id = lastUsedId
        lastUsedId += 1
        self.isLayout = False
        self.imgData = imgData
        self.area = area
        self.onclickInside = onclickInside
        self.isInverted = isInverted
        self.user_data = data
        self.invertOnClick = invertOnClick
        self.invertDuration = invertDuration
        self.forcePrintOnTop = forcePrintOnTop
        self.parentLayouts = []
        self.parentPSSMScreen = None

    def __hash__(self):
        return hash(self.id)

    def __eq__(self, other):
        if isinstance(other, self.__class__):
            return self.id == other.id
        return NotImplemented

    def update(self, newAttributes={}, skipGen=False, skipPrint=False,
               reprintOnTop=False):
        &#34;&#34;&#34;
        Pass a dict as argument, and it will update the Element&#39;s attributes
        accordingly (both its attribute and then the screen).
        Note:
            Updating an element can be very slow ! It depends on every specific
            cases, but know there are a few ways to make it faster:
            - Use `screen.startBatchWriting()` and `screen.stopBatchWriting()`
            - If you know this specific element is on top of the screen, use:
                `elt.update(newAttributes=myDict, reprintOnTop=True)`
                Which will do the same, except it won&#39;t rebuild the whole stack
                image, it will just print this object on top. (On my tests, I
                could spare up to 0.5s !)

        Args :
            newAttributes (dict): The element&#39;s new attributes
            skipGen (bool): Just update the element&#39;s attribute, but do
                not do any generation or printing
            reprintOnTop (bool): Do not reprint the whole stack, but do print
                this element on top of the screen. (much faster when possible)
            skipPrint (bool): Do not update the screen, but do regenerate.
        &#34;&#34;&#34;
        # First, we set the attributes
        for param in newAttributes:
            setattr(self, param, newAttributes[param])
        if not skipGen:
            # we recreate the pillow image of this particular object
            self.generator()
        if (not skipPrint) and (not skipGen):  # No need to update if no regen
            isBatch = self.parentPSSMScreen.isBatch
            if reprintOnTop:
                self.parentPSSMScreen.simplePrintElt(self)
            elif not isBatch:
                hasParent = len(self.parentLayouts) &gt; 0
                # We don&#39;t want unncesseray generation when printing batch
                if hasParent:
                    # We recreate the pillow image of the oldest parent
                    # And it is not needed to regenerate standard objects, since
                    oldest_parent = self.parentLayouts[0]
                    oldest_parent.generator(skipNonLayoutGen=True)
                # Then, let&#39;s reprint the stack
                self.parentPSSMScreen.printStack(area=self.area)
        return True

    def generator(self):
        &#34;&#34;&#34;
        The generator is the function which is called when the container layout
        wants to build an image. It therefore returns a pillow image.
        &#34;&#34;&#34;
        return NotImplemented

    def convertDimension(self, dimension):
        &#34;&#34;&#34;
        Converts the user dimension input (like &#34;h*0.1&#34;) to to proper integer
        amount of pixels.
        Basically, you give it a string. And it will change a few characters to
        their corresponding value, then return the evaluated string.

        Examples:
            I HIGHLY recommend doing only simple operation, like &#34;H*0.1&#34;, or
            &#34;W/10&#34;, always starting with the corresponding variable.
            But you can if you want do more complicated things:
            elt.convertDimension(&#34;H+W&#34;)
                    -&gt;  screen_height + screen_width
            elt.convertDimension(&#34;p*300+max(w, h)&#34;)
                    -&gt; 300 + max(element_width, screen_height)

        Note:
            When using question mark dimension (like &#34;?*2&#34;), the question mark
            MUST be at the beginning of the string
        &#34;&#34;&#34;
        if isinstance(dimension, int):
            return dimension
        elif isinstance(dimension, str):
            nd = &#34;&#34;
            W = self.parentPSSMScreen.width
            H = self.parentPSSMScreen.height
            if self.area:
                (x, y), (w, h) = self.area
            else:
                # area not defined. Instead of being stuck, let&#39;s assume the
                # screen height and width are a decent alternative
                w, h = W, H
            for c in dimension:
                if c == &#39;p&#39; or c == &#39;P&#39;:
                    nd += &#39;1&#39;
                elif c == &#39;W&#39;:      # screen width
                    nd += str(W)
                elif c == &#39;H&#39;:      # screen height
                    nd += str(H)
                elif c == &#39;w&#39;:      # element width
                    nd += str(w)
                elif c == &#39;h&#39;:      # element height
                    nd += str(h)
                else:           # A standard character
                    nd += c
            if dimension[0] == &#39;?&#39;:
                # We return the string, another function will take care of
                # evaluating it
                return nd
            else:
                return int(eval(nd))        # Then we can evaluate the input
        else:
            print(&#34;[PSSM] Could not parse the dimension&#34;)
            return dimension

    def pssmOnClickInside(self, coords=None):
        &#34;&#34;&#34;
        Each Element can also have a pssm function implemented on click.
        By default, it does nothing.
        &#34;&#34;&#34;
        return None


# ########################## - Layout Elements - ##############################
class Layout(Element):
    &#34;&#34;&#34;
    A layout is a quite general kind of Element :
    If must be given the working area, and a layout, and will generate every
    element of the layout

    Args:
        layout (list): The given layout (see example below). It is basically a
        list of rows. Each row is a list containing : the height of the row,
        then as many tuples as you want, each tuple being a
        (pssm.Element, width) instance
        background_color
        area
        ... all other arguments from the pssm.Element class

    Example of usage:
        See [examples](examples/index.html)
    &#34;&#34;&#34;
    def __init__(self, layout, area=None, background_color=&#34;white&#34;, **kwargs):
        super().__init__()
        self.area = area
        self.layout = layout
        self.isValid = self.isLayoutValid()
        self.background_color = background_color
        self.areaMatrix = None
        self.imgMatrix = None
        self.borders = None
        self.isLayout = True
        for param in kwargs:
            setattr(self, param, kwargs[param])

    def isLayoutValid(self):
        # TODO : to be tested
        layout = self.layout
        if not isinstance(layout, list):
            raise Exception(&#34;Layout Element is supposed to be a list&#34;)
        for row in layout:
            if not isinstance(row, list):
                raise Exception(&#34;A layout row is supposed to be a list&#34;)
            elif len(row) == 0:
                raise Exception(&#34;A layout row cannot be empty&#34;)
            elif not isinstance(row[0], str) and not isinstance(row[0], int):
                raise Exception(
                    &#34;The first element of a row (its height) should be a &#34; +
                    &#34;string or an integer&#34;
                )
            for j in range(1, len(row)):
                eltTuple = row[j]
                isTuple = isinstance(eltTuple, tuple)
                isList = isinstance(eltTuple, list)
                if not (isTuple or isList):
                    raise Exception(
                        &#34;A layout row should be a list of Tuple &#34; +
                        &#34;(except for its first element)&#34;
                    )
                if len(eltTuple) != 2:
                    raise Exception(
                        &#34;A layout element should be a Tuple : &#34; +
                        &#34;(Element, elementWidth)&#34;
                    )
                isStr = isinstance(eltTuple[1], str)
                isInt = isinstance(eltTuple[1], int)
                if not (isInt or isStr):
                    raise Exception(
                        &#34;An element width should be a string or an integer&#34;
                    )
                isElement = isinstance(eltTuple[0], Element)
                if not (isElement or eltTuple[0] is None):
                    raise Exception(
                        &#34;A layout element should be a Tuple : &#34; +
                        &#34;(Element, elementWidth), with Element designating &#34; +
                        &#34; a PSSM Element&#34;
                    )
        return True

    def generator(self, area=None, skipNonLayoutGen=False):
        &#34;&#34;&#34;
        Builds one img out of all the Elements it is being given
        &#34;&#34;&#34;
        if area is not None:
            self.area = area
        self.createAreaMatrix()
        self.createImgMatrix(skipNonLayoutGen=skipNonLayoutGen)
        [(x, y), (w, h)] = self.area
        colorType = self.parentPSSMScreen.colorType
        color = get_Color(self.background_color, colorType)
        placeholder = Image.new(colorType, (w, h), color=color)
        for i in range(len(self.areaMatrix)):
            for j in range(len(self.areaMatrix[i])):
                [(elt_x, elt_y), (elt_w, elt_h)] = self.areaMatrix[i][j]
                relative_x = elt_x - x
                relative_y = elt_y - y
                elt_img = self.imgMatrix[i][j]
                if elt_img is not None:
                    pos = (relative_x, relative_y)
                    placeholder.paste(self.imgMatrix[i][j], pos)
        self.imgData = placeholder
        return self.imgData

    def createImgMatrix(self, skipNonLayoutGen=False):
        matrix = []
        if not self.areaMatrix:
            print(&#34;[PSSM Layout] Error, areaMatrix has to be defined first&#34;)
            return None
        for i in range(len(self.layout)):
            row = []
            for j in range(1, len(self.layout[i])):
                elt, _ = self.layout[i][j]
                if elt is None:
                    elt_area = self.areaMatrix[i][j-1]
                    elt_img = None
                else:
                    elt_area = self.areaMatrix[i][j-1]
                    if not elt.isLayout and skipNonLayoutGen:
                        elt_img = elt.imgData
                    else:
                        elt_img = elt.generator(area=elt_area)
                row.append(elt_img)
            matrix.append(row)
        self.imgMatrix = matrix

    def createAreaMatrix(self):
        # TODO : must honor min and max
        matrix = []
        n_rows = len(self.layout)
        [(x, y), (w, h)] = self.area[:]
        x0, y0 = x, y
        for i in range(n_rows):     # Lets loop through the rows
            row = self.layout[i]
            row_cols = []           # All the columns of this particular row
            row_height = row[0]
            converted_height = self.convertDimension(row_height)
            if isinstance(converted_height, int):
                true_row_height = converted_height
            else:
                remaining_height = self.calculate_remainingHeight()
                dim = str(remaining_height) + converted_height[1:]
                true_row_height = int(eval(dim))
            for j in range(1, len(row)):
                (element, element_width) = row[j]
                converted_width = self.convertDimension(element_width)
                if element is not None:
                    for parent in self.parentLayouts:
                        self.layout[i][j][0].parentLayouts.append(parent)
                    self.layout[i][j][0].parentLayouts.append(self)
                    self.layout[i][j][0].parentPSSMScreen = \
                        self.parentPSSMScreen
                if isinstance(converted_width, int):
                    true_elt_width = converted_width
                else:
                    remaining_width = self.calculate_remainingWidth(i)
                    dim = str(remaining_width) + converted_width[1:]
                    true_elt_width = int(eval(dim))
                    self.layout[i][j] = (self.layout[i][j][0], true_elt_width)
                element_area = [(x0, y0), (true_elt_width, true_row_height)]
                x0 += true_elt_width
                row_cols.append(element_area)
            y0 += true_row_height
            x0 = x
            matrix.append(row_cols)
        self.areaMatrix = matrix

    def createEltList(self):
        &#34;&#34;&#34;
        Returns a list of all the elements the Layout Element contains
        &#34;&#34;&#34;
        eltList = []
        for row in self.layout:
            for i in range(1, len(row)):
                elt, _ = row[i]
                if elt is not None:
                    eltList.append(elt)
        return eltList

    def calculate_remainingHeight(self):
        rows = self.extract_rowsHeight()
        total_questionMarks_weight = 0
        total_height = 0
        for dimension in rows:
            converted_dimension = self.convertDimension(dimension)
            if isinstance(converted_dimension, int):
                total_height += converted_dimension
            else:
                weight = eval(&#34;1&#34; + converted_dimension[1:])
                total_questionMarks_weight += weight
        layout_height = self.area[1][1]
        return int((layout_height - total_height)/total_questionMarks_weight)

    def calculate_remainingWidth(self, rowIndex):
        cols = self.extract_colsWidth(rowIndex)
        total_width = 0
        total_questionMarks_weight = 0
        for dimension in cols:
            converted_dimension = self.convertDimension(dimension)
            if isinstance(converted_dimension, int):
                total_width += converted_dimension
            else:
                weight = eval(&#34;1&#34; + converted_dimension[1:])
                total_questionMarks_weight += weight
        layout_width = self.area[1][0]
        return int((layout_width - total_width)/total_questionMarks_weight)

    def extract_rowsHeight(self):
        rows = []
        for row in self.layout:
            rows.append(row[0])
        return rows

    def extract_colsWidth(self, rowIndex):
        cols = []
        for col in self.layout[rowIndex]:
            if isinstance(col, tuple):
                cols.append(col[1])
        return cols

    def _dispatchClick(self, coords):
        &#34;&#34;&#34;
        Finds the element on which the user clicked
        &#34;&#34;&#34;
        self._dispatchClick_LINEAR(coords)

    def _dispatchClick_LINEAR(self, coords):
        &#34;&#34;&#34;
        Linear search throuh both the rows and the columns
        &#34;&#34;&#34;
        click_x, click_y = coords
        # Linear search though the rows
        for i in range(len(self.areaMatrix)):
            if len(self.areaMatrix[i]) == 0:
                # That&#39;s a fake row (a margin row)
                continue
            first_row_elt = self.areaMatrix[i][0]
            last_row_elt = self.areaMatrix[i][-1]
            x = first_row_elt[0][0]
            y = first_row_elt[0][1]
            w = last_row_elt[0][0] + last_row_elt[1][0] - first_row_elt[0][0]
            h = last_row_elt[0][1] + last_row_elt[1][1] - first_row_elt[0][1]
            if coordsInArea(click_x, click_y, [(x, y), (w, h)]):
                # CLick was in that row
                for j in range(len(self.areaMatrix[i])):
                    # Linear search through the columns
                    if coordsInArea(click_x, click_y, self.areaMatrix[i][j]):
                        # Click was on that element
                        elt, _ = self.layout[i][j+1]
                        if elt is not None and elt.onclickInside is not None:
                            self.parentPSSMScreen._dispatchClickToElt(
                                coords, elt
                            )
                        return True
        return False

    def _dispatchClick_DICHOTOMY_colsOnly(self, coords):
        &#34;&#34;&#34;
        Linear search through the rows, dichotomy for the columns
        (Because of the empty rows, a dichotomy for the rows doesn&#39;t work)
        NEEDS TO BE FIXED TOO (example : two buttons in a row)
        &#34;&#34;&#34;
        click_x, click_y = coords
        row_A = -1
        for i in range(len(self.areaMatrix)):
            # Linear search though the rows
            if len(self.areaMatrix[i]) == 0:
                # That&#39;s a fake row (a margin row)
                continue
            first_row_elt = self.areaMatrix[i][0]
            last_row_elt = self.areaMatrix[i][-1]
            x = first_row_elt[0][0]
            y = first_row_elt[0][1]
            w = last_row_elt[0][0] + last_row_elt[1][0] - first_row_elt[0][0]
            h = last_row_elt[0][1] + last_row_elt[1][1] - first_row_elt[0][1]
            if coordsInArea(click_x, click_y, [(x, y), (w, h)]):
                # CLick was in that row
                row_A = i
                break
        if row_A == -1:
            return None
        col_A = 0
        col_C = max(len(self.areaMatrix[row_A]) - 1, 0)
        xA = self.areaMatrix[row_A][col_A][0][0]
        xC = self.areaMatrix[row_A][col_C][0][0]
        if click_x &lt; xA:
            return None
        if click_x &gt; xC + self.areaMatrix[row_A][col_C][1][0]:
            return None
        while col_C &gt; col_A + 1:
            col_B = int(0.5*(col_A+col_C))      # The average of the two
            xB = self.areaMatrix[row_A][col_B][0][0]
            if click_x &gt;= xB or col_B == col_C:
                col_A = col_B
                xA = xB
            else:
                col_C = col_B
                xC = xB
        # Element is at indexes row_A, col_A
        elt, _ = self.layout[row_A][col_A+1]
        if elt is not None and elt.onclickInside is not None:
            self.parentPSSMScreen._dispatchClickToElt(coords, elt)
        return True

    def _dispatchClick_DICHOTOMY_Full_ToBeFixed(self, coords):
        &#34;&#34;&#34;
        Finds the element on which the user clicked
        Implemented with dichotomy search (with the hope of making things
        faster, especially the integrated keyboard)
        &#34;&#34;&#34;
        # TODO : To be fixed
        # For now it does not work, because there are empty rows which
        # break the loop
        click_x, click_y = coords
        row_A = 0
        row_C = max(len(self.areaMatrix) - 1, 0)
        print(self.areaMatrix[row_C])
        while len(self.areaMatrix[row_A]) == 0:
            row_A += 1
        while len(self.areaMatrix[row_C]) == 0:
            row_C -= 1
        # First column THEN first row , [(x, y), (w, h)] THUS first tuple of
        # list THEN second coordinate of tuple
        yA = self.areaMatrix[row_A][0][0][1]
        yC = self.areaMatrix[row_C][0][0][1]
        if click_y &lt; yA:
            return None
        if click_y &gt; yC + self.areaMatrix[row_C][0][1][1]:
            return None
        while row_C &gt; row_A+1:
            row_B = int(0.5*(row_A+row_C))      # The average of the two
            while len(self.areaMatrix[row_B]) == 0:
                row_B += 1
            yB = self.areaMatrix[row_B][0][0][1]
            if click_y &gt;= yB or row_B == row_C:
                row_A = row_B
                yA = yB
            else:
                row_C = row_B
                yC = yB
        # User clicked on element ar row of index row_A
        # Let&#39;s do the same for the column
        col_A = 0
        col_C = max(len(self.areaMatrix[row_A]) - 1, 0)
        xA = self.areaMatrix[row_A][col_A][0][0]
        xC = self.areaMatrix[row_A][col_C][0][0]
        if click_x &lt; xA:
            return None
        if click_x &gt; xC + self.areaMatrix[row_A][col_C][1][0]:
            return None
        while col_C &gt; col_A + 1:
            col_B = int(0.5*(col_A+col_C))      # The average of the two
            xB = self.areaMatrix[row_A][col_B][0][0]
            if click_x &gt;= xB or col_B == col_C:
                col_A = col_B
                xA = xB
            else:
                col_C = col_B
                xC = xB
        # Element is at indexes row_A, col_A
        elt, _ = self.layout[row_A-2][col_A+1]
        if elt is not None and elt.onclickInside is not None:
            self.parentPSSMScreen._dispatchClickToElt(coords, elt)
        return True


class ButtonList(Layout):
    &#34;&#34;&#34;
    Generates a Layout with only one item per row, all the same type (buttons)
    and same height and width
    Args:
        button (list): a [{&#34;text&#34;:&#34;my text&#34;,&#34;onclickInside&#34;:onclickInside},
            someOtherDict, someOtherDict] array. Each dict will contain the
            parameters of each button of the button list
        borders (list): a [top, bottom,left,right] array
    &#34;&#34;&#34;
    def __init__(self, buttons, margins=[0, 0, 0, 0], spacing=0, **kwargs):
        self.buttons = buttons
        self.margins = margins
        self.spacing = spacing
        layout = self.build_layoutFromButtons()
        super().__init__(layout)
        for param in kwargs:
            setattr(self, param, kwargs[param])

    def build_layoutFromButtons(self):
        # TODO : must honor min_width,max_width etc
        [top, bottom, left, right] = self.margins
        buttonLayout = [[top-self.spacing]]
        for button in self.buttons:
            buttonElt = Button(text=button[&#39;text&#39;])
            for param in button:
                setattr(buttonElt, param, button[param])
            row_height = &#34;?&#34;
            buttonLayout.append([self.spacing])
            row = [row_height, (None, left), (buttonElt, &#34;?&#34;), (None, right)]
            buttonLayout.append(row)
        buttonLayout.append([bottom])
        return buttonLayout


class OSK(Layout):
    &#34;&#34;&#34;
    A PSSM Layout element which builds an on-screen keyboard
    Args:
        keymapPath (str): a path to a PSSMOSK keymap (like the one included)
        onKeyPress (function): A callback function. Will be given keyType and
            keyChar as argument
    &#34;&#34;&#34;
    def __init__(self, keymapPath=DEFAULT_KEYMAP_PATH, onKeyPress=None,
                 area=None, **kwargs):
        if not keymapPath:
            keymapPath = DEFAULT_KEYMAP_PATH
        self.keymapPaths = keymapPath
        self.keymap = {&#39;standard&#39;: None, &#39;caps&#39;: None, &#39;alt&#39;: None}
        self.keymap_layouts = {&#39;standard&#39;: None, &#39;caps&#39;: None, &#39;alt&#39;: None}
        self.keymap_imgs = {&#39;standard&#39;: None, &#39;caps&#39;: None, &#39;alt&#39;: None}
        with open(self.keymapPaths[&#39;standard&#39;]) as json_file:
            self.keymap[&#39;standard&#39;] = json.load(json_file)
        with open(self.keymapPaths[&#39;caps&#39;]) as json_file:
            self.keymap[&#39;caps&#39;] = json.load(json_file)
        with open(self.keymapPaths[&#39;alt&#39;]) as json_file:
            self.keymap[&#39;alt&#39;] = json.load(json_file)
        self.lang = self.keymap[&#39;standard&#39;][&#34;lang&#34;]
        self.onKeyPress = onKeyPress
        for param in kwargs:
            setattr(self, param, kwargs[param])
        self.view = &#39;standard&#39;
        self.keymap_layouts[&#39;standard&#39;] = self.build_layout(
                                               self.keymap[&#39;standard&#39;])
        self.keymap_layouts[&#39;caps&#39;] = self.build_layout(self.keymap[&#39;caps&#39;])
        self.keymap_layouts[&#39;alt&#39;] = self.build_layout(self.keymap[&#39;alt&#39;])
        # Initialize layout with standard view
        self.layout = self.keymap_layouts[&#39;standard&#39;]
        super().__init__(self.layout)
        self.area = area

    def generator(self, area=None, forceRegenerate=False,
                  skipNonLayoutGen=False):
        &#34;&#34;&#34;
        This generator is a bit special : we don&#39;t want it to regenerate
        everything everytime we change view. So we will generate all the views
        at once the first time. Then, unless asked to, we will only return the
        appropriate image.
        &#34;&#34;&#34;
        isStDefined = self.keymap_imgs[&#39;standard&#39;]
        isCaDefined = self.keymap_imgs[&#39;caps&#39;]
        isAlDefined = self.keymap_imgs[&#39;alt&#39;]
        areAllDefined = isStDefined and isCaDefined and isAlDefined
        if forceRegenerate or (not areAllDefined):
            print(&#34;[PSSM OSK] Regenration started&#34;)
            # Let&#39;s create all the Images
            # Standard view is created last, because it is the one which is to
            # be displayed
            def generateLayout(name):
                self.layout = self.keymap_layouts[name]
                self.keymap_imgs[name] = super(OSK, self).generator(area=area)
            generateLayout(&#34;caps&#34;)
            generateLayout(&#34;alt&#34;)
            generateLayout(&#34;standard&#34;)
        self.imgData = self.keymap_imgs[self.view]
        return self.keymap_imgs[self.view]

    def build_layout(self, keymap):
        oskLayout = []
        spacing = keymap[&#34;spacing&#34;]
        for row in keymap[&#34;rows&#34;]:
            buttonRow = [&#34;?&#34;, (None, spacing)]
            for key in row:
                label = self.getKeyLabel(key)
                color_condition = key[&#34;keyType&#34;] != KTstandardChar
                background_color = &#34;gray12&#34; if color_condition else &#34;white&#34;
                outline_color = &#34;white&#34; if key[&#34;isPadding&#34;] else &#34;black&#34;
                willChangeLayout = key[&#34;keyType&#34;] in [
                    KTcapsLock, KTalt, KTcarriageReturn
                ]
                invertOnClick = False if willChangeLayout else True
                buttonElt = Button(
                    text=label,
                    font_size=&#34;H*0.02&#34;,
                    background_color=background_color,
                    outline_color=outline_color,
                    onclickInside=self.handleKeyPress,
                    user_data=key,
                    wrap_textOverflow=False,
                    invertOnClick=invertOnClick
                )
                key_width = key[&#34;keyWidth&#34;]
                buttonRow.append((buttonElt, key_width))
                buttonRow.append((None, spacing))
            oskLayout.append(buttonRow)
            oskLayout.append([spacing])
        return oskLayout

    def handleKeyPress(self, elt, coords):
        keyType = elt.user_data[&#34;keyType&#34;]
        keyChar = elt.user_data[&#34;char&#34;]
        if keyType == KTcapsLock:
            # In this particular case, we can assume the keyboard will always
            # be on top.
            # Therefore, no need to print everything
            self.view = &#39;caps&#39; if self.view != &#39;caps&#39; else &#39;standard&#39;
            self.layout = self.keymap_layouts[self.view]
            self.imgData = self.keymap_imgs[self.view]
            self.parentPSSMScreen.simplePrintElt(self)
        elif keyType == KTalt:
            # In this particular case, we can assume the keyboard will always
            # be on top
            # Therefore, no need to print everything
            self.view = &#39;alt&#39; if self.view != &#39;alt&#39; else &#39;standard&#39;
            self.layout = self.keymap_layouts[self.view]
            self.imgData = self.keymap_imgs[self.view]
            self.parentPSSMScreen.simplePrintElt(self)
        if self.onKeyPress:
            self.onKeyPress(keyType, keyChar)

    def getKeyLabel(self, key):
        kt = key[&#34;keyType&#34;]
        if kt == KTstandardChar:
            return key[&#34;char&#34;]
        elif kt == KTalt:
            return &#34;ALT&#34;
        elif kt == KTbackspace:
            return &#34;BACK&#34;
        elif kt == KTcapsLock:
            return &#34;CAPS&#34;
        elif kt == KTcarriageReturn:
            return &#34;RET&#34;
        elif kt == KTcontrol:
            return &#34;CTRL&#34;
        elif kt == KTdelete:
            return &#34;DEL&#34;
        return &#34;&#34;


class Popup(Layout):
    &#34;&#34;&#34;
    A popup to be displayed above everything else, to simple ask a question
    Args:
        layout (list): The list of PSSMElements to be displayed. cf Layout
        width (str): The width of the popup
        height (str): The height of the popup
        xPos (float): Relative position on the x axis of the center point
        yPos (float): Relative position on the y axis of the center point
    &#34;&#34;&#34;
    def __init__(self, layout=[], width=&#34;W*0.8&#34;, height=&#34;H*0.5&#34;,
                 xPos=0.5, yPos=0.3, **kwargs):
        super().__init__(layout=layout)
        self.width = width
        self.height = height
        self.xPos = xPos
        self.yPos = yPos
        for param in kwargs:
            setattr(self, param, kwargs[param])

    def make_area(self):
        w = self.convertDimension(self.width)
        h = self.convertDimension(self.height)
        x = self.convertDimension(&#34;W*&#34; + str(self.xPos)) - int(0.5*w)
        y = self.convertDimension(&#34;H*&#34; + str(self.yPos)) - int(0.5*h)
        self.area = [(x, y), (w, h)]
        return self.area


class PoputInput(Popup):
    def __init__(self, titleText=&#34;&#34;, mainText=&#34;&#34;, confirmText=&#34;OK&#34;,
                 titleFont=DEFAULT_FONT, titleFontSize=DEFAULT_FONT_SIZE,
                 mainFont=DEFAULT_FONT, mainFontSize=DEFAULT_FONT_SIZE,
                 inputFont=DEFAULT_FONT, inputFontSize=DEFAULT_FONT_SIZE,
                 confirmFont=DEFAULT_FONT, confirmFontSize=DEFAULT_FONT_SIZE,
                 titleFontColor=&#34;black&#34;, mainFontColor=&#34;black&#34;,
                 inputFontColor=&#34;black&#34;, confirmFontColor=&#34;black&#34;,
                 mainTextXPos=&#34;center&#34;, mainTextYPos=&#34;center&#34;,
                 isMultiline=False, **kwargs):
        super().__init__()
        self.titleText = titleText
        self.mainText = mainText
        self.confirmText = confirmText
        self.isMultiline = isMultiline
        self.titleFont = titleFont
        self.mainFont = mainFont
        self.inputFont = inputFont
        self.confirmFont = confirmFont
        self.titleFontSize = titleFontSize
        self.mainFontSize = mainFontSize
        self.inputFontSize = inputFontSize
        self.confirmFontSize = confirmFontSize
        self.titleFontColor = titleFontColor
        self.mainFontColor = mainFontColor
        self.inputFontColor = inputFontColor
        self.confirmFontColor = confirmFontColor
        self.mainTextXPos = mainTextXPos
        self.mainTextYPos = mainTextYPos
        self.userConfirmed = False
        self.inputBtn = None
        self.okBtn = None
        for param in kwargs:
            setattr(self, param, kwargs[param])
        self.build_layout()

    def generator(self,**kwargs):
        self.make_area()
        super().generator(**kwargs)

    def build_layout(self):
        titleBtn = Button(
            text=self.titleText,
            font=self.titleFont,
            font_size=self.titleFontSize,
            font_color=self.titleFontColor
        )
        mainBtn = Button(
            text=self.mainText,
            font=self.mainFont,
            font_size=self.mainFontSize,
            font_color=self.mainFontColor,
            text_xPosition=self.mainTextXPos,
            text_yPosition=self.mainTextYPos
        )
        if self.isMultiline:
            onReturn = returnFalse
        else:
            onReturn = self.toggleConfirmation
        inputBtn = Input(
            font=self.inputFont,
            font_size=self.inputFontSize,
            font_color=self.inputFontColor,
            isMultiline=self.isMultiline,
            onReturn=onReturn
        )
        okBtn = Button(
            text=self.confirmText,
            font=self.confirmFont,
            font_size=self.confirmFontSize,
            font_color=self.confirmFontColor,
            onclickInside=self.toggleConfirmation
        )
        self.inputBtn = inputBtn
        lM = (None,1)
        layout = [
            [&#34;?*1.5&#34;, (titleBtn, &#34;?&#34;), lM],
            [&#34;?*3&#34;, (mainBtn, &#34;?&#34;), lM],
            [&#34;?*2&#34;, (inputBtn, &#34;?&#34;), lM],
            [&#34;?*1&#34;, (okBtn, &#34;?&#34;), lM]
        ]
        self.layout = layout
        return layout

    def toggleConfirmation(self, elt=None, coords=None):
            print(&#34;Toggling confirmation&#34;)
            self.userConfirmed = True

    def waitForResponse(self):
        while not self.userConfirmed:
            self.parentPSSMScreen.device.wait(0.01)
        self.parentPSSMScreen.OSKHide()
        input = self.inputBtn.getInput()
        self.userConfirmed = False  # Reset the state
        self.parentPSSMScreen.removeElt(self)
        return input


class PopupConfirm(Popup):
    def __init__(self, titleText=&#34;&#34;, mainText=&#34;&#34;, confirmText=&#34;OK&#34;,
                 cancelText=&#34;Cancel&#34;,
                 titleFont=DEFAULT_FONT, titleFontSize=DEFAULT_FONT_SIZE,
                 mainFont=DEFAULT_FONT, mainFontSize=DEFAULT_FONT_SIZE,
                 confirmFont=DEFAULT_FONT, confirmFontSize=DEFAULT_FONT_SIZE,
                 titleFontColor=&#34;black&#34;, mainFontColor=&#34;black&#34;,
                 confirmFontColor=&#34;black&#34;,
                 mainTextXPos=&#34;center&#34;, mainTextYPos=&#34;center&#34;,
                 **kwargs):
        super().__init__()
        self.titleText = titleText
        self.mainText = mainText
        self.confirmText = confirmText
        self.cancelText = cancelText
        self.titleFont = titleFont
        self.mainFont = mainFont
        self.confirmFont = confirmFont
        self.titleFontSize = titleFontSize
        self.mainFontSize = mainFontSize
        self.confirmFontSize = confirmFontSize
        self.titleFontColor = titleFontColor
        self.mainFontColor = mainFontColor
        self.confirmFontColor = confirmFontColor
        self.mainTextXPos = mainTextXPos
        self.mainTextYPos = mainTextYPos
        self.userAction = 0
        self.okBtn = None
        self.cancelBtn = None
        for param in kwargs:
            setattr(self, param, kwargs[param])
        self.build_layout()

    def generator(self,**kwargs):
        self.make_area()
        super().generator(**kwargs)

    def build_layout(self):
        titleBtn = Button(
            text=self.titleText,
            font=self.titleFont,
            font_size=self.titleFontSize,
            font_color=self.titleFontColor
        )
        mainBtn = Button(
            text=self.mainText,
            font=self.mainFont,
            font_size=self.mainFontSize,
            font_color=self.mainFontColor,
            text_xPosition=self.mainTextXPos,
            text_yPosition=self.mainTextYPos
        )
        okBtn = Button(
            text=self.confirmText,
            font=self.confirmFont,
            font_size=self.confirmFontSize,
            font_color=self.confirmFontColor,
            onclickInside=self.confirm
        )
        cancelBtn = Button(
            text=self.cancelText,
            font=self.confirmFont,
            font_size=self.confirmFontSize,
            font_color=self.confirmFontColor,
            onclickInside=self.cancel
        )
        lM = (None,1)
        layout = [
            [&#34;?*1.5&#34;, (titleBtn, &#34;?&#34;), lM],
            [&#34;?*3&#34;, (mainBtn, &#34;?&#34;), lM],
            [&#34;?*1&#34;, (okBtn, &#34;?&#34;), (cancelBtn, &#34;?&#34;), lM]
        ]
        self.layout = layout
        return layout

    def confirm(self, elt=None, coords=None):
            self.userAction = 1

    def cancel(self,elt=None, coords=None):
            self.userAction = 2

    def waitForResponse(self):
        while self.userAction == 0:
            self.parentPSSMScreen.device.wait(0.01)
        self.parentPSSMScreen.OSKHide()
        hasConfirmed = self.userAction == 1
        self.userAction = 0  # Reset the state
        self.parentPSSMScreen.removeElt(self)
        return hasConfirmed




# ########################## - Simple Elements - ##############################
class Rectangle(Element):
    &#34;&#34;&#34;
    A rectangle
    Args:
        background_color (str): The background color
        outline_color (str): The border color
    &#34;&#34;&#34;
    def __init__(self, background_color=&#34;white&#34;, outline_color=&#34;gray3&#34;,
                 parentPSSMScreen=None):
        super().__init__()
        self.background_color = background_color
        self.outline_color = outline_color
        self.parentPSSMScreen = parentPSSMScreen

    def generator(self, area):
        [(x, y), (w, h)] = area
        self.area = area
        colorType = self.parentPSSMScreen.colorType
        img = Image.new(
            colorType,
            (w, h),
            color=get_Color(&#34;white&#34;, colorType)
        )
        rect = ImageDraw.Draw(img, colorType)
        fill_color = get_Color(self.background_color, colorType)
        outline_color = get_Color(self.outline_color, colorType)
        rect.rectangle(
            [(0, 0), (w-1, h-1)],
            fill=fill_color,
            outline=outline_color
        )
        self.imgData = img
        return self.imgData


class RectangleRounded(Element):
    &#34;&#34;&#34;
    A rectangle, but with rounded corners
    &#34;&#34;&#34;
    def __init__(self, radius=20, background_color=&#34;white&#34;,
                 outline_color=&#34;gray3&#34;, parentPSSMScreen=None):
        super().__init__()
        self.radius = radius
        self.background_color = background_color
        self.outline_color = outline_color
        self.parentPSSMScreen = parentPSSMScreen

    def generator(self, area):
        [(x, y), (w, h)] = area
        self.area = area
        colorType = self.parentPSSMScreen.colorType
        rectangle = Image.new(
            colorType,
            (w, h),
            color=get_Color(&#34;white&#34;, colorType)
        )
        draw = ImageDraw.Draw(rectangle)
        draw.rectangle(
            [(0, 0), (w, h)],
            fill=get_Color(self.background_color, colorType),
            outline=get_Color(self.outline_color, colorType)
        )
        draw.line(
            [(self.radius, h-1), (w-self.radius, h-1)],
            fill=get_Color(self.outline_color, colorType),
            width=1
        )
        draw.line(
            [(w-1, self.radius), (w-1, h-self.radius)],
            fill=get_Color(self.outline_color, colorType),
            width=1
        )
        corner = roundedCorner(
            self.radius,
            self.background_color,
            self.outline_color,
            self.parentPSSMScreen.colorType
        )
        rectangle.paste(corner, (0, 0))
        # Rotate the corner and paste it
        rectangle.paste(corner.rotate(90), (0, h - self.radius))
        rectangle.paste(corner.rotate(180), (w - self.radius, h - self.radius))
        rectangle.paste(corner.rotate(270), (w - self.radius, 0))
        self.imgData = rectangle
        return self.imgData


class Button(Element):
    &#34;&#34;&#34;
    Basically a rectangle (or rounded rectangle) with text printed on it
    Args:
        text (str): The main text to be written on it
        font (str): Path to a font file (ttf file), or one of PSSM built-in
            fonts (e.g. &#34;Merriweather-Bold&#34;, &#34;default&#34;, &#34;Merriweather-Regular&#34;,
            ...) (see the font folder for the complete list)
        font_size (int): The font size
        font_color (str): The color of the font : &#34;white&#34;, &#34;black&#34;, &#34;gray0&#34; to
            &#34;gray15&#34; or a (red, green, blue, transparency) tuple
        wrap_textOverflow (bool): (True by default) Wrap text in order to avoid
         it overflowing. The cuts are made between words.
        text_xPosition (str or int): can be left, center, right, or an integer
            value, or a pssm string dimension
        text_yPosition (str or int): can be left, center, right, or an integer
            value, or a pssm string dimension
        background_color (str): The background color
        outline_color (str): The border color
        radius (int): If not 0, then add rounded corners of this radius
    &#34;&#34;&#34;
    def __init__(self, text=&#34;&#34;, font=DEFAULT_FONT, font_size=DEFAULT_FONT_SIZE,
                 background_color=&#34;white&#34;, outline_color=&#34;black&#34;, radius=0,
                 font_color=&#34;black&#34;, text_xPosition=&#34;center&#34;,
                 text_yPosition=&#34;center&#34;, wrap_textOverflow=True, **kwargs):
        super().__init__()
        self.background_color = background_color
        self.outline_color = outline_color
        self.text = text
        self.font = tools_parseKnownFonts(font)
        self.font_size = font_size
        self.radius = radius
        self.font_color = font_color
        self.text_xPosition = text_xPosition
        self.text_yPosition = text_yPosition
        self.wrap_textOverflow = wrap_textOverflow
        for param in kwargs:
            setattr(self, param, kwargs[param])
        self.loaded_font = None
        self.convertedText = None
        self.imgDraw = None

    def generator(self, area=None):
        if area is None:
            area = self.area
        [(x, y), (w, h)] = area
        self.area = area
        if not isinstance(self.font_size, int):
            self.font_size = self.convertDimension(self.font_size)
            if not isinstance(self.font_size, int):
                # That&#39;s a question mark dimension, or an invalid dimension.
                # Rollback to default font size
                self.font_size = self.convertDimension(DEFAULT_FONT_SIZE)
        loaded_font = ImageFont.truetype(self.font, self.font_size)
        self.loaded_font = loaded_font
        if self.radius &gt; 0:
            rect = RectangleRounded(
                radius=self.radius,
                background_color=self.background_color,
                outline_color=self.outline_color,
                parentPSSMScreen=self.parentPSSMScreen
            )
        else:
            rect = Rectangle(
                background_color=self.background_color,
                outline_color=self.outline_color,
                parentPSSMScreen=self.parentPSSMScreen
            )
        rect_img = rect.generator(self.area)
        imgDraw = ImageDraw.Draw(rect_img, self.parentPSSMScreen.colorType)
        self.imgDraw = imgDraw
        if self.wrap_textOverflow:
            myText = self.wrapText(self.text, loaded_font, imgDraw)
        else:
            myText = self.text
        self.convertedText = myText
        text_w, text_h = imgDraw.textsize(myText, font=loaded_font)
        x = tools_convertXArgsToPX(self.text_xPosition, w, text_w, myElt=self)
        y = tools_convertYArgsToPX(self.text_yPosition, h, text_h, myElt=self)
        imgDraw.text(
            (x, y),
            myText,
            font=loaded_font,
            fill=get_Color(self.font_color, self.parentPSSMScreen.colorType)
        )
        self.imgData = rect_img
        return self.imgData

    def wrapText(self, text, loaded_font, imgDraw):
        def get_text_width(text):
            return imgDraw.textsize(text=text, font=loaded_font)[0]

        [(x, y), (max_width, h)] = self.area
        text_lines = [
            &#39; &#39;.join([w.strip() for w in line.split(&#39; &#39;) if w])
            for line in text.split(&#39;\n&#39;)
            if line
        ]
        space_width = get_text_width(&#34; &#34;)
        wrapped_lines = []
        buf = []
        buf_width = 0

        for line in text_lines:
            for word in line.split(&#39; &#39;):
                word_width = get_text_width(word)

                expected_width = word_width if not buf else \
                    buf_width + space_width + word_width

                if expected_width &lt;= max_width:
                    # word fits in line
                    buf_width = expected_width
                    buf.append(word)
                else:
                    # word doesn&#39;t fit in line
                    wrapped_lines.append(&#39; &#39;.join(buf))
                    buf = [word]
                    buf_width = word_width
            if buf:
                wrapped_lines.append(&#39; &#39;.join(buf))
                buf = []
                buf_width = 0
        return &#39;\n&#39;.join(wrapped_lines)


class Icon(Element):
    &#34;&#34;&#34;
    An icon, built from an image
    Args:
        file (str): Path to a file, or one of the integrated image (see the
            icon folder for the name of each image). &#39;reboot&#39; for instance
            points to the integrated reboot image.
        centered (bool): Center the icon?
    &#34;&#34;&#34;
    def __init__(self, file, centered=True, **kwargs):
        super().__init__()
        self.file = file
        self.centered = centered
        self.path_to_file = tools_parseKnownImageFile(self.file)
        for param in kwargs:
            setattr(self, param, kwargs[param])

    def generator(self, area):
        self.area = area
        [(x, y), (w, h)] = area
        colorType = self.parentPSSMScreen.colorType
        icon_size = min(area[1][0], area[1][1])
        loadedImg = Image.open(self.path_to_file)
        convImg = loadedImg.convert(colorType)
        iconImg = convImg.resize((icon_size, icon_size))
        if not self.centered:
            self.imgData = iconImg
            return iconImg
        else:
            img = Image.new(
                colorType,
                (w+1, h+1),
                color=get_Color(&#34;white&#34;, colorType)
            )
            x = int(0.5*w-0.5*icon_size)
            y = int(0.5*h-0.5*icon_size)
            img.paste(iconImg, (x, y))
            self.imgData = img
            return img


class Static(Element):
    &#34;&#34;&#34;
    A very simple element which only displays a pillow image
    Args:
        pil_image (str or pil image): path to an image or a pillow image
        centered (bool): Center the image ?
        resize (bool): Make it fit the area ? (proportions are respected)
        rotation (int): an integer rotation angle
        background_color (str): &#34;white&#34;, &#34;black&#34;, &#34;gray0&#34; to &#34;gray15&#34; or a
            (red, green, blue, transparency) tuple
    &#34;&#34;&#34;
    def __init__(self, pil_image, centered=True, resize=True,
                 background_color=&#34;white&#34;, rotation=0, **kwargs):
        super().__init__()
        if isinstance(pil_image, str):
            self.pil_image = Image.open(pil_image)
        else:
            self.pil_image = pil_image
        self.background_color = background_color
        self.centered = centered
        self.resize = resize
        self.rotation = rotation
        for param in kwargs:
            setattr(self, param, kwargs[param])

    def generator(self, area=None):
        # TODO : crop or resize the image to make it fit the area
        (x, y), (w, h) = area
        colorType = self.parentPSSMScreen.colorType
        pil_image = self.pil_image.convert(colorType)
        if self.resize:
            r = min(w/pil_image.width, h/pil_image.height)
            size = (int(pil_image.width*r), int(pil_image.height*r))
            pil_image = self.pil_image.resize(size)
        if self.rotation != 0:
            pil_image = pil_image.rotate(self.rotation,
                                         fillcolor=self.background_color)
        if not self.centered:
            return pil_image
        else:
            img = Image.new(
                colorType,
                (w+1, h+1),
                color=get_Color(self.background_color, colorType)
            )
            x = int(0.5*w-0.5*pil_image.width)
            y = int(0.5*h-0.5*pil_image.height)
            img.paste(pil_image, (x, y))
            self.imgData = img
            return img


class Line(Element):
    &#34;&#34;&#34;
    Draws a simple line
    Args:
        color (str or tuple): &#34;white&#34;, &#34;black&#34;, &#34;gray0&#34; to &#34;gray15&#34; or a
            (red, green, blue, transparency) tuple
        width (int): The width of the line
        type (str): can be &#34;horizontal&#34;, &#34;vertical&#34;, &#34;diagonal1&#34; (top-left to
            bottom right) or &#34;diagonal2&#34; (top-right to bottom-left)
    &#34;&#34;&#34;
    def __init__(self, color=&#34;black&#34;, width=1, type=&#34;horizontal&#34;):
        super().__init__()
        self.color = color
        self.width = width
        self.type = type

    def generator(self, area):
        (x, y), (w, h) = area
        self.area = area
        colorType = self.parentPSSMScreen.colorType
        if self.type == &#34;horizontal&#34;:
            coo = [(0, 0), (w, 0)]
        elif self.type == &#34;vertical&#34;:
            coo = [(0, 0), (0, h)]
        elif self.type == &#34;diagonal1&#34;:
            coo = [(0, 0), (w, h)]
        else:               # Assuming diagonal2
            coo = [(w, 0), (0, h)]
        rectangle = Image.new(
            colorType,
            (w, h),
            color=get_Color(&#34;white&#34;, colorType)
        )
        draw = ImageDraw.Draw(rectangle)
        draw.line(
            coo,
            fill=get_Color(self.color, colorType),
            width=self.width
        )
        self.imgData = rectangle
        return self.imgData


class Input(Button):
    &#34;&#34;&#34;
    Basically a button, except when you click on it, it displays the keyboard.
    It handles typing things for you. so when you click on this element, the
    keyboard shows up, and you can start typing.
    The main thing it does is that it is able to detect between which
    characters the user typed to be able to insert a character between two
    others (and that was no easy task)
    It has a method to retrieve what was typed :
    Input.getInput()
    Args:
        isMultiline (bool): Allow carriage return
        onReturn (function): Function to be executed on carriage return
    &#34;&#34;&#34;
    def __init__(self, isMultiline=True, onReturn=returnFalse, **kwargs):
        super().__init__()
        self.hideCursorWhenLast = True
        self.isMultiline = isMultiline
        self.onReturn = onReturn
        self.allowSetCursorPos = False
        self.isOnTop = True  # Let&#39;s assume an input elt is always on top
        for param in kwargs:
            setattr(self, param, kwargs[param])
        if &#39;font&#39; in kwargs:
            self.font = tools_parseKnownFonts(kwargs[&#34;font&#34;])
        self.cursorPosition = len(self.text)
        self.typedText = self.text[:]
        self.text = self.typedText

    def getInput(self):
        &#34;&#34;&#34;
        Returns the text currently written on the Input box.
        &#34;&#34;&#34;
        return self.typedText

    def pssmOnClickInside(self, coords):
        if not self.parentPSSMScreen.osk:
            print(
                &#34;[PSSM] Keyboard not initialized, Input element cannot be &#34; +
                &#34;properly handled&#34;
            )
            return None
        # Set the callback function to our own
        self.parentPSSMScreen.osk.onKeyPress = self.onKeyPress
        if not self.parentPSSMScreen.isOSKShown:
            # Let&#39;s print the on screen keyboard as it is not already here
            self.parentPSSMScreen.OSKShow()
        elif self.allowSetCursorPos:
            cx, cy = coords
            [(sx, sy), (w, h)] = self.area
            loaded_font = self.loaded_font
            myText = self.convertedText
            imgDraw = self.imgDraw
            text_w, text_h = imgDraw.textsize(myText, font=loaded_font)
            x = tools_convertXArgsToPX(self.text_xPosition, w, text_w,
                                       myElt=self)
            y = tools_convertYArgsToPX(self.text_yPosition, h, text_h,
                                       myElt=self)
            # Then let&#39;s linear search
            wasFound = False
            olines = myText[:].split(&#34;\n&#34;)
            if len(olines) &gt; 0:
                lines = [olines[0]]
            else:
                lines = []
            for i in range(len(olines)):
                lines.append(&#34;\n&#34;)
            linesBefore = &#34;&#34;
            for i in range(len(lines)):
                tw1, th1 = imgDraw.textsize(linesBefore, font=loaded_font)
                linesBefore += lines[i]
                tw2, th2 = imgDraw.textsize(linesBefore, font=loaded_font)
                b_correct_y = cy &gt; sy + x + th1 and cy &lt;= sy + y + th2
                if b_correct_y:
                    for j in range(len(linesBefore)):
                        tw1, th1 = imgDraw.textsize(linesBefore[:j],
                                                    font=loaded_font)
                        tw2, th2 = imgDraw.textsize(linesBefore[:j+1],
                                                    font=loaded_font)
                        b_correct_x = cx &gt; sx + x + tw1 and cx &lt;= sx + x + tw2
                        if b_correct_x:
                            pos = j
                            for line in lines[:i]:
                                pos += len(line)
                            self.setCursorPosition(pos+1)
                            wasFound = True
                    if not wasFound:    # Let&#39;s put it at the end of the row
                        pos = 0
                        for line in lines[:i+1]:
                            pos += len(line)
                        self.setCursorPosition(pos)
                        wasFound = True
            if not wasFound:
                self.setCursorPosition(None)
            pass

    def onKeyPress(self, keyType, keyChar):
        &#34;&#34;&#34;
        Handles each key press.
        By default, it will re-display the input element on each keypress ON
        TOP OF THE SCREEN (not honoring stack position). This allow for a 30%
        speed increase on my basic test. You can change this behaviour by
        setting `InputElt.isOnTop = False`
        &#34;&#34;&#34;
        c = self.cursorPosition
        if keyType == KTstandardChar:
            self.typedText = insertStr(self.typedText, keyChar, c)
            self.setCursorPosition(self.cursorPosition+1, skipPrint=True)
        elif keyType == KTcarriageReturn:
            if self.isMultiline:
                self.typedText = insertStr(self.typedText, &#34;\n&#34;, c)
                self.setCursorPosition(self.cursorPosition+1, skipPrint=True)
            else:
                self.onReturn()
        elif keyType == KTbackspace:
            self.typedText = self.typedText[:c-1] + self.typedText[c:]
            self.setCursorPosition(self.cursorPosition-1, skipPrint=True)
        if self.hideCursorWhenLast:
            if self.cursorPosition &gt;= len(self.typedText):
                # Don&#39;t display the cursor when it is at the last position
                self.text = self.typedText[:]
        else:
            self.text = insertStr(self.typedText, CURSOR_CHAR,
                                  self.cursorPosition)
        if self.isOnTop:
            self.update(reprintOnTop=True)
        else:
            self.update()

    def setCursorPosition(self, pos, skipPrint=False):
        if pos is None:
            pos = len(self.typedText)
        self.cursorPosition = pos
        self.text = insertStr(self.typedText, CURSOR_CHAR, self.cursorPosition)
        if not skipPrint:
            self.update()


# ########################## -     Tools       - ##############################
def roundedCorner(radius, fill=&#34;white&#34;, outline_color=&#34;gray3&#34;, colorType=&#39;L&#39;):
    &#34;&#34;&#34;
    Draw a round corner
    &#34;&#34;&#34;
    corner = Image.new(colorType, (radius, radius), &#34;white&#34;)
    draw = ImageDraw.Draw(corner)
    draw.pieslice(
        (0, 0, radius * 2, radius * 2),
        180,
        270,
        fill=get_Color(fill, colorType),
        outline=get_Color(outline_color, colorType)
    )
    return corner


# ############################# - DOCUMENTATION - #############################
__pdoc__ = {}           # For the documentation
ignoreList = [
    &#39;returnFalse&#39;,
    &#39;coordsInArea&#39;,
    &#39;getRectanglesIntersection&#39;,
    &#39;roundedCorner&#39;,
    &#39;tools_convertXArgsToPX&#39;,
    &#39;tools_convertYArgsToPX&#39;,
    &#39;tools_parseKnownImageFile&#39;,
    &#39;get_Color&#39;,
    &#39;PSSMScreen.convertDimension&#39;,
    &#39;Layout.generator&#39;,
    &#39;Layout.createImgMatrix&#39;,
    &#39;Layout.createAreaMatrix&#39;,
    &#39;Layout.calculate_remainingHeight&#39;,
    &#39;Layout.calculate_remainingWidth&#39;,
    &#39;Layout.extract_rowsHeight&#39;,
    &#39;Layout.extract_colsWidth&#39;,
    &#39;Layout._dispatchClick&#39;,
    &#39;Layout._dispatchClick_LINEAR&#39;,
    &#39;Layout._dispatchClick_DICHOTOMY_colsOnly&#39;,
    &#39;Layout._dispatchClick_DICHOTOMY_Full_ToBeFixed&#39;
]
for f in ignoreList:
    __pdoc__[f] = False</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="Python-Screen-Stack-Manager.pssm.Button"><code class="flex name class">
<span>class <span class="ident">Button</span></span>
<span>(</span><span>text='', font='default', font_size='H*0.036', background_color='white', outline_color='black', radius=0, font_color='black', text_xPosition='center', text_yPosition='center', wrap_textOverflow=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Basically a rectangle (or rounded rectangle) with text printed on it</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>text</code></strong> :&ensp;<code>str</code></dt>
<dd>The main text to be written on it</dd>
<dt><strong><code>font</code></strong> :&ensp;<code>str</code></dt>
<dd>Path to a font file (ttf file), or one of PSSM built-in
fonts (e.g. "Merriweather-Bold", "default", "Merriweather-Regular",
&hellip;) (see the font folder for the complete list)</dd>
<dt><strong><code>font_size</code></strong> :&ensp;<code>int</code></dt>
<dd>The font size</dd>
<dt><strong><code>font_color</code></strong> :&ensp;<code>str</code></dt>
<dd>The color of the font : "white", "black", "gray0" to
"gray15" or a (red, green, blue, transparency) tuple</dd>
<dt><strong><code>wrap_textOverflow</code></strong> :&ensp;<code>bool</code></dt>
<dd>(True by default) Wrap text in order to avoid</dd>
<dt>it overflowing. The cuts are made between words.</dt>
<dt><strong><code>text_xPosition</code></strong> :&ensp;<code>str</code> or <code>int</code></dt>
<dd>can be left, center, right, or an integer
value, or a pssm string dimension</dd>
<dt><strong><code>text_yPosition</code></strong> :&ensp;<code>str</code> or <code>int</code></dt>
<dd>can be left, center, right, or an integer
value, or a pssm string dimension</dd>
<dt><strong><code>background_color</code></strong> :&ensp;<code>str</code></dt>
<dd>The background color</dd>
<dt><strong><code>outline_color</code></strong> :&ensp;<code>str</code></dt>
<dd>The border color</dd>
<dt><strong><code>radius</code></strong> :&ensp;<code>int</code></dt>
<dd>If not 0, then add rounded corners of this radius</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Button(Element):
    &#34;&#34;&#34;
    Basically a rectangle (or rounded rectangle) with text printed on it
    Args:
        text (str): The main text to be written on it
        font (str): Path to a font file (ttf file), or one of PSSM built-in
            fonts (e.g. &#34;Merriweather-Bold&#34;, &#34;default&#34;, &#34;Merriweather-Regular&#34;,
            ...) (see the font folder for the complete list)
        font_size (int): The font size
        font_color (str): The color of the font : &#34;white&#34;, &#34;black&#34;, &#34;gray0&#34; to
            &#34;gray15&#34; or a (red, green, blue, transparency) tuple
        wrap_textOverflow (bool): (True by default) Wrap text in order to avoid
         it overflowing. The cuts are made between words.
        text_xPosition (str or int): can be left, center, right, or an integer
            value, or a pssm string dimension
        text_yPosition (str or int): can be left, center, right, or an integer
            value, or a pssm string dimension
        background_color (str): The background color
        outline_color (str): The border color
        radius (int): If not 0, then add rounded corners of this radius
    &#34;&#34;&#34;
    def __init__(self, text=&#34;&#34;, font=DEFAULT_FONT, font_size=DEFAULT_FONT_SIZE,
                 background_color=&#34;white&#34;, outline_color=&#34;black&#34;, radius=0,
                 font_color=&#34;black&#34;, text_xPosition=&#34;center&#34;,
                 text_yPosition=&#34;center&#34;, wrap_textOverflow=True, **kwargs):
        super().__init__()
        self.background_color = background_color
        self.outline_color = outline_color
        self.text = text
        self.font = tools_parseKnownFonts(font)
        self.font_size = font_size
        self.radius = radius
        self.font_color = font_color
        self.text_xPosition = text_xPosition
        self.text_yPosition = text_yPosition
        self.wrap_textOverflow = wrap_textOverflow
        for param in kwargs:
            setattr(self, param, kwargs[param])
        self.loaded_font = None
        self.convertedText = None
        self.imgDraw = None

    def generator(self, area=None):
        if area is None:
            area = self.area
        [(x, y), (w, h)] = area
        self.area = area
        if not isinstance(self.font_size, int):
            self.font_size = self.convertDimension(self.font_size)
            if not isinstance(self.font_size, int):
                # That&#39;s a question mark dimension, or an invalid dimension.
                # Rollback to default font size
                self.font_size = self.convertDimension(DEFAULT_FONT_SIZE)
        loaded_font = ImageFont.truetype(self.font, self.font_size)
        self.loaded_font = loaded_font
        if self.radius &gt; 0:
            rect = RectangleRounded(
                radius=self.radius,
                background_color=self.background_color,
                outline_color=self.outline_color,
                parentPSSMScreen=self.parentPSSMScreen
            )
        else:
            rect = Rectangle(
                background_color=self.background_color,
                outline_color=self.outline_color,
                parentPSSMScreen=self.parentPSSMScreen
            )
        rect_img = rect.generator(self.area)
        imgDraw = ImageDraw.Draw(rect_img, self.parentPSSMScreen.colorType)
        self.imgDraw = imgDraw
        if self.wrap_textOverflow:
            myText = self.wrapText(self.text, loaded_font, imgDraw)
        else:
            myText = self.text
        self.convertedText = myText
        text_w, text_h = imgDraw.textsize(myText, font=loaded_font)
        x = tools_convertXArgsToPX(self.text_xPosition, w, text_w, myElt=self)
        y = tools_convertYArgsToPX(self.text_yPosition, h, text_h, myElt=self)
        imgDraw.text(
            (x, y),
            myText,
            font=loaded_font,
            fill=get_Color(self.font_color, self.parentPSSMScreen.colorType)
        )
        self.imgData = rect_img
        return self.imgData

    def wrapText(self, text, loaded_font, imgDraw):
        def get_text_width(text):
            return imgDraw.textsize(text=text, font=loaded_font)[0]

        [(x, y), (max_width, h)] = self.area
        text_lines = [
            &#39; &#39;.join([w.strip() for w in line.split(&#39; &#39;) if w])
            for line in text.split(&#39;\n&#39;)
            if line
        ]
        space_width = get_text_width(&#34; &#34;)
        wrapped_lines = []
        buf = []
        buf_width = 0

        for line in text_lines:
            for word in line.split(&#39; &#39;):
                word_width = get_text_width(word)

                expected_width = word_width if not buf else \
                    buf_width + space_width + word_width

                if expected_width &lt;= max_width:
                    # word fits in line
                    buf_width = expected_width
                    buf.append(word)
                else:
                    # word doesn&#39;t fit in line
                    wrapped_lines.append(&#39; &#39;.join(buf))
                    buf = [word]
                    buf_width = word_width
            if buf:
                wrapped_lines.append(&#39; &#39;.join(buf))
                buf = []
                buf_width = 0
        return &#39;\n&#39;.join(wrapped_lines)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="Python-Screen-Stack-Manager.pssm.Element" href="#Python-Screen-Stack-Manager.pssm.Element">Element</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="Python-Screen-Stack-Manager.pssm.Input" href="#Python-Screen-Stack-Manager.pssm.Input">Input</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="Python-Screen-Stack-Manager.pssm.Button.wrapText"><code class="name flex">
<span>def <span class="ident">wrapText</span></span>(<span>self, text, loaded_font, imgDraw)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def wrapText(self, text, loaded_font, imgDraw):
    def get_text_width(text):
        return imgDraw.textsize(text=text, font=loaded_font)[0]

    [(x, y), (max_width, h)] = self.area
    text_lines = [
        &#39; &#39;.join([w.strip() for w in line.split(&#39; &#39;) if w])
        for line in text.split(&#39;\n&#39;)
        if line
    ]
    space_width = get_text_width(&#34; &#34;)
    wrapped_lines = []
    buf = []
    buf_width = 0

    for line in text_lines:
        for word in line.split(&#39; &#39;):
            word_width = get_text_width(word)

            expected_width = word_width if not buf else \
                buf_width + space_width + word_width

            if expected_width &lt;= max_width:
                # word fits in line
                buf_width = expected_width
                buf.append(word)
            else:
                # word doesn&#39;t fit in line
                wrapped_lines.append(&#39; &#39;.join(buf))
                buf = [word]
                buf_width = word_width
        if buf:
            wrapped_lines.append(&#39; &#39;.join(buf))
            buf = []
            buf_width = 0
    return &#39;\n&#39;.join(wrapped_lines)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="Python-Screen-Stack-Manager.pssm.Element" href="#Python-Screen-Stack-Manager.pssm.Element">Element</a></b></code>:
<ul class="hlist">
<li><code><a title="Python-Screen-Stack-Manager.pssm.Element.convertDimension" href="#Python-Screen-Stack-Manager.pssm.Element.convertDimension">convertDimension</a></code></li>
<li><code><a title="Python-Screen-Stack-Manager.pssm.Element.generator" href="#Python-Screen-Stack-Manager.pssm.Element.generator">generator</a></code></li>
<li><code><a title="Python-Screen-Stack-Manager.pssm.Element.pssmOnClickInside" href="#Python-Screen-Stack-Manager.pssm.Element.pssmOnClickInside">pssmOnClickInside</a></code></li>
<li><code><a title="Python-Screen-Stack-Manager.pssm.Element.update" href="#Python-Screen-Stack-Manager.pssm.Element.update">update</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="Python-Screen-Stack-Manager.pssm.ButtonList"><code class="flex name class">
<span>class <span class="ident">ButtonList</span></span>
<span>(</span><span>buttons, margins=[0, 0, 0, 0], spacing=0, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Generates a Layout with only one item per row, all the same type (buttons)
and same height and width</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>button</code></strong> :&ensp;<code>list</code></dt>
<dd>a [{"text":"my text","onclickInside":onclickInside},
someOtherDict, someOtherDict] array. Each dict will contain the
parameters of each button of the button list</dd>
<dt><strong><code>borders</code></strong> :&ensp;<code>list</code></dt>
<dd>a [top, bottom,left,right] array</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ButtonList(Layout):
    &#34;&#34;&#34;
    Generates a Layout with only one item per row, all the same type (buttons)
    and same height and width
    Args:
        button (list): a [{&#34;text&#34;:&#34;my text&#34;,&#34;onclickInside&#34;:onclickInside},
            someOtherDict, someOtherDict] array. Each dict will contain the
            parameters of each button of the button list
        borders (list): a [top, bottom,left,right] array
    &#34;&#34;&#34;
    def __init__(self, buttons, margins=[0, 0, 0, 0], spacing=0, **kwargs):
        self.buttons = buttons
        self.margins = margins
        self.spacing = spacing
        layout = self.build_layoutFromButtons()
        super().__init__(layout)
        for param in kwargs:
            setattr(self, param, kwargs[param])

    def build_layoutFromButtons(self):
        # TODO : must honor min_width,max_width etc
        [top, bottom, left, right] = self.margins
        buttonLayout = [[top-self.spacing]]
        for button in self.buttons:
            buttonElt = Button(text=button[&#39;text&#39;])
            for param in button:
                setattr(buttonElt, param, button[param])
            row_height = &#34;?&#34;
            buttonLayout.append([self.spacing])
            row = [row_height, (None, left), (buttonElt, &#34;?&#34;), (None, right)]
            buttonLayout.append(row)
        buttonLayout.append([bottom])
        return buttonLayout</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="Python-Screen-Stack-Manager.pssm.Layout" href="#Python-Screen-Stack-Manager.pssm.Layout">Layout</a></li>
<li><a title="Python-Screen-Stack-Manager.pssm.Element" href="#Python-Screen-Stack-Manager.pssm.Element">Element</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="Python-Screen-Stack-Manager.pssm.ButtonList.build_layoutFromButtons"><code class="name flex">
<span>def <span class="ident">build_layoutFromButtons</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def build_layoutFromButtons(self):
    # TODO : must honor min_width,max_width etc
    [top, bottom, left, right] = self.margins
    buttonLayout = [[top-self.spacing]]
    for button in self.buttons:
        buttonElt = Button(text=button[&#39;text&#39;])
        for param in button:
            setattr(buttonElt, param, button[param])
        row_height = &#34;?&#34;
        buttonLayout.append([self.spacing])
        row = [row_height, (None, left), (buttonElt, &#34;?&#34;), (None, right)]
        buttonLayout.append(row)
    buttonLayout.append([bottom])
    return buttonLayout</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="Python-Screen-Stack-Manager.pssm.Layout" href="#Python-Screen-Stack-Manager.pssm.Layout">Layout</a></b></code>:
<ul class="hlist">
<li><code><a title="Python-Screen-Stack-Manager.pssm.Layout.convertDimension" href="#Python-Screen-Stack-Manager.pssm.Element.convertDimension">convertDimension</a></code></li>
<li><code><a title="Python-Screen-Stack-Manager.pssm.Layout.createEltList" href="#Python-Screen-Stack-Manager.pssm.Layout.createEltList">createEltList</a></code></li>
<li><code><a title="Python-Screen-Stack-Manager.pssm.Layout.generator" href="#Python-Screen-Stack-Manager.pssm.Layout.generator">generator</a></code></li>
<li><code><a title="Python-Screen-Stack-Manager.pssm.Layout.pssmOnClickInside" href="#Python-Screen-Stack-Manager.pssm.Element.pssmOnClickInside">pssmOnClickInside</a></code></li>
<li><code><a title="Python-Screen-Stack-Manager.pssm.Layout.update" href="#Python-Screen-Stack-Manager.pssm.Element.update">update</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="Python-Screen-Stack-Manager.pssm.Element"><code class="flex name class">
<span>class <span class="ident">Element</span></span>
<span>(</span><span>area=None, imgData=None, onclickInside=&lt;function returnFalse&gt;, isInverted=False, data={}, invertOnClick=False, invertDuration=0.2, forcePrintOnTop=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Everything which is going to be displayed on the screen is an Element.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>isInverted</code></strong> :&ensp;<code>bool</code></dt>
<dd>Is the element inverted</dd>
<dt><strong><code>data</code></strong> :&ensp;<code>dict,</code> or <code>any</code></dt>
<dd>A parameter for you to store whatever you want</dd>
<dt><strong><code>area</code></strong> :&ensp;<code>list</code></dt>
<dd>a [(x, y), (w, h)] list. If used in a Layout, the layout
will take care of calculating the area.</dd>
<dt><strong><code>imgData</code></strong> :&ensp;<code>PILImage</code></dt>
<dd>the PIL image of the object (None by default, the
generator function takes care of generating one)</dd>
<dt><strong><code>onclickInside</code></strong> :&ensp;<code>function</code></dt>
<dd>A function to be executed when the user
clicks on the Element</dd>
<dt><strong><code>invertOnClick</code></strong> :&ensp;<code>bool</code></dt>
<dd>Invert the element when a click is registered ?</dd>
<dt><strong><code>invertDuration</code></strong> :&ensp;<code>int</code></dt>
<dd>Duration in seconds of the element invertion
after a click is registered (use 0 for infinite)</dd>
<dt><strong><code>forcePrintOnTop</code></strong> :&ensp;<code>bool</code></dt>
<dd>Force the element to be printed on top of the
stack, even if there is an on-screen keyboard or a popup</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Element:
    &#34;&#34;&#34;
    Everything which is going to be displayed on the screen is an Element.

    Args:
        isInverted (bool): Is the element inverted
        data (dict, or any): A parameter for you to store whatever you want
        area (list): a [(x, y), (w, h)] list. If used in a Layout, the layout
            will take care of calculating the area.
        imgData (PILImage): the PIL image of the object (None by default, the
            generator function takes care of generating one)
        onclickInside (function): A function to be executed when the user
            clicks on the Element
        invertOnClick (bool): Invert the element when a click is registered ?
        invertDuration (int): Duration in seconds of the element invertion
            after a click is registered (use 0 for infinite)
        forcePrintOnTop (bool): Force the element to be printed on top of the
            stack, even if there is an on-screen keyboard or a popup
    &#34;&#34;&#34;
    def __init__(self, area=None, imgData=None, onclickInside=returnFalse,
                 isInverted=False, data={}, invertOnClick=False,
                 invertDuration=DEFAULT_INVERT_DURATION, forcePrintOnTop=False
                 ):
        global lastUsedId
        self.id = lastUsedId
        lastUsedId += 1
        self.isLayout = False
        self.imgData = imgData
        self.area = area
        self.onclickInside = onclickInside
        self.isInverted = isInverted
        self.user_data = data
        self.invertOnClick = invertOnClick
        self.invertDuration = invertDuration
        self.forcePrintOnTop = forcePrintOnTop
        self.parentLayouts = []
        self.parentPSSMScreen = None

    def __hash__(self):
        return hash(self.id)

    def __eq__(self, other):
        if isinstance(other, self.__class__):
            return self.id == other.id
        return NotImplemented

    def update(self, newAttributes={}, skipGen=False, skipPrint=False,
               reprintOnTop=False):
        &#34;&#34;&#34;
        Pass a dict as argument, and it will update the Element&#39;s attributes
        accordingly (both its attribute and then the screen).
        Note:
            Updating an element can be very slow ! It depends on every specific
            cases, but know there are a few ways to make it faster:
            - Use `screen.startBatchWriting()` and `screen.stopBatchWriting()`
            - If you know this specific element is on top of the screen, use:
                `elt.update(newAttributes=myDict, reprintOnTop=True)`
                Which will do the same, except it won&#39;t rebuild the whole stack
                image, it will just print this object on top. (On my tests, I
                could spare up to 0.5s !)

        Args :
            newAttributes (dict): The element&#39;s new attributes
            skipGen (bool): Just update the element&#39;s attribute, but do
                not do any generation or printing
            reprintOnTop (bool): Do not reprint the whole stack, but do print
                this element on top of the screen. (much faster when possible)
            skipPrint (bool): Do not update the screen, but do regenerate.
        &#34;&#34;&#34;
        # First, we set the attributes
        for param in newAttributes:
            setattr(self, param, newAttributes[param])
        if not skipGen:
            # we recreate the pillow image of this particular object
            self.generator()
        if (not skipPrint) and (not skipGen):  # No need to update if no regen
            isBatch = self.parentPSSMScreen.isBatch
            if reprintOnTop:
                self.parentPSSMScreen.simplePrintElt(self)
            elif not isBatch:
                hasParent = len(self.parentLayouts) &gt; 0
                # We don&#39;t want unncesseray generation when printing batch
                if hasParent:
                    # We recreate the pillow image of the oldest parent
                    # And it is not needed to regenerate standard objects, since
                    oldest_parent = self.parentLayouts[0]
                    oldest_parent.generator(skipNonLayoutGen=True)
                # Then, let&#39;s reprint the stack
                self.parentPSSMScreen.printStack(area=self.area)
        return True

    def generator(self):
        &#34;&#34;&#34;
        The generator is the function which is called when the container layout
        wants to build an image. It therefore returns a pillow image.
        &#34;&#34;&#34;
        return NotImplemented

    def convertDimension(self, dimension):
        &#34;&#34;&#34;
        Converts the user dimension input (like &#34;h*0.1&#34;) to to proper integer
        amount of pixels.
        Basically, you give it a string. And it will change a few characters to
        their corresponding value, then return the evaluated string.

        Examples:
            I HIGHLY recommend doing only simple operation, like &#34;H*0.1&#34;, or
            &#34;W/10&#34;, always starting with the corresponding variable.
            But you can if you want do more complicated things:
            elt.convertDimension(&#34;H+W&#34;)
                    -&gt;  screen_height + screen_width
            elt.convertDimension(&#34;p*300+max(w, h)&#34;)
                    -&gt; 300 + max(element_width, screen_height)

        Note:
            When using question mark dimension (like &#34;?*2&#34;), the question mark
            MUST be at the beginning of the string
        &#34;&#34;&#34;
        if isinstance(dimension, int):
            return dimension
        elif isinstance(dimension, str):
            nd = &#34;&#34;
            W = self.parentPSSMScreen.width
            H = self.parentPSSMScreen.height
            if self.area:
                (x, y), (w, h) = self.area
            else:
                # area not defined. Instead of being stuck, let&#39;s assume the
                # screen height and width are a decent alternative
                w, h = W, H
            for c in dimension:
                if c == &#39;p&#39; or c == &#39;P&#39;:
                    nd += &#39;1&#39;
                elif c == &#39;W&#39;:      # screen width
                    nd += str(W)
                elif c == &#39;H&#39;:      # screen height
                    nd += str(H)
                elif c == &#39;w&#39;:      # element width
                    nd += str(w)
                elif c == &#39;h&#39;:      # element height
                    nd += str(h)
                else:           # A standard character
                    nd += c
            if dimension[0] == &#39;?&#39;:
                # We return the string, another function will take care of
                # evaluating it
                return nd
            else:
                return int(eval(nd))        # Then we can evaluate the input
        else:
            print(&#34;[PSSM] Could not parse the dimension&#34;)
            return dimension

    def pssmOnClickInside(self, coords=None):
        &#34;&#34;&#34;
        Each Element can also have a pssm function implemented on click.
        By default, it does nothing.
        &#34;&#34;&#34;
        return None</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="Python-Screen-Stack-Manager.pssm.Button" href="#Python-Screen-Stack-Manager.pssm.Button">Button</a></li>
<li><a title="Python-Screen-Stack-Manager.pssm.Icon" href="#Python-Screen-Stack-Manager.pssm.Icon">Icon</a></li>
<li><a title="Python-Screen-Stack-Manager.pssm.Layout" href="#Python-Screen-Stack-Manager.pssm.Layout">Layout</a></li>
<li><a title="Python-Screen-Stack-Manager.pssm.Line" href="#Python-Screen-Stack-Manager.pssm.Line">Line</a></li>
<li><a title="Python-Screen-Stack-Manager.pssm.Rectangle" href="#Python-Screen-Stack-Manager.pssm.Rectangle">Rectangle</a></li>
<li><a title="Python-Screen-Stack-Manager.pssm.RectangleRounded" href="#Python-Screen-Stack-Manager.pssm.RectangleRounded">RectangleRounded</a></li>
<li><a title="Python-Screen-Stack-Manager.pssm.Static" href="#Python-Screen-Stack-Manager.pssm.Static">Static</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="Python-Screen-Stack-Manager.pssm.Element.convertDimension"><code class="name flex">
<span>def <span class="ident">convertDimension</span></span>(<span>self, dimension)</span>
</code></dt>
<dd>
<div class="desc"><p>Converts the user dimension input (like "h*0.1") to to proper integer
amount of pixels.
Basically, you give it a string. And it will change a few characters to
their corresponding value, then return the evaluated string.</p>
<h2 id="examples">Examples</h2>
<p>I HIGHLY recommend doing only simple operation, like "H<em>0.1", or
"W/10", always starting with the corresponding variable.
But you can if you want do more complicated things:
elt.convertDimension("H+W")
-&gt;
screen_height + screen_width
elt.convertDimension("p</em>300+max(w, h)")
-&gt; 300 + max(element_width, screen_height)</p>
<h2 id="note">Note</h2>
<p>When using question mark dimension (like "?*2"), the question mark
MUST be at the beginning of the string</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def convertDimension(self, dimension):
    &#34;&#34;&#34;
    Converts the user dimension input (like &#34;h*0.1&#34;) to to proper integer
    amount of pixels.
    Basically, you give it a string. And it will change a few characters to
    their corresponding value, then return the evaluated string.

    Examples:
        I HIGHLY recommend doing only simple operation, like &#34;H*0.1&#34;, or
        &#34;W/10&#34;, always starting with the corresponding variable.
        But you can if you want do more complicated things:
        elt.convertDimension(&#34;H+W&#34;)
                -&gt;  screen_height + screen_width
        elt.convertDimension(&#34;p*300+max(w, h)&#34;)
                -&gt; 300 + max(element_width, screen_height)

    Note:
        When using question mark dimension (like &#34;?*2&#34;), the question mark
        MUST be at the beginning of the string
    &#34;&#34;&#34;
    if isinstance(dimension, int):
        return dimension
    elif isinstance(dimension, str):
        nd = &#34;&#34;
        W = self.parentPSSMScreen.width
        H = self.parentPSSMScreen.height
        if self.area:
            (x, y), (w, h) = self.area
        else:
            # area not defined. Instead of being stuck, let&#39;s assume the
            # screen height and width are a decent alternative
            w, h = W, H
        for c in dimension:
            if c == &#39;p&#39; or c == &#39;P&#39;:
                nd += &#39;1&#39;
            elif c == &#39;W&#39;:      # screen width
                nd += str(W)
            elif c == &#39;H&#39;:      # screen height
                nd += str(H)
            elif c == &#39;w&#39;:      # element width
                nd += str(w)
            elif c == &#39;h&#39;:      # element height
                nd += str(h)
            else:           # A standard character
                nd += c
        if dimension[0] == &#39;?&#39;:
            # We return the string, another function will take care of
            # evaluating it
            return nd
        else:
            return int(eval(nd))        # Then we can evaluate the input
    else:
        print(&#34;[PSSM] Could not parse the dimension&#34;)
        return dimension</code></pre>
</details>
</dd>
<dt id="Python-Screen-Stack-Manager.pssm.Element.generator"><code class="name flex">
<span>def <span class="ident">generator</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>The generator is the function which is called when the container layout
wants to build an image. It therefore returns a pillow image.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generator(self):
    &#34;&#34;&#34;
    The generator is the function which is called when the container layout
    wants to build an image. It therefore returns a pillow image.
    &#34;&#34;&#34;
    return NotImplemented</code></pre>
</details>
</dd>
<dt id="Python-Screen-Stack-Manager.pssm.Element.pssmOnClickInside"><code class="name flex">
<span>def <span class="ident">pssmOnClickInside</span></span>(<span>self, coords=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Each Element can also have a pssm function implemented on click.
By default, it does nothing.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pssmOnClickInside(self, coords=None):
    &#34;&#34;&#34;
    Each Element can also have a pssm function implemented on click.
    By default, it does nothing.
    &#34;&#34;&#34;
    return None</code></pre>
</details>
</dd>
<dt id="Python-Screen-Stack-Manager.pssm.Element.update"><code class="name flex">
<span>def <span class="ident">update</span></span>(<span>self, newAttributes={}, skipGen=False, skipPrint=False, reprintOnTop=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Pass a dict as argument, and it will update the Element's attributes
accordingly (both its attribute and then the screen).</p>
<h2 id="note">Note</h2>
<p>Updating an element can be very slow ! It depends on every specific
cases, but know there are a few ways to make it faster:
- Use <code>screen.startBatchWriting()</code> and <code>screen.stopBatchWriting()</code>
- If you know this specific element is on top of the screen, use:
<code>elt.update(newAttributes=myDict, reprintOnTop=True)</code>
Which will do the same, except it won't rebuild the whole stack
image, it will just print this object on top. (On my tests, I
could spare up to 0.5s !)</p>
<p>Args :
newAttributes (dict): The element's new attributes
skipGen (bool): Just update the element's attribute, but do
not do any generation or printing
reprintOnTop (bool): Do not reprint the whole stack, but do print
this element on top of the screen. (much faster when possible)
skipPrint (bool): Do not update the screen, but do regenerate.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update(self, newAttributes={}, skipGen=False, skipPrint=False,
           reprintOnTop=False):
    &#34;&#34;&#34;
    Pass a dict as argument, and it will update the Element&#39;s attributes
    accordingly (both its attribute and then the screen).
    Note:
        Updating an element can be very slow ! It depends on every specific
        cases, but know there are a few ways to make it faster:
        - Use `screen.startBatchWriting()` and `screen.stopBatchWriting()`
        - If you know this specific element is on top of the screen, use:
            `elt.update(newAttributes=myDict, reprintOnTop=True)`
            Which will do the same, except it won&#39;t rebuild the whole stack
            image, it will just print this object on top. (On my tests, I
            could spare up to 0.5s !)

    Args :
        newAttributes (dict): The element&#39;s new attributes
        skipGen (bool): Just update the element&#39;s attribute, but do
            not do any generation or printing
        reprintOnTop (bool): Do not reprint the whole stack, but do print
            this element on top of the screen. (much faster when possible)
        skipPrint (bool): Do not update the screen, but do regenerate.
    &#34;&#34;&#34;
    # First, we set the attributes
    for param in newAttributes:
        setattr(self, param, newAttributes[param])
    if not skipGen:
        # we recreate the pillow image of this particular object
        self.generator()
    if (not skipPrint) and (not skipGen):  # No need to update if no regen
        isBatch = self.parentPSSMScreen.isBatch
        if reprintOnTop:
            self.parentPSSMScreen.simplePrintElt(self)
        elif not isBatch:
            hasParent = len(self.parentLayouts) &gt; 0
            # We don&#39;t want unncesseray generation when printing batch
            if hasParent:
                # We recreate the pillow image of the oldest parent
                # And it is not needed to regenerate standard objects, since
                oldest_parent = self.parentLayouts[0]
                oldest_parent.generator(skipNonLayoutGen=True)
            # Then, let&#39;s reprint the stack
            self.parentPSSMScreen.printStack(area=self.area)
    return True</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="Python-Screen-Stack-Manager.pssm.Icon"><code class="flex name class">
<span>class <span class="ident">Icon</span></span>
<span>(</span><span>file, centered=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>An icon, built from an image</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>file</code></strong> :&ensp;<code>str</code></dt>
<dd>Path to a file, or one of the integrated image (see the
icon folder for the name of each image). 'reboot' for instance
points to the integrated reboot image.</dd>
<dt><strong><code>centered</code></strong> :&ensp;<code>bool</code></dt>
<dd>Center the icon?</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Icon(Element):
    &#34;&#34;&#34;
    An icon, built from an image
    Args:
        file (str): Path to a file, or one of the integrated image (see the
            icon folder for the name of each image). &#39;reboot&#39; for instance
            points to the integrated reboot image.
        centered (bool): Center the icon?
    &#34;&#34;&#34;
    def __init__(self, file, centered=True, **kwargs):
        super().__init__()
        self.file = file
        self.centered = centered
        self.path_to_file = tools_parseKnownImageFile(self.file)
        for param in kwargs:
            setattr(self, param, kwargs[param])

    def generator(self, area):
        self.area = area
        [(x, y), (w, h)] = area
        colorType = self.parentPSSMScreen.colorType
        icon_size = min(area[1][0], area[1][1])
        loadedImg = Image.open(self.path_to_file)
        convImg = loadedImg.convert(colorType)
        iconImg = convImg.resize((icon_size, icon_size))
        if not self.centered:
            self.imgData = iconImg
            return iconImg
        else:
            img = Image.new(
                colorType,
                (w+1, h+1),
                color=get_Color(&#34;white&#34;, colorType)
            )
            x = int(0.5*w-0.5*icon_size)
            y = int(0.5*h-0.5*icon_size)
            img.paste(iconImg, (x, y))
            self.imgData = img
            return img</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="Python-Screen-Stack-Manager.pssm.Element" href="#Python-Screen-Stack-Manager.pssm.Element">Element</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="Python-Screen-Stack-Manager.pssm.Element" href="#Python-Screen-Stack-Manager.pssm.Element">Element</a></b></code>:
<ul class="hlist">
<li><code><a title="Python-Screen-Stack-Manager.pssm.Element.convertDimension" href="#Python-Screen-Stack-Manager.pssm.Element.convertDimension">convertDimension</a></code></li>
<li><code><a title="Python-Screen-Stack-Manager.pssm.Element.generator" href="#Python-Screen-Stack-Manager.pssm.Element.generator">generator</a></code></li>
<li><code><a title="Python-Screen-Stack-Manager.pssm.Element.pssmOnClickInside" href="#Python-Screen-Stack-Manager.pssm.Element.pssmOnClickInside">pssmOnClickInside</a></code></li>
<li><code><a title="Python-Screen-Stack-Manager.pssm.Element.update" href="#Python-Screen-Stack-Manager.pssm.Element.update">update</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="Python-Screen-Stack-Manager.pssm.Input"><code class="flex name class">
<span>class <span class="ident">Input</span></span>
<span>(</span><span>isMultiline=True, onReturn=&lt;function returnFalse&gt;, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Basically a button, except when you click on it, it displays the keyboard.
It handles typing things for you. so when you click on this element, the
keyboard shows up, and you can start typing.
The main thing it does is that it is able to detect between which
characters the user typed to be able to insert a character between two
others (and that was no easy task)
It has a method to retrieve what was typed :
Input.getInput()</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>isMultiline</code></strong> :&ensp;<code>bool</code></dt>
<dd>Allow carriage return</dd>
<dt><strong><code>onReturn</code></strong> :&ensp;<code>function</code></dt>
<dd>Function to be executed on carriage return</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Input(Button):
    &#34;&#34;&#34;
    Basically a button, except when you click on it, it displays the keyboard.
    It handles typing things for you. so when you click on this element, the
    keyboard shows up, and you can start typing.
    The main thing it does is that it is able to detect between which
    characters the user typed to be able to insert a character between two
    others (and that was no easy task)
    It has a method to retrieve what was typed :
    Input.getInput()
    Args:
        isMultiline (bool): Allow carriage return
        onReturn (function): Function to be executed on carriage return
    &#34;&#34;&#34;
    def __init__(self, isMultiline=True, onReturn=returnFalse, **kwargs):
        super().__init__()
        self.hideCursorWhenLast = True
        self.isMultiline = isMultiline
        self.onReturn = onReturn
        self.allowSetCursorPos = False
        self.isOnTop = True  # Let&#39;s assume an input elt is always on top
        for param in kwargs:
            setattr(self, param, kwargs[param])
        if &#39;font&#39; in kwargs:
            self.font = tools_parseKnownFonts(kwargs[&#34;font&#34;])
        self.cursorPosition = len(self.text)
        self.typedText = self.text[:]
        self.text = self.typedText

    def getInput(self):
        &#34;&#34;&#34;
        Returns the text currently written on the Input box.
        &#34;&#34;&#34;
        return self.typedText

    def pssmOnClickInside(self, coords):
        if not self.parentPSSMScreen.osk:
            print(
                &#34;[PSSM] Keyboard not initialized, Input element cannot be &#34; +
                &#34;properly handled&#34;
            )
            return None
        # Set the callback function to our own
        self.parentPSSMScreen.osk.onKeyPress = self.onKeyPress
        if not self.parentPSSMScreen.isOSKShown:
            # Let&#39;s print the on screen keyboard as it is not already here
            self.parentPSSMScreen.OSKShow()
        elif self.allowSetCursorPos:
            cx, cy = coords
            [(sx, sy), (w, h)] = self.area
            loaded_font = self.loaded_font
            myText = self.convertedText
            imgDraw = self.imgDraw
            text_w, text_h = imgDraw.textsize(myText, font=loaded_font)
            x = tools_convertXArgsToPX(self.text_xPosition, w, text_w,
                                       myElt=self)
            y = tools_convertYArgsToPX(self.text_yPosition, h, text_h,
                                       myElt=self)
            # Then let&#39;s linear search
            wasFound = False
            olines = myText[:].split(&#34;\n&#34;)
            if len(olines) &gt; 0:
                lines = [olines[0]]
            else:
                lines = []
            for i in range(len(olines)):
                lines.append(&#34;\n&#34;)
            linesBefore = &#34;&#34;
            for i in range(len(lines)):
                tw1, th1 = imgDraw.textsize(linesBefore, font=loaded_font)
                linesBefore += lines[i]
                tw2, th2 = imgDraw.textsize(linesBefore, font=loaded_font)
                b_correct_y = cy &gt; sy + x + th1 and cy &lt;= sy + y + th2
                if b_correct_y:
                    for j in range(len(linesBefore)):
                        tw1, th1 = imgDraw.textsize(linesBefore[:j],
                                                    font=loaded_font)
                        tw2, th2 = imgDraw.textsize(linesBefore[:j+1],
                                                    font=loaded_font)
                        b_correct_x = cx &gt; sx + x + tw1 and cx &lt;= sx + x + tw2
                        if b_correct_x:
                            pos = j
                            for line in lines[:i]:
                                pos += len(line)
                            self.setCursorPosition(pos+1)
                            wasFound = True
                    if not wasFound:    # Let&#39;s put it at the end of the row
                        pos = 0
                        for line in lines[:i+1]:
                            pos += len(line)
                        self.setCursorPosition(pos)
                        wasFound = True
            if not wasFound:
                self.setCursorPosition(None)
            pass

    def onKeyPress(self, keyType, keyChar):
        &#34;&#34;&#34;
        Handles each key press.
        By default, it will re-display the input element on each keypress ON
        TOP OF THE SCREEN (not honoring stack position). This allow for a 30%
        speed increase on my basic test. You can change this behaviour by
        setting `InputElt.isOnTop = False`
        &#34;&#34;&#34;
        c = self.cursorPosition
        if keyType == KTstandardChar:
            self.typedText = insertStr(self.typedText, keyChar, c)
            self.setCursorPosition(self.cursorPosition+1, skipPrint=True)
        elif keyType == KTcarriageReturn:
            if self.isMultiline:
                self.typedText = insertStr(self.typedText, &#34;\n&#34;, c)
                self.setCursorPosition(self.cursorPosition+1, skipPrint=True)
            else:
                self.onReturn()
        elif keyType == KTbackspace:
            self.typedText = self.typedText[:c-1] + self.typedText[c:]
            self.setCursorPosition(self.cursorPosition-1, skipPrint=True)
        if self.hideCursorWhenLast:
            if self.cursorPosition &gt;= len(self.typedText):
                # Don&#39;t display the cursor when it is at the last position
                self.text = self.typedText[:]
        else:
            self.text = insertStr(self.typedText, CURSOR_CHAR,
                                  self.cursorPosition)
        if self.isOnTop:
            self.update(reprintOnTop=True)
        else:
            self.update()

    def setCursorPosition(self, pos, skipPrint=False):
        if pos is None:
            pos = len(self.typedText)
        self.cursorPosition = pos
        self.text = insertStr(self.typedText, CURSOR_CHAR, self.cursorPosition)
        if not skipPrint:
            self.update()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="Python-Screen-Stack-Manager.pssm.Button" href="#Python-Screen-Stack-Manager.pssm.Button">Button</a></li>
<li><a title="Python-Screen-Stack-Manager.pssm.Element" href="#Python-Screen-Stack-Manager.pssm.Element">Element</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="Python-Screen-Stack-Manager.pssm.Input.getInput"><code class="name flex">
<span>def <span class="ident">getInput</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the text currently written on the Input box.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getInput(self):
    &#34;&#34;&#34;
    Returns the text currently written on the Input box.
    &#34;&#34;&#34;
    return self.typedText</code></pre>
</details>
</dd>
<dt id="Python-Screen-Stack-Manager.pssm.Input.onKeyPress"><code class="name flex">
<span>def <span class="ident">onKeyPress</span></span>(<span>self, keyType, keyChar)</span>
</code></dt>
<dd>
<div class="desc"><p>Handles each key press.
By default, it will re-display the input element on each keypress ON
TOP OF THE SCREEN (not honoring stack position). This allow for a 30%
speed increase on my basic test. You can change this behaviour by
setting <code>InputElt.isOnTop = False</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def onKeyPress(self, keyType, keyChar):
    &#34;&#34;&#34;
    Handles each key press.
    By default, it will re-display the input element on each keypress ON
    TOP OF THE SCREEN (not honoring stack position). This allow for a 30%
    speed increase on my basic test. You can change this behaviour by
    setting `InputElt.isOnTop = False`
    &#34;&#34;&#34;
    c = self.cursorPosition
    if keyType == KTstandardChar:
        self.typedText = insertStr(self.typedText, keyChar, c)
        self.setCursorPosition(self.cursorPosition+1, skipPrint=True)
    elif keyType == KTcarriageReturn:
        if self.isMultiline:
            self.typedText = insertStr(self.typedText, &#34;\n&#34;, c)
            self.setCursorPosition(self.cursorPosition+1, skipPrint=True)
        else:
            self.onReturn()
    elif keyType == KTbackspace:
        self.typedText = self.typedText[:c-1] + self.typedText[c:]
        self.setCursorPosition(self.cursorPosition-1, skipPrint=True)
    if self.hideCursorWhenLast:
        if self.cursorPosition &gt;= len(self.typedText):
            # Don&#39;t display the cursor when it is at the last position
            self.text = self.typedText[:]
    else:
        self.text = insertStr(self.typedText, CURSOR_CHAR,
                              self.cursorPosition)
    if self.isOnTop:
        self.update(reprintOnTop=True)
    else:
        self.update()</code></pre>
</details>
</dd>
<dt id="Python-Screen-Stack-Manager.pssm.Input.setCursorPosition"><code class="name flex">
<span>def <span class="ident">setCursorPosition</span></span>(<span>self, pos, skipPrint=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setCursorPosition(self, pos, skipPrint=False):
    if pos is None:
        pos = len(self.typedText)
    self.cursorPosition = pos
    self.text = insertStr(self.typedText, CURSOR_CHAR, self.cursorPosition)
    if not skipPrint:
        self.update()</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="Python-Screen-Stack-Manager.pssm.Button" href="#Python-Screen-Stack-Manager.pssm.Button">Button</a></b></code>:
<ul class="hlist">
<li><code><a title="Python-Screen-Stack-Manager.pssm.Button.convertDimension" href="#Python-Screen-Stack-Manager.pssm.Element.convertDimension">convertDimension</a></code></li>
<li><code><a title="Python-Screen-Stack-Manager.pssm.Button.generator" href="#Python-Screen-Stack-Manager.pssm.Element.generator">generator</a></code></li>
<li><code><a title="Python-Screen-Stack-Manager.pssm.Button.pssmOnClickInside" href="#Python-Screen-Stack-Manager.pssm.Element.pssmOnClickInside">pssmOnClickInside</a></code></li>
<li><code><a title="Python-Screen-Stack-Manager.pssm.Button.update" href="#Python-Screen-Stack-Manager.pssm.Element.update">update</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="Python-Screen-Stack-Manager.pssm.Layout"><code class="flex name class">
<span>class <span class="ident">Layout</span></span>
<span>(</span><span>layout, area=None, background_color='white', **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>A layout is a quite general kind of Element :
If must be given the working area, and a layout, and will generate every
element of the layout</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>layout</code></strong> :&ensp;<code>list</code></dt>
<dd>The given layout (see example below). It is basically a</dd>
<dt>list of rows. Each row is a list containing : the height of the row,</dt>
<dt>then as many tuples as you want, each tuple being a</dt>
<dt>(pssm.Element, width) instance</dt>
<dt><strong><code>background_color</code></strong></dt>
<dd>&nbsp;</dd>
<dt><strong><code>area</code></strong></dt>
<dd>&nbsp;</dd>
</dl>
<p>&hellip; all other arguments from the pssm.Element class
Example of usage:
See <a href="examples/index.html">examples</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Layout(Element):
    &#34;&#34;&#34;
    A layout is a quite general kind of Element :
    If must be given the working area, and a layout, and will generate every
    element of the layout

    Args:
        layout (list): The given layout (see example below). It is basically a
        list of rows. Each row is a list containing : the height of the row,
        then as many tuples as you want, each tuple being a
        (pssm.Element, width) instance
        background_color
        area
        ... all other arguments from the pssm.Element class

    Example of usage:
        See [examples](examples/index.html)
    &#34;&#34;&#34;
    def __init__(self, layout, area=None, background_color=&#34;white&#34;, **kwargs):
        super().__init__()
        self.area = area
        self.layout = layout
        self.isValid = self.isLayoutValid()
        self.background_color = background_color
        self.areaMatrix = None
        self.imgMatrix = None
        self.borders = None
        self.isLayout = True
        for param in kwargs:
            setattr(self, param, kwargs[param])

    def isLayoutValid(self):
        # TODO : to be tested
        layout = self.layout
        if not isinstance(layout, list):
            raise Exception(&#34;Layout Element is supposed to be a list&#34;)
        for row in layout:
            if not isinstance(row, list):
                raise Exception(&#34;A layout row is supposed to be a list&#34;)
            elif len(row) == 0:
                raise Exception(&#34;A layout row cannot be empty&#34;)
            elif not isinstance(row[0], str) and not isinstance(row[0], int):
                raise Exception(
                    &#34;The first element of a row (its height) should be a &#34; +
                    &#34;string or an integer&#34;
                )
            for j in range(1, len(row)):
                eltTuple = row[j]
                isTuple = isinstance(eltTuple, tuple)
                isList = isinstance(eltTuple, list)
                if not (isTuple or isList):
                    raise Exception(
                        &#34;A layout row should be a list of Tuple &#34; +
                        &#34;(except for its first element)&#34;
                    )
                if len(eltTuple) != 2:
                    raise Exception(
                        &#34;A layout element should be a Tuple : &#34; +
                        &#34;(Element, elementWidth)&#34;
                    )
                isStr = isinstance(eltTuple[1], str)
                isInt = isinstance(eltTuple[1], int)
                if not (isInt or isStr):
                    raise Exception(
                        &#34;An element width should be a string or an integer&#34;
                    )
                isElement = isinstance(eltTuple[0], Element)
                if not (isElement or eltTuple[0] is None):
                    raise Exception(
                        &#34;A layout element should be a Tuple : &#34; +
                        &#34;(Element, elementWidth), with Element designating &#34; +
                        &#34; a PSSM Element&#34;
                    )
        return True

    def generator(self, area=None, skipNonLayoutGen=False):
        &#34;&#34;&#34;
        Builds one img out of all the Elements it is being given
        &#34;&#34;&#34;
        if area is not None:
            self.area = area
        self.createAreaMatrix()
        self.createImgMatrix(skipNonLayoutGen=skipNonLayoutGen)
        [(x, y), (w, h)] = self.area
        colorType = self.parentPSSMScreen.colorType
        color = get_Color(self.background_color, colorType)
        placeholder = Image.new(colorType, (w, h), color=color)
        for i in range(len(self.areaMatrix)):
            for j in range(len(self.areaMatrix[i])):
                [(elt_x, elt_y), (elt_w, elt_h)] = self.areaMatrix[i][j]
                relative_x = elt_x - x
                relative_y = elt_y - y
                elt_img = self.imgMatrix[i][j]
                if elt_img is not None:
                    pos = (relative_x, relative_y)
                    placeholder.paste(self.imgMatrix[i][j], pos)
        self.imgData = placeholder
        return self.imgData

    def createImgMatrix(self, skipNonLayoutGen=False):
        matrix = []
        if not self.areaMatrix:
            print(&#34;[PSSM Layout] Error, areaMatrix has to be defined first&#34;)
            return None
        for i in range(len(self.layout)):
            row = []
            for j in range(1, len(self.layout[i])):
                elt, _ = self.layout[i][j]
                if elt is None:
                    elt_area = self.areaMatrix[i][j-1]
                    elt_img = None
                else:
                    elt_area = self.areaMatrix[i][j-1]
                    if not elt.isLayout and skipNonLayoutGen:
                        elt_img = elt.imgData
                    else:
                        elt_img = elt.generator(area=elt_area)
                row.append(elt_img)
            matrix.append(row)
        self.imgMatrix = matrix

    def createAreaMatrix(self):
        # TODO : must honor min and max
        matrix = []
        n_rows = len(self.layout)
        [(x, y), (w, h)] = self.area[:]
        x0, y0 = x, y
        for i in range(n_rows):     # Lets loop through the rows
            row = self.layout[i]
            row_cols = []           # All the columns of this particular row
            row_height = row[0]
            converted_height = self.convertDimension(row_height)
            if isinstance(converted_height, int):
                true_row_height = converted_height
            else:
                remaining_height = self.calculate_remainingHeight()
                dim = str(remaining_height) + converted_height[1:]
                true_row_height = int(eval(dim))
            for j in range(1, len(row)):
                (element, element_width) = row[j]
                converted_width = self.convertDimension(element_width)
                if element is not None:
                    for parent in self.parentLayouts:
                        self.layout[i][j][0].parentLayouts.append(parent)
                    self.layout[i][j][0].parentLayouts.append(self)
                    self.layout[i][j][0].parentPSSMScreen = \
                        self.parentPSSMScreen
                if isinstance(converted_width, int):
                    true_elt_width = converted_width
                else:
                    remaining_width = self.calculate_remainingWidth(i)
                    dim = str(remaining_width) + converted_width[1:]
                    true_elt_width = int(eval(dim))
                    self.layout[i][j] = (self.layout[i][j][0], true_elt_width)
                element_area = [(x0, y0), (true_elt_width, true_row_height)]
                x0 += true_elt_width
                row_cols.append(element_area)
            y0 += true_row_height
            x0 = x
            matrix.append(row_cols)
        self.areaMatrix = matrix

    def createEltList(self):
        &#34;&#34;&#34;
        Returns a list of all the elements the Layout Element contains
        &#34;&#34;&#34;
        eltList = []
        for row in self.layout:
            for i in range(1, len(row)):
                elt, _ = row[i]
                if elt is not None:
                    eltList.append(elt)
        return eltList

    def calculate_remainingHeight(self):
        rows = self.extract_rowsHeight()
        total_questionMarks_weight = 0
        total_height = 0
        for dimension in rows:
            converted_dimension = self.convertDimension(dimension)
            if isinstance(converted_dimension, int):
                total_height += converted_dimension
            else:
                weight = eval(&#34;1&#34; + converted_dimension[1:])
                total_questionMarks_weight += weight
        layout_height = self.area[1][1]
        return int((layout_height - total_height)/total_questionMarks_weight)

    def calculate_remainingWidth(self, rowIndex):
        cols = self.extract_colsWidth(rowIndex)
        total_width = 0
        total_questionMarks_weight = 0
        for dimension in cols:
            converted_dimension = self.convertDimension(dimension)
            if isinstance(converted_dimension, int):
                total_width += converted_dimension
            else:
                weight = eval(&#34;1&#34; + converted_dimension[1:])
                total_questionMarks_weight += weight
        layout_width = self.area[1][0]
        return int((layout_width - total_width)/total_questionMarks_weight)

    def extract_rowsHeight(self):
        rows = []
        for row in self.layout:
            rows.append(row[0])
        return rows

    def extract_colsWidth(self, rowIndex):
        cols = []
        for col in self.layout[rowIndex]:
            if isinstance(col, tuple):
                cols.append(col[1])
        return cols

    def _dispatchClick(self, coords):
        &#34;&#34;&#34;
        Finds the element on which the user clicked
        &#34;&#34;&#34;
        self._dispatchClick_LINEAR(coords)

    def _dispatchClick_LINEAR(self, coords):
        &#34;&#34;&#34;
        Linear search throuh both the rows and the columns
        &#34;&#34;&#34;
        click_x, click_y = coords
        # Linear search though the rows
        for i in range(len(self.areaMatrix)):
            if len(self.areaMatrix[i]) == 0:
                # That&#39;s a fake row (a margin row)
                continue
            first_row_elt = self.areaMatrix[i][0]
            last_row_elt = self.areaMatrix[i][-1]
            x = first_row_elt[0][0]
            y = first_row_elt[0][1]
            w = last_row_elt[0][0] + last_row_elt[1][0] - first_row_elt[0][0]
            h = last_row_elt[0][1] + last_row_elt[1][1] - first_row_elt[0][1]
            if coordsInArea(click_x, click_y, [(x, y), (w, h)]):
                # CLick was in that row
                for j in range(len(self.areaMatrix[i])):
                    # Linear search through the columns
                    if coordsInArea(click_x, click_y, self.areaMatrix[i][j]):
                        # Click was on that element
                        elt, _ = self.layout[i][j+1]
                        if elt is not None and elt.onclickInside is not None:
                            self.parentPSSMScreen._dispatchClickToElt(
                                coords, elt
                            )
                        return True
        return False

    def _dispatchClick_DICHOTOMY_colsOnly(self, coords):
        &#34;&#34;&#34;
        Linear search through the rows, dichotomy for the columns
        (Because of the empty rows, a dichotomy for the rows doesn&#39;t work)
        NEEDS TO BE FIXED TOO (example : two buttons in a row)
        &#34;&#34;&#34;
        click_x, click_y = coords
        row_A = -1
        for i in range(len(self.areaMatrix)):
            # Linear search though the rows
            if len(self.areaMatrix[i]) == 0:
                # That&#39;s a fake row (a margin row)
                continue
            first_row_elt = self.areaMatrix[i][0]
            last_row_elt = self.areaMatrix[i][-1]
            x = first_row_elt[0][0]
            y = first_row_elt[0][1]
            w = last_row_elt[0][0] + last_row_elt[1][0] - first_row_elt[0][0]
            h = last_row_elt[0][1] + last_row_elt[1][1] - first_row_elt[0][1]
            if coordsInArea(click_x, click_y, [(x, y), (w, h)]):
                # CLick was in that row
                row_A = i
                break
        if row_A == -1:
            return None
        col_A = 0
        col_C = max(len(self.areaMatrix[row_A]) - 1, 0)
        xA = self.areaMatrix[row_A][col_A][0][0]
        xC = self.areaMatrix[row_A][col_C][0][0]
        if click_x &lt; xA:
            return None
        if click_x &gt; xC + self.areaMatrix[row_A][col_C][1][0]:
            return None
        while col_C &gt; col_A + 1:
            col_B = int(0.5*(col_A+col_C))      # The average of the two
            xB = self.areaMatrix[row_A][col_B][0][0]
            if click_x &gt;= xB or col_B == col_C:
                col_A = col_B
                xA = xB
            else:
                col_C = col_B
                xC = xB
        # Element is at indexes row_A, col_A
        elt, _ = self.layout[row_A][col_A+1]
        if elt is not None and elt.onclickInside is not None:
            self.parentPSSMScreen._dispatchClickToElt(coords, elt)
        return True

    def _dispatchClick_DICHOTOMY_Full_ToBeFixed(self, coords):
        &#34;&#34;&#34;
        Finds the element on which the user clicked
        Implemented with dichotomy search (with the hope of making things
        faster, especially the integrated keyboard)
        &#34;&#34;&#34;
        # TODO : To be fixed
        # For now it does not work, because there are empty rows which
        # break the loop
        click_x, click_y = coords
        row_A = 0
        row_C = max(len(self.areaMatrix) - 1, 0)
        print(self.areaMatrix[row_C])
        while len(self.areaMatrix[row_A]) == 0:
            row_A += 1
        while len(self.areaMatrix[row_C]) == 0:
            row_C -= 1
        # First column THEN first row , [(x, y), (w, h)] THUS first tuple of
        # list THEN second coordinate of tuple
        yA = self.areaMatrix[row_A][0][0][1]
        yC = self.areaMatrix[row_C][0][0][1]
        if click_y &lt; yA:
            return None
        if click_y &gt; yC + self.areaMatrix[row_C][0][1][1]:
            return None
        while row_C &gt; row_A+1:
            row_B = int(0.5*(row_A+row_C))      # The average of the two
            while len(self.areaMatrix[row_B]) == 0:
                row_B += 1
            yB = self.areaMatrix[row_B][0][0][1]
            if click_y &gt;= yB or row_B == row_C:
                row_A = row_B
                yA = yB
            else:
                row_C = row_B
                yC = yB
        # User clicked on element ar row of index row_A
        # Let&#39;s do the same for the column
        col_A = 0
        col_C = max(len(self.areaMatrix[row_A]) - 1, 0)
        xA = self.areaMatrix[row_A][col_A][0][0]
        xC = self.areaMatrix[row_A][col_C][0][0]
        if click_x &lt; xA:
            return None
        if click_x &gt; xC + self.areaMatrix[row_A][col_C][1][0]:
            return None
        while col_C &gt; col_A + 1:
            col_B = int(0.5*(col_A+col_C))      # The average of the two
            xB = self.areaMatrix[row_A][col_B][0][0]
            if click_x &gt;= xB or col_B == col_C:
                col_A = col_B
                xA = xB
            else:
                col_C = col_B
                xC = xB
        # Element is at indexes row_A, col_A
        elt, _ = self.layout[row_A-2][col_A+1]
        if elt is not None and elt.onclickInside is not None:
            self.parentPSSMScreen._dispatchClickToElt(coords, elt)
        return True</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="Python-Screen-Stack-Manager.pssm.Element" href="#Python-Screen-Stack-Manager.pssm.Element">Element</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="Python-Screen-Stack-Manager.pssm.ButtonList" href="#Python-Screen-Stack-Manager.pssm.ButtonList">ButtonList</a></li>
<li><a title="Python-Screen-Stack-Manager.pssm.OSK" href="#Python-Screen-Stack-Manager.pssm.OSK">OSK</a></li>
<li><a title="Python-Screen-Stack-Manager.pssm.Popup" href="#Python-Screen-Stack-Manager.pssm.Popup">Popup</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="Python-Screen-Stack-Manager.pssm.Layout.createEltList"><code class="name flex">
<span>def <span class="ident">createEltList</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a list of all the elements the Layout Element contains</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def createEltList(self):
    &#34;&#34;&#34;
    Returns a list of all the elements the Layout Element contains
    &#34;&#34;&#34;
    eltList = []
    for row in self.layout:
        for i in range(1, len(row)):
            elt, _ = row[i]
            if elt is not None:
                eltList.append(elt)
    return eltList</code></pre>
</details>
</dd>
<dt id="Python-Screen-Stack-Manager.pssm.Layout.isLayoutValid"><code class="name flex">
<span>def <span class="ident">isLayoutValid</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def isLayoutValid(self):
    # TODO : to be tested
    layout = self.layout
    if not isinstance(layout, list):
        raise Exception(&#34;Layout Element is supposed to be a list&#34;)
    for row in layout:
        if not isinstance(row, list):
            raise Exception(&#34;A layout row is supposed to be a list&#34;)
        elif len(row) == 0:
            raise Exception(&#34;A layout row cannot be empty&#34;)
        elif not isinstance(row[0], str) and not isinstance(row[0], int):
            raise Exception(
                &#34;The first element of a row (its height) should be a &#34; +
                &#34;string or an integer&#34;
            )
        for j in range(1, len(row)):
            eltTuple = row[j]
            isTuple = isinstance(eltTuple, tuple)
            isList = isinstance(eltTuple, list)
            if not (isTuple or isList):
                raise Exception(
                    &#34;A layout row should be a list of Tuple &#34; +
                    &#34;(except for its first element)&#34;
                )
            if len(eltTuple) != 2:
                raise Exception(
                    &#34;A layout element should be a Tuple : &#34; +
                    &#34;(Element, elementWidth)&#34;
                )
            isStr = isinstance(eltTuple[1], str)
            isInt = isinstance(eltTuple[1], int)
            if not (isInt or isStr):
                raise Exception(
                    &#34;An element width should be a string or an integer&#34;
                )
            isElement = isinstance(eltTuple[0], Element)
            if not (isElement or eltTuple[0] is None):
                raise Exception(
                    &#34;A layout element should be a Tuple : &#34; +
                    &#34;(Element, elementWidth), with Element designating &#34; +
                    &#34; a PSSM Element&#34;
                )
    return True</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="Python-Screen-Stack-Manager.pssm.Element" href="#Python-Screen-Stack-Manager.pssm.Element">Element</a></b></code>:
<ul class="hlist">
<li><code><a title="Python-Screen-Stack-Manager.pssm.Element.convertDimension" href="#Python-Screen-Stack-Manager.pssm.Element.convertDimension">convertDimension</a></code></li>
<li><code><a title="Python-Screen-Stack-Manager.pssm.Element.pssmOnClickInside" href="#Python-Screen-Stack-Manager.pssm.Element.pssmOnClickInside">pssmOnClickInside</a></code></li>
<li><code><a title="Python-Screen-Stack-Manager.pssm.Element.update" href="#Python-Screen-Stack-Manager.pssm.Element.update">update</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="Python-Screen-Stack-Manager.pssm.Line"><code class="flex name class">
<span>class <span class="ident">Line</span></span>
<span>(</span><span>color='black', width=1, type='horizontal')</span>
</code></dt>
<dd>
<div class="desc"><p>Draws a simple line</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>color</code></strong> :&ensp;<code>str</code> or <code>tuple</code></dt>
<dd>"white", "black", "gray0" to "gray15" or a
(red, green, blue, transparency) tuple</dd>
<dt><strong><code>width</code></strong> :&ensp;<code>int</code></dt>
<dd>The width of the line</dd>
<dt><strong><code>type</code></strong> :&ensp;<code>str</code></dt>
<dd>can be "horizontal", "vertical", "diagonal1" (top-left to
bottom right) or "diagonal2" (top-right to bottom-left)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Line(Element):
    &#34;&#34;&#34;
    Draws a simple line
    Args:
        color (str or tuple): &#34;white&#34;, &#34;black&#34;, &#34;gray0&#34; to &#34;gray15&#34; or a
            (red, green, blue, transparency) tuple
        width (int): The width of the line
        type (str): can be &#34;horizontal&#34;, &#34;vertical&#34;, &#34;diagonal1&#34; (top-left to
            bottom right) or &#34;diagonal2&#34; (top-right to bottom-left)
    &#34;&#34;&#34;
    def __init__(self, color=&#34;black&#34;, width=1, type=&#34;horizontal&#34;):
        super().__init__()
        self.color = color
        self.width = width
        self.type = type

    def generator(self, area):
        (x, y), (w, h) = area
        self.area = area
        colorType = self.parentPSSMScreen.colorType
        if self.type == &#34;horizontal&#34;:
            coo = [(0, 0), (w, 0)]
        elif self.type == &#34;vertical&#34;:
            coo = [(0, 0), (0, h)]
        elif self.type == &#34;diagonal1&#34;:
            coo = [(0, 0), (w, h)]
        else:               # Assuming diagonal2
            coo = [(w, 0), (0, h)]
        rectangle = Image.new(
            colorType,
            (w, h),
            color=get_Color(&#34;white&#34;, colorType)
        )
        draw = ImageDraw.Draw(rectangle)
        draw.line(
            coo,
            fill=get_Color(self.color, colorType),
            width=self.width
        )
        self.imgData = rectangle
        return self.imgData</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="Python-Screen-Stack-Manager.pssm.Element" href="#Python-Screen-Stack-Manager.pssm.Element">Element</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="Python-Screen-Stack-Manager.pssm.Element" href="#Python-Screen-Stack-Manager.pssm.Element">Element</a></b></code>:
<ul class="hlist">
<li><code><a title="Python-Screen-Stack-Manager.pssm.Element.convertDimension" href="#Python-Screen-Stack-Manager.pssm.Element.convertDimension">convertDimension</a></code></li>
<li><code><a title="Python-Screen-Stack-Manager.pssm.Element.generator" href="#Python-Screen-Stack-Manager.pssm.Element.generator">generator</a></code></li>
<li><code><a title="Python-Screen-Stack-Manager.pssm.Element.pssmOnClickInside" href="#Python-Screen-Stack-Manager.pssm.Element.pssmOnClickInside">pssmOnClickInside</a></code></li>
<li><code><a title="Python-Screen-Stack-Manager.pssm.Element.update" href="#Python-Screen-Stack-Manager.pssm.Element.update">update</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="Python-Screen-Stack-Manager.pssm.OSK"><code class="flex name class">
<span>class <span class="ident">OSK</span></span>
<span>(</span><span>keymapPath={'standard': 'D:\\Jehan\\Documents\\Developpement\\KOBO\\dev\\Python-Screen-Stack-Manager\\config\\default-keymap-en_us.json', 'caps': 'D:\\Jehan\\Documents\\Developpement\\KOBO\\dev\\Python-Screen-Stack-Manager\\config\\default-keymap-en_us_CAPS.json', 'alt': 'D:\\Jehan\\Documents\\Developpement\\KOBO\\dev\\Python-Screen-Stack-Manager\\config\\default-keymap-en_us_ALT.json'}, onKeyPress=None, area=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>A PSSM Layout element which builds an on-screen keyboard</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>keymapPath</code></strong> :&ensp;<code>str</code></dt>
<dd>a path to a PSSMOSK keymap (like the one included)</dd>
<dt><strong><code>onKeyPress</code></strong> :&ensp;<code>function</code></dt>
<dd>A callback function. Will be given keyType and
keyChar as argument</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class OSK(Layout):
    &#34;&#34;&#34;
    A PSSM Layout element which builds an on-screen keyboard
    Args:
        keymapPath (str): a path to a PSSMOSK keymap (like the one included)
        onKeyPress (function): A callback function. Will be given keyType and
            keyChar as argument
    &#34;&#34;&#34;
    def __init__(self, keymapPath=DEFAULT_KEYMAP_PATH, onKeyPress=None,
                 area=None, **kwargs):
        if not keymapPath:
            keymapPath = DEFAULT_KEYMAP_PATH
        self.keymapPaths = keymapPath
        self.keymap = {&#39;standard&#39;: None, &#39;caps&#39;: None, &#39;alt&#39;: None}
        self.keymap_layouts = {&#39;standard&#39;: None, &#39;caps&#39;: None, &#39;alt&#39;: None}
        self.keymap_imgs = {&#39;standard&#39;: None, &#39;caps&#39;: None, &#39;alt&#39;: None}
        with open(self.keymapPaths[&#39;standard&#39;]) as json_file:
            self.keymap[&#39;standard&#39;] = json.load(json_file)
        with open(self.keymapPaths[&#39;caps&#39;]) as json_file:
            self.keymap[&#39;caps&#39;] = json.load(json_file)
        with open(self.keymapPaths[&#39;alt&#39;]) as json_file:
            self.keymap[&#39;alt&#39;] = json.load(json_file)
        self.lang = self.keymap[&#39;standard&#39;][&#34;lang&#34;]
        self.onKeyPress = onKeyPress
        for param in kwargs:
            setattr(self, param, kwargs[param])
        self.view = &#39;standard&#39;
        self.keymap_layouts[&#39;standard&#39;] = self.build_layout(
                                               self.keymap[&#39;standard&#39;])
        self.keymap_layouts[&#39;caps&#39;] = self.build_layout(self.keymap[&#39;caps&#39;])
        self.keymap_layouts[&#39;alt&#39;] = self.build_layout(self.keymap[&#39;alt&#39;])
        # Initialize layout with standard view
        self.layout = self.keymap_layouts[&#39;standard&#39;]
        super().__init__(self.layout)
        self.area = area

    def generator(self, area=None, forceRegenerate=False,
                  skipNonLayoutGen=False):
        &#34;&#34;&#34;
        This generator is a bit special : we don&#39;t want it to regenerate
        everything everytime we change view. So we will generate all the views
        at once the first time. Then, unless asked to, we will only return the
        appropriate image.
        &#34;&#34;&#34;
        isStDefined = self.keymap_imgs[&#39;standard&#39;]
        isCaDefined = self.keymap_imgs[&#39;caps&#39;]
        isAlDefined = self.keymap_imgs[&#39;alt&#39;]
        areAllDefined = isStDefined and isCaDefined and isAlDefined
        if forceRegenerate or (not areAllDefined):
            print(&#34;[PSSM OSK] Regenration started&#34;)
            # Let&#39;s create all the Images
            # Standard view is created last, because it is the one which is to
            # be displayed
            def generateLayout(name):
                self.layout = self.keymap_layouts[name]
                self.keymap_imgs[name] = super(OSK, self).generator(area=area)
            generateLayout(&#34;caps&#34;)
            generateLayout(&#34;alt&#34;)
            generateLayout(&#34;standard&#34;)
        self.imgData = self.keymap_imgs[self.view]
        return self.keymap_imgs[self.view]

    def build_layout(self, keymap):
        oskLayout = []
        spacing = keymap[&#34;spacing&#34;]
        for row in keymap[&#34;rows&#34;]:
            buttonRow = [&#34;?&#34;, (None, spacing)]
            for key in row:
                label = self.getKeyLabel(key)
                color_condition = key[&#34;keyType&#34;] != KTstandardChar
                background_color = &#34;gray12&#34; if color_condition else &#34;white&#34;
                outline_color = &#34;white&#34; if key[&#34;isPadding&#34;] else &#34;black&#34;
                willChangeLayout = key[&#34;keyType&#34;] in [
                    KTcapsLock, KTalt, KTcarriageReturn
                ]
                invertOnClick = False if willChangeLayout else True
                buttonElt = Button(
                    text=label,
                    font_size=&#34;H*0.02&#34;,
                    background_color=background_color,
                    outline_color=outline_color,
                    onclickInside=self.handleKeyPress,
                    user_data=key,
                    wrap_textOverflow=False,
                    invertOnClick=invertOnClick
                )
                key_width = key[&#34;keyWidth&#34;]
                buttonRow.append((buttonElt, key_width))
                buttonRow.append((None, spacing))
            oskLayout.append(buttonRow)
            oskLayout.append([spacing])
        return oskLayout

    def handleKeyPress(self, elt, coords):
        keyType = elt.user_data[&#34;keyType&#34;]
        keyChar = elt.user_data[&#34;char&#34;]
        if keyType == KTcapsLock:
            # In this particular case, we can assume the keyboard will always
            # be on top.
            # Therefore, no need to print everything
            self.view = &#39;caps&#39; if self.view != &#39;caps&#39; else &#39;standard&#39;
            self.layout = self.keymap_layouts[self.view]
            self.imgData = self.keymap_imgs[self.view]
            self.parentPSSMScreen.simplePrintElt(self)
        elif keyType == KTalt:
            # In this particular case, we can assume the keyboard will always
            # be on top
            # Therefore, no need to print everything
            self.view = &#39;alt&#39; if self.view != &#39;alt&#39; else &#39;standard&#39;
            self.layout = self.keymap_layouts[self.view]
            self.imgData = self.keymap_imgs[self.view]
            self.parentPSSMScreen.simplePrintElt(self)
        if self.onKeyPress:
            self.onKeyPress(keyType, keyChar)

    def getKeyLabel(self, key):
        kt = key[&#34;keyType&#34;]
        if kt == KTstandardChar:
            return key[&#34;char&#34;]
        elif kt == KTalt:
            return &#34;ALT&#34;
        elif kt == KTbackspace:
            return &#34;BACK&#34;
        elif kt == KTcapsLock:
            return &#34;CAPS&#34;
        elif kt == KTcarriageReturn:
            return &#34;RET&#34;
        elif kt == KTcontrol:
            return &#34;CTRL&#34;
        elif kt == KTdelete:
            return &#34;DEL&#34;
        return &#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="Python-Screen-Stack-Manager.pssm.Layout" href="#Python-Screen-Stack-Manager.pssm.Layout">Layout</a></li>
<li><a title="Python-Screen-Stack-Manager.pssm.Element" href="#Python-Screen-Stack-Manager.pssm.Element">Element</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="Python-Screen-Stack-Manager.pssm.OSK.build_layout"><code class="name flex">
<span>def <span class="ident">build_layout</span></span>(<span>self, keymap)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def build_layout(self, keymap):
    oskLayout = []
    spacing = keymap[&#34;spacing&#34;]
    for row in keymap[&#34;rows&#34;]:
        buttonRow = [&#34;?&#34;, (None, spacing)]
        for key in row:
            label = self.getKeyLabel(key)
            color_condition = key[&#34;keyType&#34;] != KTstandardChar
            background_color = &#34;gray12&#34; if color_condition else &#34;white&#34;
            outline_color = &#34;white&#34; if key[&#34;isPadding&#34;] else &#34;black&#34;
            willChangeLayout = key[&#34;keyType&#34;] in [
                KTcapsLock, KTalt, KTcarriageReturn
            ]
            invertOnClick = False if willChangeLayout else True
            buttonElt = Button(
                text=label,
                font_size=&#34;H*0.02&#34;,
                background_color=background_color,
                outline_color=outline_color,
                onclickInside=self.handleKeyPress,
                user_data=key,
                wrap_textOverflow=False,
                invertOnClick=invertOnClick
            )
            key_width = key[&#34;keyWidth&#34;]
            buttonRow.append((buttonElt, key_width))
            buttonRow.append((None, spacing))
        oskLayout.append(buttonRow)
        oskLayout.append([spacing])
    return oskLayout</code></pre>
</details>
</dd>
<dt id="Python-Screen-Stack-Manager.pssm.OSK.generator"><code class="name flex">
<span>def <span class="ident">generator</span></span>(<span>self, area=None, forceRegenerate=False, skipNonLayoutGen=False)</span>
</code></dt>
<dd>
<div class="desc"><p>This generator is a bit special : we don't want it to regenerate
everything everytime we change view. So we will generate all the views
at once the first time. Then, unless asked to, we will only return the
appropriate image.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generator(self, area=None, forceRegenerate=False,
              skipNonLayoutGen=False):
    &#34;&#34;&#34;
    This generator is a bit special : we don&#39;t want it to regenerate
    everything everytime we change view. So we will generate all the views
    at once the first time. Then, unless asked to, we will only return the
    appropriate image.
    &#34;&#34;&#34;
    isStDefined = self.keymap_imgs[&#39;standard&#39;]
    isCaDefined = self.keymap_imgs[&#39;caps&#39;]
    isAlDefined = self.keymap_imgs[&#39;alt&#39;]
    areAllDefined = isStDefined and isCaDefined and isAlDefined
    if forceRegenerate or (not areAllDefined):
        print(&#34;[PSSM OSK] Regenration started&#34;)
        # Let&#39;s create all the Images
        # Standard view is created last, because it is the one which is to
        # be displayed
        def generateLayout(name):
            self.layout = self.keymap_layouts[name]
            self.keymap_imgs[name] = super(OSK, self).generator(area=area)
        generateLayout(&#34;caps&#34;)
        generateLayout(&#34;alt&#34;)
        generateLayout(&#34;standard&#34;)
    self.imgData = self.keymap_imgs[self.view]
    return self.keymap_imgs[self.view]</code></pre>
</details>
</dd>
<dt id="Python-Screen-Stack-Manager.pssm.OSK.getKeyLabel"><code class="name flex">
<span>def <span class="ident">getKeyLabel</span></span>(<span>self, key)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getKeyLabel(self, key):
    kt = key[&#34;keyType&#34;]
    if kt == KTstandardChar:
        return key[&#34;char&#34;]
    elif kt == KTalt:
        return &#34;ALT&#34;
    elif kt == KTbackspace:
        return &#34;BACK&#34;
    elif kt == KTcapsLock:
        return &#34;CAPS&#34;
    elif kt == KTcarriageReturn:
        return &#34;RET&#34;
    elif kt == KTcontrol:
        return &#34;CTRL&#34;
    elif kt == KTdelete:
        return &#34;DEL&#34;
    return &#34;&#34;</code></pre>
</details>
</dd>
<dt id="Python-Screen-Stack-Manager.pssm.OSK.handleKeyPress"><code class="name flex">
<span>def <span class="ident">handleKeyPress</span></span>(<span>self, elt, coords)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def handleKeyPress(self, elt, coords):
    keyType = elt.user_data[&#34;keyType&#34;]
    keyChar = elt.user_data[&#34;char&#34;]
    if keyType == KTcapsLock:
        # In this particular case, we can assume the keyboard will always
        # be on top.
        # Therefore, no need to print everything
        self.view = &#39;caps&#39; if self.view != &#39;caps&#39; else &#39;standard&#39;
        self.layout = self.keymap_layouts[self.view]
        self.imgData = self.keymap_imgs[self.view]
        self.parentPSSMScreen.simplePrintElt(self)
    elif keyType == KTalt:
        # In this particular case, we can assume the keyboard will always
        # be on top
        # Therefore, no need to print everything
        self.view = &#39;alt&#39; if self.view != &#39;alt&#39; else &#39;standard&#39;
        self.layout = self.keymap_layouts[self.view]
        self.imgData = self.keymap_imgs[self.view]
        self.parentPSSMScreen.simplePrintElt(self)
    if self.onKeyPress:
        self.onKeyPress(keyType, keyChar)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="Python-Screen-Stack-Manager.pssm.Layout" href="#Python-Screen-Stack-Manager.pssm.Layout">Layout</a></b></code>:
<ul class="hlist">
<li><code><a title="Python-Screen-Stack-Manager.pssm.Layout.convertDimension" href="#Python-Screen-Stack-Manager.pssm.Element.convertDimension">convertDimension</a></code></li>
<li><code><a title="Python-Screen-Stack-Manager.pssm.Layout.createEltList" href="#Python-Screen-Stack-Manager.pssm.Layout.createEltList">createEltList</a></code></li>
<li><code><a title="Python-Screen-Stack-Manager.pssm.Layout.pssmOnClickInside" href="#Python-Screen-Stack-Manager.pssm.Element.pssmOnClickInside">pssmOnClickInside</a></code></li>
<li><code><a title="Python-Screen-Stack-Manager.pssm.Layout.update" href="#Python-Screen-Stack-Manager.pssm.Element.update">update</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="Python-Screen-Stack-Manager.pssm.PSSMScreen"><code class="flex name class">
<span>class <span class="ident">PSSMScreen</span></span>
<span>(</span><span>deviceName, name='screen', stack=[], isInverted=False)</span>
</code></dt>
<dd>
<div class="desc"><p>This is the class which handles most of the logic.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>deviceName</code></strong> :&ensp;<code>str</code></dt>
<dd>"Kobo" for Kobo ereaders
(and probably all FBInk supported devices)</dd>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>The name of the class instance
(deprecated, I will eventually remove it)</dd>
<dt><strong><code>stack</code></strong> :&ensp;<code>list</code></dt>
<dd>Do not use it unless you know what you are doing.
The list of all the pssm Elements which are on the screen.</dd>
<dt><strong><code>isInverted</code></strong> :&ensp;<code>bool</code></dt>
<dd>&hellip;</dd>
</dl>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>device</code></strong></dt>
<dd>the device.py module.
You can with it access a few useful functions like
<code>self.device.readBatteryPercentage()</code></dd>
<dt><strong><code>colorType</code></strong></dt>
<dd>"L" for grayscale devices, "RGBA" for others</dd>
<dt><strong><code>width</code></strong></dt>
<dd>The screen width</dd>
<dt><strong><code>height</code></strong> :&ensp;<code>The screen height</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>view_width</code></strong></dt>
<dd>The width of the screen portion not hidden behind bezels</dd>
<dt><strong><code>view_height</code></strong></dt>
<dd>&hellip;</dd>
<dt><strong><code>name</code></strong></dt>
<dd>&hellip;</dd>
<dt><strong><code>isInverted</code></strong></dt>
<dd>&hellip;</dd>
</dl>
<p>Example of usage:
screen = pssm.PSSMScreen("Kobo","Main"))</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PSSMScreen:
    &#34;&#34;&#34;
    This is the class which handles most of the logic.

    Args:
        deviceName (str): &#34;Kobo&#34; for Kobo ereaders
            (and probably all FBInk supported devices)
        name (str): The name of the class instance
            (deprecated, I will eventually remove it)
        stack (list): Do not use it unless you know what you are doing.
            The list of all the pssm Elements which are on the screen.
        isInverted (bool): ...

    Attributes:
        device: the device.py module.
            You can with it access a few useful functions like
            `self.device.readBatteryPercentage()`
        colorType: &#34;L&#34; for grayscale devices, &#34;RGBA&#34; for others
        width: The screen width
        height : The screen height
        view_width: The width of the screen portion not hidden behind bezels
        view_height: ...
        name: ...
        isInverted: ...

    Example of usage:
        screen = pssm.PSSMScreen(&#34;Kobo&#34;,&#34;Main&#34;))
    &#34;&#34;&#34;
    def __init__(self, deviceName, name=&#34;screen&#34;, stack=[], isInverted=False):
        self.name = name
        if deviceName == &#34;Kobo&#34;:
            import devices.kobo.device as pssm_device
        else:
            import devices.emulator.device as pssm_device
        self.device = pssm_device
        self.colorType = self.device.colorType
        self.width = self.device.screen_width
        self.height = self.device.screen_height
        self.view_width = self.device.view_width
        self.view_height = self.device.view_height
        self.w_offset = self.device.w_offset
        self.h_offset = self.device.h_offset
        self.area = [(0, 0), (self.view_width, self.view_height)]
        self.stack = stack
        self.isInverted = isInverted
        self.isInputThreadStarted = False
        self.lastX = -1
        self.lastY = -1
        self.osk = None
        self.numberEltOnTop = 0
        self.isOSKShown = False
        self.isBatch = False

    def findEltWithId(self, myElementId, stack=None):
        &#34;&#34;&#34;
        (Deprecated)
        Returns the element which has such an ID.
        Avoid using this function as much as possible:
        it has terrible performance.
        (Recursive search through all the elements of the stack)
        And anyway there is no reason why you should use it.
        &#34;&#34;&#34;
        if stack is None:
            stack = self.stack
        for elt in stack:
            if elt.id == myElementId:
                return elt
            elif elt.isLayout:
                layoutEltList = elt.createEltList()
                search = self.findEltWithId(myElementId, stack=layoutEltList)
                if search is not None:
                    return search
        return None

    def printStack(self, area=None, forceLayoutGen=False):
        &#34;&#34;&#34;
        Prints the stack Elements in the stack order
        If a area is set, then, we only display
        the part of the stack which is in this area
        &#34;&#34;&#34;
        if self.isBatch:
            # Do not do anything during batch mode
            return None
        pil_image = self.capture(area=area, forceLayoutGen=forceLayoutGen)
        if area:
            [(x, y), (w, h)] = area
        else:
            [(x, y), (w, h)] = self.area
        self.device.print_pil(pil_image, x, y, isInverted=self.isInverted)

    def capture(self,area=None, forceLayoutGen=False):
        &#34;&#34;&#34;
        Returns a screen capture of the current stack state.
        &#34;&#34;&#34;
        white = get_Color(&#34;white&#34;, self.colorType)
        dim = (self.width, self.height)
        img = Image.new(self.colorType, dim, color=white)
        for elt in self.stack:
            [(x, y), (w, h)] = elt.area
            if elt.isLayout and forceLayoutGen:
                elt.generator(area=elt.area, skipNonLayoutGen=True)
            if elt.isInverted:
                pil_image = ImageOps.invert(elt.imgData)
            else:
                pil_image = elt.imgData
            img.paste(pil_image, (x, y))
        if area:
            [(x, y), (w, h)] = area
            box = (x, y, x+w, y+h)
            return img.crop(box=box)
        else:
            return img

    def simplePrintElt(self, myElement, skipGen=False):
        &#34;&#34;&#34;
        Prints the Element without adding it to the stack.
        Does not honor isBatch (you can simplePrint even during batch mode)
        Args:
            myElement (PSSM Element): The element you want to display
            skipGen (bool): Do you want to regenerate the image?
        &#34;&#34;&#34;
        if not skipGen:
            # First, the element must be generated
            myElement.generator()
        # Then, we print it
        [(x, y), (w, h)] = myElement.area
        # What follows is a Workaround :
        self.device.print_pil(
            myElement.imgData,
            x, y,
            isInverted=myElement.isInverted
        )

    def startBatchWriting(self):
        &#34;&#34;&#34;
        Toggle batch writing: nothing will be displayed on the screen until
        you use screen.stopBatchWriting()
        &#34;&#34;&#34;
        self.isBatch = True

    def stopBatchWriting(self):
        &#34;&#34;&#34;
        Updates the screen after batch writing
        &#34;&#34;&#34;
        self.isBatch = False
        self.printStack(area=self.area, forceLayoutGen=True)

    def addElt(self, myElement, skipPrint=False, skipRegistration=False):
        &#34;&#34;&#34;
        Adds Element to the stack and prints it
            myElement (PSSM Element): The Element you want to add
            skipPrint (bool): True if you don&#39;t want to update the screen
            skipRegistration (bool): True if you don&#39;t want to add the Element
                to the stack
        &#34;&#34;&#34;
        for i in range(len(self.stack)):
            elt = self.stack[i]
            if elt.id == myElement.id:
                # There is already an Element in the stack with the same ID.
                # Let&#39;s update the Element in the stack
                if not skipPrint:
                    self.stack[i] = myElement
                    self.printStack(area=myElement.area)
                break   # The Element is already in the stack
        else:
            # the Element is not already in the stack
            if not skipRegistration:
                # We append the element to the stack
                myElement.parentPSSMScreen = self
                if self.numberEltOnTop &gt; 0:
                    # There is something on top, addnig it at position -2
                    # (before the last one)
                    pos = - 1 - self.numberEltOnTop
                    self.stack.insert(pos, myElement)
                else:
                    self.stack.append(myElement)
                if not skipPrint :
                    if self.numberEltOnTop &gt; 0 and not self.forcePrintOnTop:
                        # TODO : make it faster, we only need to display the
                        # image behind the keyboard, not reprint everything
                        myElement.generator()
                        self.printStack(area=myElement.area)
                    else:
                        # No keyboard on the horizon, let&#39;s do it
                        if self.isBatch:
                            # Then we only generate
                            myElement.generator()
                        else:
                            myElement.generator()
                            self.simplePrintElt(myElement, skipGen=True)

    def removeElt(self, elt=None, eltid=None, skipPrint=False):
        &#34;&#34;&#34;
        Removes the Element from the stack and hides it from the screen
        &#34;&#34;&#34;
        if elt:
            self.stack.remove(elt)
            if not skipPrint:
                self.printStack(area=elt.area)
        elif eltid:
            elt = self.findEltWithId(eltid)
            if elt:
                self.stack.remove(elt)
                if not skipPrint:
                    self.printStack(area=elt.area)
        else:
            print(&#39;No element given&#39;)

    def getStackLevel(self, myElementId):
        elt = self.findEltWithId(myElementId)
        return self.stack.index(elt)

    def setStackLevel(self, elt, stackLevel=&#34;last&#34;):
        &#34;&#34;&#34;
        Set the position of said Element
        Then prints every Element above it (including itself)
        &#34;&#34;&#34;
        # TODO : Must be able to accept another stackLevel
        if stackLevel == &#34;last&#34; or stackLevel == -1:
            stackLevel = len(self.stack)
            self.removeElt(elt, skipPrint=True)
            self.stack.insert(stackLevel, elt)
            self.printStack(area=[elt.xy, elt.xy2])
            return True

    def invertElt(self, elt, invertDuration=-1,
                  useFastPrint=True, skipPrint=False):
        &#34;&#34;&#34;
        Inverts an Element

        Args:
            elt (Element): The PSSM Element to invert
            invertDuration (int) : -1 or 0 if permanent, else an integer
            skipPrint (bool): Save only or save + print?
            useFastPrint (bool): Use FBInk&#39;s partial refresh with nightmode
                (much faster) instead of printing the whole stack.
        &#34;&#34;&#34;
        if elt is None:
            print(&#34;No element given&#34;)
            return False
        # First, let&#39;s get the Element&#39;s initial inverted state
        Element_initial_state = bool(elt.isInverted)
        elt.isInverted = not Element_initial_state
        if not skipPrint:
            if useFastPrint:
                # Run as thread to make things a bit faster
                args = [
                    elt.area,
                    invertDuration,
                    not Element_initial_state
                ]
                invertThread = threading.Thread(
                    target=self._invertArea_helper,
                    args=args
                )
                invertThread.start()
                # self._invertArea_helper(elt.area, invertDuration, True)
            else:
                elt.update()
        elt.isInverted = Element_initial_state

    def _invertArea_helper(self, area, invertDuration, isInverted=False):
        &#34;&#34;&#34;
        Helper function to properly setup the timer.
        &#34;&#34;&#34;
        # TODO: To be tested
        initial_mode = isInverted
        isTemporaryinvertion = bool(invertDuration &gt; 0)
        self.device.do_screen_refresh(
            isInverted=isInverted,
            area=area,
            isInvertionPermanent=False,
            isFlashing=False,
            useFastInvertion=True
        )
        if isTemporaryinvertion:
            # Now we call this funcion, without starting a timer
            # And the screen is now in an opposite state as the initial one
            myTimer = threading.Timer(
                interval=invertDuration,
                function=self._invertArea_helper,
                args=[area, -1, not initial_mode]
            )
            myTimer.start()
        return True

    def invert(self):
        &#34;&#34;&#34;
        Inverts the whole screen
        &#34;&#34;&#34;
        self.isInverted = not self.isInverted
        self.device.do_screen_refresh(self.isInverted)
        return True

    def refresh(self):
        &#34;&#34;&#34;
        Refreshes the screeen
        &#34;&#34;&#34;
        self.device.do_screen_refresh()
        return True

    def clear(self):
        &#34;&#34;&#34;
        Clears the screen
        &#34;&#34;&#34;
        self.device.do_screen_clear()
        return True

    def OSKInit(self, onKeyPress=None, area=None, keymapPath=None):
        if not area:
            x = 0
            y = int(2*self.view_height/3)
            w = self.view_width
            h = int(self.view_height/3)
            area = [(x, y), (w, h)]
        self.osk = OSK(onKeyPress=onKeyPress, area=area, keymapPath=keymapPath)

    def OSKShow(self, onKeyPress=None):
        if not self.osk:
            print(&#34;OSK not initialized, it can&#39;t be shown&#34;)
            return None
        if onKeyPress:
            self.osk.onKeyPress = onKeyPress
        self.addElt(self.osk)   # It has already been generated
        self.numberEltOnTop += 1
        self.isOSKShown = True

    def OSKHide(self):
        if self.isOSKShown:
            self.removeElt(elt=self.osk)
            self.numberEltOnTop -= 1
            self.isOSKShown = False

    def startListenerThread(self, grabInput=False):
        &#34;&#34;&#34;
        Starts the touch listener as a separate thread
        Args:
            grabInput (boolean): Do an EVIOCGRAB IOCTL call to prevent
                any other software from registering touch events
        &#34;&#34;&#34;
        self.isInputThreadStarted = True
        self.device.isInputThreadStarted = True
        print(&#34;[PSSM - Touch handler] : Input thread started&#34;)
        args = [self._clickHandler, True, grabInput]
        inputThread = threading.Thread(
            target=self.device.eventBindings,
            args=args
        )
        inputThread.start()

    def _clickHandler(self, x, y):
        n = len(self.stack)
        for i in range(n):
            j = n-1-i   # We go through the stack in descending order
            elt = self.stack[j]
            if elt.area is None:
                # An object without area, it should not happen, but if it does,
                # it can be skipped
                continue
            if coordsInArea(x, y, elt.area):
                if elt.onclickInside is not None:
                    self.lastX = x
                    self.lastY = y
                    if elt is not None:
                        self._dispatchClickToElt((x, y), elt)
                break

    def _dispatchClickToElt(self, coords, elt):
        &#34;&#34;&#34;
        Once given an object on which the user clicked, this function calls the
        appropriate function on the object
        (ie elt.onclickInside or elt._dispatchClick)
        It also handles invertion.
        &#34;&#34;&#34;
        if elt.isLayout:
            if elt.onclickInside is not None:
                elt.onclickInside(elt, coords)
            if elt.invertOnClick:
                self.invertElt(elt, elt.invertDuration)
            elt._dispatchClick(coords)
        else:
            if elt.invertOnClick:
                self.invertElt(elt, elt.invertDuration)
            # Execute PSSM action on click
            elt.pssmOnClickInside(coords)
            # Execute user action attached to it too
            elt.onclickInside(elt, coords)

    def stopListenerThread(self):
        self.isInputThreadStarted = False
        self.device.isInputThreadStarted = False
        print(&#34;[PSSM - Touch handler] : Input thread stopped&#34;)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="Python-Screen-Stack-Manager.pssm.PSSMScreen.OSKHide"><code class="name flex">
<span>def <span class="ident">OSKHide</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def OSKHide(self):
    if self.isOSKShown:
        self.removeElt(elt=self.osk)
        self.numberEltOnTop -= 1
        self.isOSKShown = False</code></pre>
</details>
</dd>
<dt id="Python-Screen-Stack-Manager.pssm.PSSMScreen.OSKInit"><code class="name flex">
<span>def <span class="ident">OSKInit</span></span>(<span>self, onKeyPress=None, area=None, keymapPath=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def OSKInit(self, onKeyPress=None, area=None, keymapPath=None):
    if not area:
        x = 0
        y = int(2*self.view_height/3)
        w = self.view_width
        h = int(self.view_height/3)
        area = [(x, y), (w, h)]
    self.osk = OSK(onKeyPress=onKeyPress, area=area, keymapPath=keymapPath)</code></pre>
</details>
</dd>
<dt id="Python-Screen-Stack-Manager.pssm.PSSMScreen.OSKShow"><code class="name flex">
<span>def <span class="ident">OSKShow</span></span>(<span>self, onKeyPress=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def OSKShow(self, onKeyPress=None):
    if not self.osk:
        print(&#34;OSK not initialized, it can&#39;t be shown&#34;)
        return None
    if onKeyPress:
        self.osk.onKeyPress = onKeyPress
    self.addElt(self.osk)   # It has already been generated
    self.numberEltOnTop += 1
    self.isOSKShown = True</code></pre>
</details>
</dd>
<dt id="Python-Screen-Stack-Manager.pssm.PSSMScreen.addElt"><code class="name flex">
<span>def <span class="ident">addElt</span></span>(<span>self, myElement, skipPrint=False, skipRegistration=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Adds Element to the stack and prints it
myElement (PSSM Element): The Element you want to add
skipPrint (bool): True if you don't want to update the screen
skipRegistration (bool): True if you don't want to add the Element
to the stack</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def addElt(self, myElement, skipPrint=False, skipRegistration=False):
    &#34;&#34;&#34;
    Adds Element to the stack and prints it
        myElement (PSSM Element): The Element you want to add
        skipPrint (bool): True if you don&#39;t want to update the screen
        skipRegistration (bool): True if you don&#39;t want to add the Element
            to the stack
    &#34;&#34;&#34;
    for i in range(len(self.stack)):
        elt = self.stack[i]
        if elt.id == myElement.id:
            # There is already an Element in the stack with the same ID.
            # Let&#39;s update the Element in the stack
            if not skipPrint:
                self.stack[i] = myElement
                self.printStack(area=myElement.area)
            break   # The Element is already in the stack
    else:
        # the Element is not already in the stack
        if not skipRegistration:
            # We append the element to the stack
            myElement.parentPSSMScreen = self
            if self.numberEltOnTop &gt; 0:
                # There is something on top, addnig it at position -2
                # (before the last one)
                pos = - 1 - self.numberEltOnTop
                self.stack.insert(pos, myElement)
            else:
                self.stack.append(myElement)
            if not skipPrint :
                if self.numberEltOnTop &gt; 0 and not self.forcePrintOnTop:
                    # TODO : make it faster, we only need to display the
                    # image behind the keyboard, not reprint everything
                    myElement.generator()
                    self.printStack(area=myElement.area)
                else:
                    # No keyboard on the horizon, let&#39;s do it
                    if self.isBatch:
                        # Then we only generate
                        myElement.generator()
                    else:
                        myElement.generator()
                        self.simplePrintElt(myElement, skipGen=True)</code></pre>
</details>
</dd>
<dt id="Python-Screen-Stack-Manager.pssm.PSSMScreen.capture"><code class="name flex">
<span>def <span class="ident">capture</span></span>(<span>self, area=None, forceLayoutGen=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a screen capture of the current stack state.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def capture(self,area=None, forceLayoutGen=False):
    &#34;&#34;&#34;
    Returns a screen capture of the current stack state.
    &#34;&#34;&#34;
    white = get_Color(&#34;white&#34;, self.colorType)
    dim = (self.width, self.height)
    img = Image.new(self.colorType, dim, color=white)
    for elt in self.stack:
        [(x, y), (w, h)] = elt.area
        if elt.isLayout and forceLayoutGen:
            elt.generator(area=elt.area, skipNonLayoutGen=True)
        if elt.isInverted:
            pil_image = ImageOps.invert(elt.imgData)
        else:
            pil_image = elt.imgData
        img.paste(pil_image, (x, y))
    if area:
        [(x, y), (w, h)] = area
        box = (x, y, x+w, y+h)
        return img.crop(box=box)
    else:
        return img</code></pre>
</details>
</dd>
<dt id="Python-Screen-Stack-Manager.pssm.PSSMScreen.clear"><code class="name flex">
<span>def <span class="ident">clear</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Clears the screen</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clear(self):
    &#34;&#34;&#34;
    Clears the screen
    &#34;&#34;&#34;
    self.device.do_screen_clear()
    return True</code></pre>
</details>
</dd>
<dt id="Python-Screen-Stack-Manager.pssm.PSSMScreen.findEltWithId"><code class="name flex">
<span>def <span class="ident">findEltWithId</span></span>(<span>self, myElementId, stack=None)</span>
</code></dt>
<dd>
<div class="desc"><p>(Deprecated)
Returns the element which has such an ID.
Avoid using this function as much as possible:
it has terrible performance.
(Recursive search through all the elements of the stack)
And anyway there is no reason why you should use it.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def findEltWithId(self, myElementId, stack=None):
    &#34;&#34;&#34;
    (Deprecated)
    Returns the element which has such an ID.
    Avoid using this function as much as possible:
    it has terrible performance.
    (Recursive search through all the elements of the stack)
    And anyway there is no reason why you should use it.
    &#34;&#34;&#34;
    if stack is None:
        stack = self.stack
    for elt in stack:
        if elt.id == myElementId:
            return elt
        elif elt.isLayout:
            layoutEltList = elt.createEltList()
            search = self.findEltWithId(myElementId, stack=layoutEltList)
            if search is not None:
                return search
    return None</code></pre>
</details>
</dd>
<dt id="Python-Screen-Stack-Manager.pssm.PSSMScreen.getStackLevel"><code class="name flex">
<span>def <span class="ident">getStackLevel</span></span>(<span>self, myElementId)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getStackLevel(self, myElementId):
    elt = self.findEltWithId(myElementId)
    return self.stack.index(elt)</code></pre>
</details>
</dd>
<dt id="Python-Screen-Stack-Manager.pssm.PSSMScreen.invert"><code class="name flex">
<span>def <span class="ident">invert</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Inverts the whole screen</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def invert(self):
    &#34;&#34;&#34;
    Inverts the whole screen
    &#34;&#34;&#34;
    self.isInverted = not self.isInverted
    self.device.do_screen_refresh(self.isInverted)
    return True</code></pre>
</details>
</dd>
<dt id="Python-Screen-Stack-Manager.pssm.PSSMScreen.invertElt"><code class="name flex">
<span>def <span class="ident">invertElt</span></span>(<span>self, elt, invertDuration=-1, useFastPrint=True, skipPrint=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Inverts an Element</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>elt</code></strong> :&ensp;<code><a title="Python-Screen-Stack-Manager.pssm.Element" href="#Python-Screen-Stack-Manager.pssm.Element">Element</a></code></dt>
<dd>The PSSM Element to invert</dd>
<dt>invertDuration (int) : -1 or 0 if permanent, else an integer</dt>
<dt><strong><code>skipPrint</code></strong> :&ensp;<code>bool</code></dt>
<dd>Save only or save + print?</dd>
<dt><strong><code>useFastPrint</code></strong> :&ensp;<code>bool</code></dt>
<dd>Use FBInk's partial refresh with nightmode
(much faster) instead of printing the whole stack.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def invertElt(self, elt, invertDuration=-1,
              useFastPrint=True, skipPrint=False):
    &#34;&#34;&#34;
    Inverts an Element

    Args:
        elt (Element): The PSSM Element to invert
        invertDuration (int) : -1 or 0 if permanent, else an integer
        skipPrint (bool): Save only or save + print?
        useFastPrint (bool): Use FBInk&#39;s partial refresh with nightmode
            (much faster) instead of printing the whole stack.
    &#34;&#34;&#34;
    if elt is None:
        print(&#34;No element given&#34;)
        return False
    # First, let&#39;s get the Element&#39;s initial inverted state
    Element_initial_state = bool(elt.isInverted)
    elt.isInverted = not Element_initial_state
    if not skipPrint:
        if useFastPrint:
            # Run as thread to make things a bit faster
            args = [
                elt.area,
                invertDuration,
                not Element_initial_state
            ]
            invertThread = threading.Thread(
                target=self._invertArea_helper,
                args=args
            )
            invertThread.start()
            # self._invertArea_helper(elt.area, invertDuration, True)
        else:
            elt.update()
    elt.isInverted = Element_initial_state</code></pre>
</details>
</dd>
<dt id="Python-Screen-Stack-Manager.pssm.PSSMScreen.printStack"><code class="name flex">
<span>def <span class="ident">printStack</span></span>(<span>self, area=None, forceLayoutGen=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Prints the stack Elements in the stack order
If a area is set, then, we only display
the part of the stack which is in this area</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def printStack(self, area=None, forceLayoutGen=False):
    &#34;&#34;&#34;
    Prints the stack Elements in the stack order
    If a area is set, then, we only display
    the part of the stack which is in this area
    &#34;&#34;&#34;
    if self.isBatch:
        # Do not do anything during batch mode
        return None
    pil_image = self.capture(area=area, forceLayoutGen=forceLayoutGen)
    if area:
        [(x, y), (w, h)] = area
    else:
        [(x, y), (w, h)] = self.area
    self.device.print_pil(pil_image, x, y, isInverted=self.isInverted)</code></pre>
</details>
</dd>
<dt id="Python-Screen-Stack-Manager.pssm.PSSMScreen.refresh"><code class="name flex">
<span>def <span class="ident">refresh</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Refreshes the screeen</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def refresh(self):
    &#34;&#34;&#34;
    Refreshes the screeen
    &#34;&#34;&#34;
    self.device.do_screen_refresh()
    return True</code></pre>
</details>
</dd>
<dt id="Python-Screen-Stack-Manager.pssm.PSSMScreen.removeElt"><code class="name flex">
<span>def <span class="ident">removeElt</span></span>(<span>self, elt=None, eltid=None, skipPrint=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Removes the Element from the stack and hides it from the screen</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def removeElt(self, elt=None, eltid=None, skipPrint=False):
    &#34;&#34;&#34;
    Removes the Element from the stack and hides it from the screen
    &#34;&#34;&#34;
    if elt:
        self.stack.remove(elt)
        if not skipPrint:
            self.printStack(area=elt.area)
    elif eltid:
        elt = self.findEltWithId(eltid)
        if elt:
            self.stack.remove(elt)
            if not skipPrint:
                self.printStack(area=elt.area)
    else:
        print(&#39;No element given&#39;)</code></pre>
</details>
</dd>
<dt id="Python-Screen-Stack-Manager.pssm.PSSMScreen.setStackLevel"><code class="name flex">
<span>def <span class="ident">setStackLevel</span></span>(<span>self, elt, stackLevel='last')</span>
</code></dt>
<dd>
<div class="desc"><p>Set the position of said Element
Then prints every Element above it (including itself)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setStackLevel(self, elt, stackLevel=&#34;last&#34;):
    &#34;&#34;&#34;
    Set the position of said Element
    Then prints every Element above it (including itself)
    &#34;&#34;&#34;
    # TODO : Must be able to accept another stackLevel
    if stackLevel == &#34;last&#34; or stackLevel == -1:
        stackLevel = len(self.stack)
        self.removeElt(elt, skipPrint=True)
        self.stack.insert(stackLevel, elt)
        self.printStack(area=[elt.xy, elt.xy2])
        return True</code></pre>
</details>
</dd>
<dt id="Python-Screen-Stack-Manager.pssm.PSSMScreen.simplePrintElt"><code class="name flex">
<span>def <span class="ident">simplePrintElt</span></span>(<span>self, myElement, skipGen=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Prints the Element without adding it to the stack.
Does not honor isBatch (you can simplePrint even during batch mode)</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>myElement</code></strong> :&ensp;<code>PSSM <a title="Python-Screen-Stack-Manager.pssm.Element" href="#Python-Screen-Stack-Manager.pssm.Element">Element</a></code></dt>
<dd>The element you want to display</dd>
<dt><strong><code>skipGen</code></strong> :&ensp;<code>bool</code></dt>
<dd>Do you want to regenerate the image?</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def simplePrintElt(self, myElement, skipGen=False):
    &#34;&#34;&#34;
    Prints the Element without adding it to the stack.
    Does not honor isBatch (you can simplePrint even during batch mode)
    Args:
        myElement (PSSM Element): The element you want to display
        skipGen (bool): Do you want to regenerate the image?
    &#34;&#34;&#34;
    if not skipGen:
        # First, the element must be generated
        myElement.generator()
    # Then, we print it
    [(x, y), (w, h)] = myElement.area
    # What follows is a Workaround :
    self.device.print_pil(
        myElement.imgData,
        x, y,
        isInverted=myElement.isInverted
    )</code></pre>
</details>
</dd>
<dt id="Python-Screen-Stack-Manager.pssm.PSSMScreen.startBatchWriting"><code class="name flex">
<span>def <span class="ident">startBatchWriting</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Toggle batch writing: nothing will be displayed on the screen until
you use screen.stopBatchWriting()</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def startBatchWriting(self):
    &#34;&#34;&#34;
    Toggle batch writing: nothing will be displayed on the screen until
    you use screen.stopBatchWriting()
    &#34;&#34;&#34;
    self.isBatch = True</code></pre>
</details>
</dd>
<dt id="Python-Screen-Stack-Manager.pssm.PSSMScreen.startListenerThread"><code class="name flex">
<span>def <span class="ident">startListenerThread</span></span>(<span>self, grabInput=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Starts the touch listener as a separate thread</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>grabInput</code></strong> :&ensp;<code>boolean</code></dt>
<dd>Do an EVIOCGRAB IOCTL call to prevent
any other software from registering touch events</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def startListenerThread(self, grabInput=False):
    &#34;&#34;&#34;
    Starts the touch listener as a separate thread
    Args:
        grabInput (boolean): Do an EVIOCGRAB IOCTL call to prevent
            any other software from registering touch events
    &#34;&#34;&#34;
    self.isInputThreadStarted = True
    self.device.isInputThreadStarted = True
    print(&#34;[PSSM - Touch handler] : Input thread started&#34;)
    args = [self._clickHandler, True, grabInput]
    inputThread = threading.Thread(
        target=self.device.eventBindings,
        args=args
    )
    inputThread.start()</code></pre>
</details>
</dd>
<dt id="Python-Screen-Stack-Manager.pssm.PSSMScreen.stopBatchWriting"><code class="name flex">
<span>def <span class="ident">stopBatchWriting</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Updates the screen after batch writing</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def stopBatchWriting(self):
    &#34;&#34;&#34;
    Updates the screen after batch writing
    &#34;&#34;&#34;
    self.isBatch = False
    self.printStack(area=self.area, forceLayoutGen=True)</code></pre>
</details>
</dd>
<dt id="Python-Screen-Stack-Manager.pssm.PSSMScreen.stopListenerThread"><code class="name flex">
<span>def <span class="ident">stopListenerThread</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def stopListenerThread(self):
    self.isInputThreadStarted = False
    self.device.isInputThreadStarted = False
    print(&#34;[PSSM - Touch handler] : Input thread stopped&#34;)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="Python-Screen-Stack-Manager.pssm.Popup"><code class="flex name class">
<span>class <span class="ident">Popup</span></span>
<span>(</span><span>layout=[], width='W*0.8', height='H*0.5', xPos=0.5, yPos=0.3, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>A popup to be displayed above everything else, to simple ask a question</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>layout</code></strong> :&ensp;<code>list</code></dt>
<dd>The list of PSSMElements to be displayed. cf Layout</dd>
<dt><strong><code>width</code></strong> :&ensp;<code>str</code></dt>
<dd>The width of the popup</dd>
<dt><strong><code>height</code></strong> :&ensp;<code>str</code></dt>
<dd>The height of the popup</dd>
<dt><strong><code>xPos</code></strong> :&ensp;<code>float</code></dt>
<dd>Relative position on the x axis of the center point</dd>
<dt><strong><code>yPos</code></strong> :&ensp;<code>float</code></dt>
<dd>Relative position on the y axis of the center point</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Popup(Layout):
    &#34;&#34;&#34;
    A popup to be displayed above everything else, to simple ask a question
    Args:
        layout (list): The list of PSSMElements to be displayed. cf Layout
        width (str): The width of the popup
        height (str): The height of the popup
        xPos (float): Relative position on the x axis of the center point
        yPos (float): Relative position on the y axis of the center point
    &#34;&#34;&#34;
    def __init__(self, layout=[], width=&#34;W*0.8&#34;, height=&#34;H*0.5&#34;,
                 xPos=0.5, yPos=0.3, **kwargs):
        super().__init__(layout=layout)
        self.width = width
        self.height = height
        self.xPos = xPos
        self.yPos = yPos
        for param in kwargs:
            setattr(self, param, kwargs[param])

    def make_area(self):
        w = self.convertDimension(self.width)
        h = self.convertDimension(self.height)
        x = self.convertDimension(&#34;W*&#34; + str(self.xPos)) - int(0.5*w)
        y = self.convertDimension(&#34;H*&#34; + str(self.yPos)) - int(0.5*h)
        self.area = [(x, y), (w, h)]
        return self.area</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="Python-Screen-Stack-Manager.pssm.Layout" href="#Python-Screen-Stack-Manager.pssm.Layout">Layout</a></li>
<li><a title="Python-Screen-Stack-Manager.pssm.Element" href="#Python-Screen-Stack-Manager.pssm.Element">Element</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="Python-Screen-Stack-Manager.pssm.PopupConfirm" href="#Python-Screen-Stack-Manager.pssm.PopupConfirm">PopupConfirm</a></li>
<li><a title="Python-Screen-Stack-Manager.pssm.PoputInput" href="#Python-Screen-Stack-Manager.pssm.PoputInput">PoputInput</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="Python-Screen-Stack-Manager.pssm.Popup.make_area"><code class="name flex">
<span>def <span class="ident">make_area</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def make_area(self):
    w = self.convertDimension(self.width)
    h = self.convertDimension(self.height)
    x = self.convertDimension(&#34;W*&#34; + str(self.xPos)) - int(0.5*w)
    y = self.convertDimension(&#34;H*&#34; + str(self.yPos)) - int(0.5*h)
    self.area = [(x, y), (w, h)]
    return self.area</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="Python-Screen-Stack-Manager.pssm.Layout" href="#Python-Screen-Stack-Manager.pssm.Layout">Layout</a></b></code>:
<ul class="hlist">
<li><code><a title="Python-Screen-Stack-Manager.pssm.Layout.convertDimension" href="#Python-Screen-Stack-Manager.pssm.Element.convertDimension">convertDimension</a></code></li>
<li><code><a title="Python-Screen-Stack-Manager.pssm.Layout.createEltList" href="#Python-Screen-Stack-Manager.pssm.Layout.createEltList">createEltList</a></code></li>
<li><code><a title="Python-Screen-Stack-Manager.pssm.Layout.generator" href="#Python-Screen-Stack-Manager.pssm.Layout.generator">generator</a></code></li>
<li><code><a title="Python-Screen-Stack-Manager.pssm.Layout.pssmOnClickInside" href="#Python-Screen-Stack-Manager.pssm.Element.pssmOnClickInside">pssmOnClickInside</a></code></li>
<li><code><a title="Python-Screen-Stack-Manager.pssm.Layout.update" href="#Python-Screen-Stack-Manager.pssm.Element.update">update</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="Python-Screen-Stack-Manager.pssm.PopupConfirm"><code class="flex name class">
<span>class <span class="ident">PopupConfirm</span></span>
<span>(</span><span>titleText='', mainText='', confirmText='OK', cancelText='Cancel', titleFont='default', titleFontSize='H*0.036', mainFont='default', mainFontSize='H*0.036', confirmFont='default', confirmFontSize='H*0.036', titleFontColor='black', mainFontColor='black', confirmFontColor='black', mainTextXPos='center', mainTextYPos='center', **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>A popup to be displayed above everything else, to simple ask a question</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>layout</code></strong> :&ensp;<code>list</code></dt>
<dd>The list of PSSMElements to be displayed. cf Layout</dd>
<dt><strong><code>width</code></strong> :&ensp;<code>str</code></dt>
<dd>The width of the popup</dd>
<dt><strong><code>height</code></strong> :&ensp;<code>str</code></dt>
<dd>The height of the popup</dd>
<dt><strong><code>xPos</code></strong> :&ensp;<code>float</code></dt>
<dd>Relative position on the x axis of the center point</dd>
<dt><strong><code>yPos</code></strong> :&ensp;<code>float</code></dt>
<dd>Relative position on the y axis of the center point</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PopupConfirm(Popup):
    def __init__(self, titleText=&#34;&#34;, mainText=&#34;&#34;, confirmText=&#34;OK&#34;,
                 cancelText=&#34;Cancel&#34;,
                 titleFont=DEFAULT_FONT, titleFontSize=DEFAULT_FONT_SIZE,
                 mainFont=DEFAULT_FONT, mainFontSize=DEFAULT_FONT_SIZE,
                 confirmFont=DEFAULT_FONT, confirmFontSize=DEFAULT_FONT_SIZE,
                 titleFontColor=&#34;black&#34;, mainFontColor=&#34;black&#34;,
                 confirmFontColor=&#34;black&#34;,
                 mainTextXPos=&#34;center&#34;, mainTextYPos=&#34;center&#34;,
                 **kwargs):
        super().__init__()
        self.titleText = titleText
        self.mainText = mainText
        self.confirmText = confirmText
        self.cancelText = cancelText
        self.titleFont = titleFont
        self.mainFont = mainFont
        self.confirmFont = confirmFont
        self.titleFontSize = titleFontSize
        self.mainFontSize = mainFontSize
        self.confirmFontSize = confirmFontSize
        self.titleFontColor = titleFontColor
        self.mainFontColor = mainFontColor
        self.confirmFontColor = confirmFontColor
        self.mainTextXPos = mainTextXPos
        self.mainTextYPos = mainTextYPos
        self.userAction = 0
        self.okBtn = None
        self.cancelBtn = None
        for param in kwargs:
            setattr(self, param, kwargs[param])
        self.build_layout()

    def generator(self,**kwargs):
        self.make_area()
        super().generator(**kwargs)

    def build_layout(self):
        titleBtn = Button(
            text=self.titleText,
            font=self.titleFont,
            font_size=self.titleFontSize,
            font_color=self.titleFontColor
        )
        mainBtn = Button(
            text=self.mainText,
            font=self.mainFont,
            font_size=self.mainFontSize,
            font_color=self.mainFontColor,
            text_xPosition=self.mainTextXPos,
            text_yPosition=self.mainTextYPos
        )
        okBtn = Button(
            text=self.confirmText,
            font=self.confirmFont,
            font_size=self.confirmFontSize,
            font_color=self.confirmFontColor,
            onclickInside=self.confirm
        )
        cancelBtn = Button(
            text=self.cancelText,
            font=self.confirmFont,
            font_size=self.confirmFontSize,
            font_color=self.confirmFontColor,
            onclickInside=self.cancel
        )
        lM = (None,1)
        layout = [
            [&#34;?*1.5&#34;, (titleBtn, &#34;?&#34;), lM],
            [&#34;?*3&#34;, (mainBtn, &#34;?&#34;), lM],
            [&#34;?*1&#34;, (okBtn, &#34;?&#34;), (cancelBtn, &#34;?&#34;), lM]
        ]
        self.layout = layout
        return layout

    def confirm(self, elt=None, coords=None):
            self.userAction = 1

    def cancel(self,elt=None, coords=None):
            self.userAction = 2

    def waitForResponse(self):
        while self.userAction == 0:
            self.parentPSSMScreen.device.wait(0.01)
        self.parentPSSMScreen.OSKHide()
        hasConfirmed = self.userAction == 1
        self.userAction = 0  # Reset the state
        self.parentPSSMScreen.removeElt(self)
        return hasConfirmed</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="Python-Screen-Stack-Manager.pssm.Popup" href="#Python-Screen-Stack-Manager.pssm.Popup">Popup</a></li>
<li><a title="Python-Screen-Stack-Manager.pssm.Layout" href="#Python-Screen-Stack-Manager.pssm.Layout">Layout</a></li>
<li><a title="Python-Screen-Stack-Manager.pssm.Element" href="#Python-Screen-Stack-Manager.pssm.Element">Element</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="Python-Screen-Stack-Manager.pssm.PopupConfirm.build_layout"><code class="name flex">
<span>def <span class="ident">build_layout</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def build_layout(self):
    titleBtn = Button(
        text=self.titleText,
        font=self.titleFont,
        font_size=self.titleFontSize,
        font_color=self.titleFontColor
    )
    mainBtn = Button(
        text=self.mainText,
        font=self.mainFont,
        font_size=self.mainFontSize,
        font_color=self.mainFontColor,
        text_xPosition=self.mainTextXPos,
        text_yPosition=self.mainTextYPos
    )
    okBtn = Button(
        text=self.confirmText,
        font=self.confirmFont,
        font_size=self.confirmFontSize,
        font_color=self.confirmFontColor,
        onclickInside=self.confirm
    )
    cancelBtn = Button(
        text=self.cancelText,
        font=self.confirmFont,
        font_size=self.confirmFontSize,
        font_color=self.confirmFontColor,
        onclickInside=self.cancel
    )
    lM = (None,1)
    layout = [
        [&#34;?*1.5&#34;, (titleBtn, &#34;?&#34;), lM],
        [&#34;?*3&#34;, (mainBtn, &#34;?&#34;), lM],
        [&#34;?*1&#34;, (okBtn, &#34;?&#34;), (cancelBtn, &#34;?&#34;), lM]
    ]
    self.layout = layout
    return layout</code></pre>
</details>
</dd>
<dt id="Python-Screen-Stack-Manager.pssm.PopupConfirm.cancel"><code class="name flex">
<span>def <span class="ident">cancel</span></span>(<span>self, elt=None, coords=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cancel(self,elt=None, coords=None):
        self.userAction = 2</code></pre>
</details>
</dd>
<dt id="Python-Screen-Stack-Manager.pssm.PopupConfirm.confirm"><code class="name flex">
<span>def <span class="ident">confirm</span></span>(<span>self, elt=None, coords=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def confirm(self, elt=None, coords=None):
        self.userAction = 1</code></pre>
</details>
</dd>
<dt id="Python-Screen-Stack-Manager.pssm.PopupConfirm.waitForResponse"><code class="name flex">
<span>def <span class="ident">waitForResponse</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def waitForResponse(self):
    while self.userAction == 0:
        self.parentPSSMScreen.device.wait(0.01)
    self.parentPSSMScreen.OSKHide()
    hasConfirmed = self.userAction == 1
    self.userAction = 0  # Reset the state
    self.parentPSSMScreen.removeElt(self)
    return hasConfirmed</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="Python-Screen-Stack-Manager.pssm.Popup" href="#Python-Screen-Stack-Manager.pssm.Popup">Popup</a></b></code>:
<ul class="hlist">
<li><code><a title="Python-Screen-Stack-Manager.pssm.Popup.convertDimension" href="#Python-Screen-Stack-Manager.pssm.Element.convertDimension">convertDimension</a></code></li>
<li><code><a title="Python-Screen-Stack-Manager.pssm.Popup.createEltList" href="#Python-Screen-Stack-Manager.pssm.Layout.createEltList">createEltList</a></code></li>
<li><code><a title="Python-Screen-Stack-Manager.pssm.Popup.generator" href="#Python-Screen-Stack-Manager.pssm.Layout.generator">generator</a></code></li>
<li><code><a title="Python-Screen-Stack-Manager.pssm.Popup.pssmOnClickInside" href="#Python-Screen-Stack-Manager.pssm.Element.pssmOnClickInside">pssmOnClickInside</a></code></li>
<li><code><a title="Python-Screen-Stack-Manager.pssm.Popup.update" href="#Python-Screen-Stack-Manager.pssm.Element.update">update</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="Python-Screen-Stack-Manager.pssm.PoputInput"><code class="flex name class">
<span>class <span class="ident">PoputInput</span></span>
<span>(</span><span>titleText='', mainText='', confirmText='OK', titleFont='default', titleFontSize='H*0.036', mainFont='default', mainFontSize='H*0.036', inputFont='default', inputFontSize='H*0.036', confirmFont='default', confirmFontSize='H*0.036', titleFontColor='black', mainFontColor='black', inputFontColor='black', confirmFontColor='black', mainTextXPos='center', mainTextYPos='center', isMultiline=False, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>A popup to be displayed above everything else, to simple ask a question</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>layout</code></strong> :&ensp;<code>list</code></dt>
<dd>The list of PSSMElements to be displayed. cf Layout</dd>
<dt><strong><code>width</code></strong> :&ensp;<code>str</code></dt>
<dd>The width of the popup</dd>
<dt><strong><code>height</code></strong> :&ensp;<code>str</code></dt>
<dd>The height of the popup</dd>
<dt><strong><code>xPos</code></strong> :&ensp;<code>float</code></dt>
<dd>Relative position on the x axis of the center point</dd>
<dt><strong><code>yPos</code></strong> :&ensp;<code>float</code></dt>
<dd>Relative position on the y axis of the center point</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PoputInput(Popup):
    def __init__(self, titleText=&#34;&#34;, mainText=&#34;&#34;, confirmText=&#34;OK&#34;,
                 titleFont=DEFAULT_FONT, titleFontSize=DEFAULT_FONT_SIZE,
                 mainFont=DEFAULT_FONT, mainFontSize=DEFAULT_FONT_SIZE,
                 inputFont=DEFAULT_FONT, inputFontSize=DEFAULT_FONT_SIZE,
                 confirmFont=DEFAULT_FONT, confirmFontSize=DEFAULT_FONT_SIZE,
                 titleFontColor=&#34;black&#34;, mainFontColor=&#34;black&#34;,
                 inputFontColor=&#34;black&#34;, confirmFontColor=&#34;black&#34;,
                 mainTextXPos=&#34;center&#34;, mainTextYPos=&#34;center&#34;,
                 isMultiline=False, **kwargs):
        super().__init__()
        self.titleText = titleText
        self.mainText = mainText
        self.confirmText = confirmText
        self.isMultiline = isMultiline
        self.titleFont = titleFont
        self.mainFont = mainFont
        self.inputFont = inputFont
        self.confirmFont = confirmFont
        self.titleFontSize = titleFontSize
        self.mainFontSize = mainFontSize
        self.inputFontSize = inputFontSize
        self.confirmFontSize = confirmFontSize
        self.titleFontColor = titleFontColor
        self.mainFontColor = mainFontColor
        self.inputFontColor = inputFontColor
        self.confirmFontColor = confirmFontColor
        self.mainTextXPos = mainTextXPos
        self.mainTextYPos = mainTextYPos
        self.userConfirmed = False
        self.inputBtn = None
        self.okBtn = None
        for param in kwargs:
            setattr(self, param, kwargs[param])
        self.build_layout()

    def generator(self,**kwargs):
        self.make_area()
        super().generator(**kwargs)

    def build_layout(self):
        titleBtn = Button(
            text=self.titleText,
            font=self.titleFont,
            font_size=self.titleFontSize,
            font_color=self.titleFontColor
        )
        mainBtn = Button(
            text=self.mainText,
            font=self.mainFont,
            font_size=self.mainFontSize,
            font_color=self.mainFontColor,
            text_xPosition=self.mainTextXPos,
            text_yPosition=self.mainTextYPos
        )
        if self.isMultiline:
            onReturn = returnFalse
        else:
            onReturn = self.toggleConfirmation
        inputBtn = Input(
            font=self.inputFont,
            font_size=self.inputFontSize,
            font_color=self.inputFontColor,
            isMultiline=self.isMultiline,
            onReturn=onReturn
        )
        okBtn = Button(
            text=self.confirmText,
            font=self.confirmFont,
            font_size=self.confirmFontSize,
            font_color=self.confirmFontColor,
            onclickInside=self.toggleConfirmation
        )
        self.inputBtn = inputBtn
        lM = (None,1)
        layout = [
            [&#34;?*1.5&#34;, (titleBtn, &#34;?&#34;), lM],
            [&#34;?*3&#34;, (mainBtn, &#34;?&#34;), lM],
            [&#34;?*2&#34;, (inputBtn, &#34;?&#34;), lM],
            [&#34;?*1&#34;, (okBtn, &#34;?&#34;), lM]
        ]
        self.layout = layout
        return layout

    def toggleConfirmation(self, elt=None, coords=None):
            print(&#34;Toggling confirmation&#34;)
            self.userConfirmed = True

    def waitForResponse(self):
        while not self.userConfirmed:
            self.parentPSSMScreen.device.wait(0.01)
        self.parentPSSMScreen.OSKHide()
        input = self.inputBtn.getInput()
        self.userConfirmed = False  # Reset the state
        self.parentPSSMScreen.removeElt(self)
        return input</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="Python-Screen-Stack-Manager.pssm.Popup" href="#Python-Screen-Stack-Manager.pssm.Popup">Popup</a></li>
<li><a title="Python-Screen-Stack-Manager.pssm.Layout" href="#Python-Screen-Stack-Manager.pssm.Layout">Layout</a></li>
<li><a title="Python-Screen-Stack-Manager.pssm.Element" href="#Python-Screen-Stack-Manager.pssm.Element">Element</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="Python-Screen-Stack-Manager.pssm.PoputInput.build_layout"><code class="name flex">
<span>def <span class="ident">build_layout</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def build_layout(self):
    titleBtn = Button(
        text=self.titleText,
        font=self.titleFont,
        font_size=self.titleFontSize,
        font_color=self.titleFontColor
    )
    mainBtn = Button(
        text=self.mainText,
        font=self.mainFont,
        font_size=self.mainFontSize,
        font_color=self.mainFontColor,
        text_xPosition=self.mainTextXPos,
        text_yPosition=self.mainTextYPos
    )
    if self.isMultiline:
        onReturn = returnFalse
    else:
        onReturn = self.toggleConfirmation
    inputBtn = Input(
        font=self.inputFont,
        font_size=self.inputFontSize,
        font_color=self.inputFontColor,
        isMultiline=self.isMultiline,
        onReturn=onReturn
    )
    okBtn = Button(
        text=self.confirmText,
        font=self.confirmFont,
        font_size=self.confirmFontSize,
        font_color=self.confirmFontColor,
        onclickInside=self.toggleConfirmation
    )
    self.inputBtn = inputBtn
    lM = (None,1)
    layout = [
        [&#34;?*1.5&#34;, (titleBtn, &#34;?&#34;), lM],
        [&#34;?*3&#34;, (mainBtn, &#34;?&#34;), lM],
        [&#34;?*2&#34;, (inputBtn, &#34;?&#34;), lM],
        [&#34;?*1&#34;, (okBtn, &#34;?&#34;), lM]
    ]
    self.layout = layout
    return layout</code></pre>
</details>
</dd>
<dt id="Python-Screen-Stack-Manager.pssm.PoputInput.toggleConfirmation"><code class="name flex">
<span>def <span class="ident">toggleConfirmation</span></span>(<span>self, elt=None, coords=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def toggleConfirmation(self, elt=None, coords=None):
        print(&#34;Toggling confirmation&#34;)
        self.userConfirmed = True</code></pre>
</details>
</dd>
<dt id="Python-Screen-Stack-Manager.pssm.PoputInput.waitForResponse"><code class="name flex">
<span>def <span class="ident">waitForResponse</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def waitForResponse(self):
    while not self.userConfirmed:
        self.parentPSSMScreen.device.wait(0.01)
    self.parentPSSMScreen.OSKHide()
    input = self.inputBtn.getInput()
    self.userConfirmed = False  # Reset the state
    self.parentPSSMScreen.removeElt(self)
    return input</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="Python-Screen-Stack-Manager.pssm.Popup" href="#Python-Screen-Stack-Manager.pssm.Popup">Popup</a></b></code>:
<ul class="hlist">
<li><code><a title="Python-Screen-Stack-Manager.pssm.Popup.convertDimension" href="#Python-Screen-Stack-Manager.pssm.Element.convertDimension">convertDimension</a></code></li>
<li><code><a title="Python-Screen-Stack-Manager.pssm.Popup.createEltList" href="#Python-Screen-Stack-Manager.pssm.Layout.createEltList">createEltList</a></code></li>
<li><code><a title="Python-Screen-Stack-Manager.pssm.Popup.generator" href="#Python-Screen-Stack-Manager.pssm.Layout.generator">generator</a></code></li>
<li><code><a title="Python-Screen-Stack-Manager.pssm.Popup.pssmOnClickInside" href="#Python-Screen-Stack-Manager.pssm.Element.pssmOnClickInside">pssmOnClickInside</a></code></li>
<li><code><a title="Python-Screen-Stack-Manager.pssm.Popup.update" href="#Python-Screen-Stack-Manager.pssm.Element.update">update</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="Python-Screen-Stack-Manager.pssm.Rectangle"><code class="flex name class">
<span>class <span class="ident">Rectangle</span></span>
<span>(</span><span>background_color='white', outline_color='gray3', parentPSSMScreen=None)</span>
</code></dt>
<dd>
<div class="desc"><p>A rectangle</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>background_color</code></strong> :&ensp;<code>str</code></dt>
<dd>The background color</dd>
<dt><strong><code>outline_color</code></strong> :&ensp;<code>str</code></dt>
<dd>The border color</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Rectangle(Element):
    &#34;&#34;&#34;
    A rectangle
    Args:
        background_color (str): The background color
        outline_color (str): The border color
    &#34;&#34;&#34;
    def __init__(self, background_color=&#34;white&#34;, outline_color=&#34;gray3&#34;,
                 parentPSSMScreen=None):
        super().__init__()
        self.background_color = background_color
        self.outline_color = outline_color
        self.parentPSSMScreen = parentPSSMScreen

    def generator(self, area):
        [(x, y), (w, h)] = area
        self.area = area
        colorType = self.parentPSSMScreen.colorType
        img = Image.new(
            colorType,
            (w, h),
            color=get_Color(&#34;white&#34;, colorType)
        )
        rect = ImageDraw.Draw(img, colorType)
        fill_color = get_Color(self.background_color, colorType)
        outline_color = get_Color(self.outline_color, colorType)
        rect.rectangle(
            [(0, 0), (w-1, h-1)],
            fill=fill_color,
            outline=outline_color
        )
        self.imgData = img
        return self.imgData</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="Python-Screen-Stack-Manager.pssm.Element" href="#Python-Screen-Stack-Manager.pssm.Element">Element</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="Python-Screen-Stack-Manager.pssm.Element" href="#Python-Screen-Stack-Manager.pssm.Element">Element</a></b></code>:
<ul class="hlist">
<li><code><a title="Python-Screen-Stack-Manager.pssm.Element.convertDimension" href="#Python-Screen-Stack-Manager.pssm.Element.convertDimension">convertDimension</a></code></li>
<li><code><a title="Python-Screen-Stack-Manager.pssm.Element.generator" href="#Python-Screen-Stack-Manager.pssm.Element.generator">generator</a></code></li>
<li><code><a title="Python-Screen-Stack-Manager.pssm.Element.pssmOnClickInside" href="#Python-Screen-Stack-Manager.pssm.Element.pssmOnClickInside">pssmOnClickInside</a></code></li>
<li><code><a title="Python-Screen-Stack-Manager.pssm.Element.update" href="#Python-Screen-Stack-Manager.pssm.Element.update">update</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="Python-Screen-Stack-Manager.pssm.RectangleRounded"><code class="flex name class">
<span>class <span class="ident">RectangleRounded</span></span>
<span>(</span><span>radius=20, background_color='white', outline_color='gray3', parentPSSMScreen=None)</span>
</code></dt>
<dd>
<div class="desc"><p>A rectangle, but with rounded corners</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RectangleRounded(Element):
    &#34;&#34;&#34;
    A rectangle, but with rounded corners
    &#34;&#34;&#34;
    def __init__(self, radius=20, background_color=&#34;white&#34;,
                 outline_color=&#34;gray3&#34;, parentPSSMScreen=None):
        super().__init__()
        self.radius = radius
        self.background_color = background_color
        self.outline_color = outline_color
        self.parentPSSMScreen = parentPSSMScreen

    def generator(self, area):
        [(x, y), (w, h)] = area
        self.area = area
        colorType = self.parentPSSMScreen.colorType
        rectangle = Image.new(
            colorType,
            (w, h),
            color=get_Color(&#34;white&#34;, colorType)
        )
        draw = ImageDraw.Draw(rectangle)
        draw.rectangle(
            [(0, 0), (w, h)],
            fill=get_Color(self.background_color, colorType),
            outline=get_Color(self.outline_color, colorType)
        )
        draw.line(
            [(self.radius, h-1), (w-self.radius, h-1)],
            fill=get_Color(self.outline_color, colorType),
            width=1
        )
        draw.line(
            [(w-1, self.radius), (w-1, h-self.radius)],
            fill=get_Color(self.outline_color, colorType),
            width=1
        )
        corner = roundedCorner(
            self.radius,
            self.background_color,
            self.outline_color,
            self.parentPSSMScreen.colorType
        )
        rectangle.paste(corner, (0, 0))
        # Rotate the corner and paste it
        rectangle.paste(corner.rotate(90), (0, h - self.radius))
        rectangle.paste(corner.rotate(180), (w - self.radius, h - self.radius))
        rectangle.paste(corner.rotate(270), (w - self.radius, 0))
        self.imgData = rectangle
        return self.imgData</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="Python-Screen-Stack-Manager.pssm.Element" href="#Python-Screen-Stack-Manager.pssm.Element">Element</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="Python-Screen-Stack-Manager.pssm.Element" href="#Python-Screen-Stack-Manager.pssm.Element">Element</a></b></code>:
<ul class="hlist">
<li><code><a title="Python-Screen-Stack-Manager.pssm.Element.convertDimension" href="#Python-Screen-Stack-Manager.pssm.Element.convertDimension">convertDimension</a></code></li>
<li><code><a title="Python-Screen-Stack-Manager.pssm.Element.generator" href="#Python-Screen-Stack-Manager.pssm.Element.generator">generator</a></code></li>
<li><code><a title="Python-Screen-Stack-Manager.pssm.Element.pssmOnClickInside" href="#Python-Screen-Stack-Manager.pssm.Element.pssmOnClickInside">pssmOnClickInside</a></code></li>
<li><code><a title="Python-Screen-Stack-Manager.pssm.Element.update" href="#Python-Screen-Stack-Manager.pssm.Element.update">update</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="Python-Screen-Stack-Manager.pssm.Static"><code class="flex name class">
<span>class <span class="ident">Static</span></span>
<span>(</span><span>pil_image, centered=True, resize=True, background_color='white', rotation=0, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>A very simple element which only displays a pillow image</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>pil_image</code></strong> :&ensp;<code>str</code> or <code>pil image</code></dt>
<dd>path to an image or a pillow image</dd>
<dt><strong><code>centered</code></strong> :&ensp;<code>bool</code></dt>
<dd>Center the image ?</dd>
<dt><strong><code>resize</code></strong> :&ensp;<code>bool</code></dt>
<dd>Make it fit the area ? (proportions are respected)</dd>
<dt><strong><code>rotation</code></strong> :&ensp;<code>int</code></dt>
<dd>an integer rotation angle</dd>
<dt><strong><code>background_color</code></strong> :&ensp;<code>str</code></dt>
<dd>"white", "black", "gray0" to "gray15" or a
(red, green, blue, transparency) tuple</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Static(Element):
    &#34;&#34;&#34;
    A very simple element which only displays a pillow image
    Args:
        pil_image (str or pil image): path to an image or a pillow image
        centered (bool): Center the image ?
        resize (bool): Make it fit the area ? (proportions are respected)
        rotation (int): an integer rotation angle
        background_color (str): &#34;white&#34;, &#34;black&#34;, &#34;gray0&#34; to &#34;gray15&#34; or a
            (red, green, blue, transparency) tuple
    &#34;&#34;&#34;
    def __init__(self, pil_image, centered=True, resize=True,
                 background_color=&#34;white&#34;, rotation=0, **kwargs):
        super().__init__()
        if isinstance(pil_image, str):
            self.pil_image = Image.open(pil_image)
        else:
            self.pil_image = pil_image
        self.background_color = background_color
        self.centered = centered
        self.resize = resize
        self.rotation = rotation
        for param in kwargs:
            setattr(self, param, kwargs[param])

    def generator(self, area=None):
        # TODO : crop or resize the image to make it fit the area
        (x, y), (w, h) = area
        colorType = self.parentPSSMScreen.colorType
        pil_image = self.pil_image.convert(colorType)
        if self.resize:
            r = min(w/pil_image.width, h/pil_image.height)
            size = (int(pil_image.width*r), int(pil_image.height*r))
            pil_image = self.pil_image.resize(size)
        if self.rotation != 0:
            pil_image = pil_image.rotate(self.rotation,
                                         fillcolor=self.background_color)
        if not self.centered:
            return pil_image
        else:
            img = Image.new(
                colorType,
                (w+1, h+1),
                color=get_Color(self.background_color, colorType)
            )
            x = int(0.5*w-0.5*pil_image.width)
            y = int(0.5*h-0.5*pil_image.height)
            img.paste(pil_image, (x, y))
            self.imgData = img
            return img</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="Python-Screen-Stack-Manager.pssm.Element" href="#Python-Screen-Stack-Manager.pssm.Element">Element</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="Python-Screen-Stack-Manager.pssm.Element" href="#Python-Screen-Stack-Manager.pssm.Element">Element</a></b></code>:
<ul class="hlist">
<li><code><a title="Python-Screen-Stack-Manager.pssm.Element.convertDimension" href="#Python-Screen-Stack-Manager.pssm.Element.convertDimension">convertDimension</a></code></li>
<li><code><a title="Python-Screen-Stack-Manager.pssm.Element.generator" href="#Python-Screen-Stack-Manager.pssm.Element.generator">generator</a></code></li>
<li><code><a title="Python-Screen-Stack-Manager.pssm.Element.pssmOnClickInside" href="#Python-Screen-Stack-Manager.pssm.Element.pssmOnClickInside">pssmOnClickInside</a></code></li>
<li><code><a title="Python-Screen-Stack-Manager.pssm.Element.update" href="#Python-Screen-Stack-Manager.pssm.Element.update">update</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="Python-Screen-Stack-Manager" href="index.html">Python-Screen-Stack-Manager</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="Python-Screen-Stack-Manager.pssm.Button" href="#Python-Screen-Stack-Manager.pssm.Button">Button</a></code></h4>
<ul class="">
<li><code><a title="Python-Screen-Stack-Manager.pssm.Button.wrapText" href="#Python-Screen-Stack-Manager.pssm.Button.wrapText">wrapText</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="Python-Screen-Stack-Manager.pssm.ButtonList" href="#Python-Screen-Stack-Manager.pssm.ButtonList">ButtonList</a></code></h4>
<ul class="">
<li><code><a title="Python-Screen-Stack-Manager.pssm.ButtonList.build_layoutFromButtons" href="#Python-Screen-Stack-Manager.pssm.ButtonList.build_layoutFromButtons">build_layoutFromButtons</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="Python-Screen-Stack-Manager.pssm.Element" href="#Python-Screen-Stack-Manager.pssm.Element">Element</a></code></h4>
<ul class="">
<li><code><a title="Python-Screen-Stack-Manager.pssm.Element.convertDimension" href="#Python-Screen-Stack-Manager.pssm.Element.convertDimension">convertDimension</a></code></li>
<li><code><a title="Python-Screen-Stack-Manager.pssm.Element.generator" href="#Python-Screen-Stack-Manager.pssm.Element.generator">generator</a></code></li>
<li><code><a title="Python-Screen-Stack-Manager.pssm.Element.pssmOnClickInside" href="#Python-Screen-Stack-Manager.pssm.Element.pssmOnClickInside">pssmOnClickInside</a></code></li>
<li><code><a title="Python-Screen-Stack-Manager.pssm.Element.update" href="#Python-Screen-Stack-Manager.pssm.Element.update">update</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="Python-Screen-Stack-Manager.pssm.Icon" href="#Python-Screen-Stack-Manager.pssm.Icon">Icon</a></code></h4>
</li>
<li>
<h4><code><a title="Python-Screen-Stack-Manager.pssm.Input" href="#Python-Screen-Stack-Manager.pssm.Input">Input</a></code></h4>
<ul class="">
<li><code><a title="Python-Screen-Stack-Manager.pssm.Input.getInput" href="#Python-Screen-Stack-Manager.pssm.Input.getInput">getInput</a></code></li>
<li><code><a title="Python-Screen-Stack-Manager.pssm.Input.onKeyPress" href="#Python-Screen-Stack-Manager.pssm.Input.onKeyPress">onKeyPress</a></code></li>
<li><code><a title="Python-Screen-Stack-Manager.pssm.Input.setCursorPosition" href="#Python-Screen-Stack-Manager.pssm.Input.setCursorPosition">setCursorPosition</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="Python-Screen-Stack-Manager.pssm.Layout" href="#Python-Screen-Stack-Manager.pssm.Layout">Layout</a></code></h4>
<ul class="">
<li><code><a title="Python-Screen-Stack-Manager.pssm.Layout.createEltList" href="#Python-Screen-Stack-Manager.pssm.Layout.createEltList">createEltList</a></code></li>
<li><code><a title="Python-Screen-Stack-Manager.pssm.Layout.isLayoutValid" href="#Python-Screen-Stack-Manager.pssm.Layout.isLayoutValid">isLayoutValid</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="Python-Screen-Stack-Manager.pssm.Line" href="#Python-Screen-Stack-Manager.pssm.Line">Line</a></code></h4>
</li>
<li>
<h4><code><a title="Python-Screen-Stack-Manager.pssm.OSK" href="#Python-Screen-Stack-Manager.pssm.OSK">OSK</a></code></h4>
<ul class="">
<li><code><a title="Python-Screen-Stack-Manager.pssm.OSK.build_layout" href="#Python-Screen-Stack-Manager.pssm.OSK.build_layout">build_layout</a></code></li>
<li><code><a title="Python-Screen-Stack-Manager.pssm.OSK.generator" href="#Python-Screen-Stack-Manager.pssm.OSK.generator">generator</a></code></li>
<li><code><a title="Python-Screen-Stack-Manager.pssm.OSK.getKeyLabel" href="#Python-Screen-Stack-Manager.pssm.OSK.getKeyLabel">getKeyLabel</a></code></li>
<li><code><a title="Python-Screen-Stack-Manager.pssm.OSK.handleKeyPress" href="#Python-Screen-Stack-Manager.pssm.OSK.handleKeyPress">handleKeyPress</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="Python-Screen-Stack-Manager.pssm.PSSMScreen" href="#Python-Screen-Stack-Manager.pssm.PSSMScreen">PSSMScreen</a></code></h4>
<ul class="two-column">
<li><code><a title="Python-Screen-Stack-Manager.pssm.PSSMScreen.OSKHide" href="#Python-Screen-Stack-Manager.pssm.PSSMScreen.OSKHide">OSKHide</a></code></li>
<li><code><a title="Python-Screen-Stack-Manager.pssm.PSSMScreen.OSKInit" href="#Python-Screen-Stack-Manager.pssm.PSSMScreen.OSKInit">OSKInit</a></code></li>
<li><code><a title="Python-Screen-Stack-Manager.pssm.PSSMScreen.OSKShow" href="#Python-Screen-Stack-Manager.pssm.PSSMScreen.OSKShow">OSKShow</a></code></li>
<li><code><a title="Python-Screen-Stack-Manager.pssm.PSSMScreen.addElt" href="#Python-Screen-Stack-Manager.pssm.PSSMScreen.addElt">addElt</a></code></li>
<li><code><a title="Python-Screen-Stack-Manager.pssm.PSSMScreen.capture" href="#Python-Screen-Stack-Manager.pssm.PSSMScreen.capture">capture</a></code></li>
<li><code><a title="Python-Screen-Stack-Manager.pssm.PSSMScreen.clear" href="#Python-Screen-Stack-Manager.pssm.PSSMScreen.clear">clear</a></code></li>
<li><code><a title="Python-Screen-Stack-Manager.pssm.PSSMScreen.findEltWithId" href="#Python-Screen-Stack-Manager.pssm.PSSMScreen.findEltWithId">findEltWithId</a></code></li>
<li><code><a title="Python-Screen-Stack-Manager.pssm.PSSMScreen.getStackLevel" href="#Python-Screen-Stack-Manager.pssm.PSSMScreen.getStackLevel">getStackLevel</a></code></li>
<li><code><a title="Python-Screen-Stack-Manager.pssm.PSSMScreen.invert" href="#Python-Screen-Stack-Manager.pssm.PSSMScreen.invert">invert</a></code></li>
<li><code><a title="Python-Screen-Stack-Manager.pssm.PSSMScreen.invertElt" href="#Python-Screen-Stack-Manager.pssm.PSSMScreen.invertElt">invertElt</a></code></li>
<li><code><a title="Python-Screen-Stack-Manager.pssm.PSSMScreen.printStack" href="#Python-Screen-Stack-Manager.pssm.PSSMScreen.printStack">printStack</a></code></li>
<li><code><a title="Python-Screen-Stack-Manager.pssm.PSSMScreen.refresh" href="#Python-Screen-Stack-Manager.pssm.PSSMScreen.refresh">refresh</a></code></li>
<li><code><a title="Python-Screen-Stack-Manager.pssm.PSSMScreen.removeElt" href="#Python-Screen-Stack-Manager.pssm.PSSMScreen.removeElt">removeElt</a></code></li>
<li><code><a title="Python-Screen-Stack-Manager.pssm.PSSMScreen.setStackLevel" href="#Python-Screen-Stack-Manager.pssm.PSSMScreen.setStackLevel">setStackLevel</a></code></li>
<li><code><a title="Python-Screen-Stack-Manager.pssm.PSSMScreen.simplePrintElt" href="#Python-Screen-Stack-Manager.pssm.PSSMScreen.simplePrintElt">simplePrintElt</a></code></li>
<li><code><a title="Python-Screen-Stack-Manager.pssm.PSSMScreen.startBatchWriting" href="#Python-Screen-Stack-Manager.pssm.PSSMScreen.startBatchWriting">startBatchWriting</a></code></li>
<li><code><a title="Python-Screen-Stack-Manager.pssm.PSSMScreen.startListenerThread" href="#Python-Screen-Stack-Manager.pssm.PSSMScreen.startListenerThread">startListenerThread</a></code></li>
<li><code><a title="Python-Screen-Stack-Manager.pssm.PSSMScreen.stopBatchWriting" href="#Python-Screen-Stack-Manager.pssm.PSSMScreen.stopBatchWriting">stopBatchWriting</a></code></li>
<li><code><a title="Python-Screen-Stack-Manager.pssm.PSSMScreen.stopListenerThread" href="#Python-Screen-Stack-Manager.pssm.PSSMScreen.stopListenerThread">stopListenerThread</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="Python-Screen-Stack-Manager.pssm.Popup" href="#Python-Screen-Stack-Manager.pssm.Popup">Popup</a></code></h4>
<ul class="">
<li><code><a title="Python-Screen-Stack-Manager.pssm.Popup.make_area" href="#Python-Screen-Stack-Manager.pssm.Popup.make_area">make_area</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="Python-Screen-Stack-Manager.pssm.PopupConfirm" href="#Python-Screen-Stack-Manager.pssm.PopupConfirm">PopupConfirm</a></code></h4>
<ul class="">
<li><code><a title="Python-Screen-Stack-Manager.pssm.PopupConfirm.build_layout" href="#Python-Screen-Stack-Manager.pssm.PopupConfirm.build_layout">build_layout</a></code></li>
<li><code><a title="Python-Screen-Stack-Manager.pssm.PopupConfirm.cancel" href="#Python-Screen-Stack-Manager.pssm.PopupConfirm.cancel">cancel</a></code></li>
<li><code><a title="Python-Screen-Stack-Manager.pssm.PopupConfirm.confirm" href="#Python-Screen-Stack-Manager.pssm.PopupConfirm.confirm">confirm</a></code></li>
<li><code><a title="Python-Screen-Stack-Manager.pssm.PopupConfirm.waitForResponse" href="#Python-Screen-Stack-Manager.pssm.PopupConfirm.waitForResponse">waitForResponse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="Python-Screen-Stack-Manager.pssm.PoputInput" href="#Python-Screen-Stack-Manager.pssm.PoputInput">PoputInput</a></code></h4>
<ul class="">
<li><code><a title="Python-Screen-Stack-Manager.pssm.PoputInput.build_layout" href="#Python-Screen-Stack-Manager.pssm.PoputInput.build_layout">build_layout</a></code></li>
<li><code><a title="Python-Screen-Stack-Manager.pssm.PoputInput.toggleConfirmation" href="#Python-Screen-Stack-Manager.pssm.PoputInput.toggleConfirmation">toggleConfirmation</a></code></li>
<li><code><a title="Python-Screen-Stack-Manager.pssm.PoputInput.waitForResponse" href="#Python-Screen-Stack-Manager.pssm.PoputInput.waitForResponse">waitForResponse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="Python-Screen-Stack-Manager.pssm.Rectangle" href="#Python-Screen-Stack-Manager.pssm.Rectangle">Rectangle</a></code></h4>
</li>
<li>
<h4><code><a title="Python-Screen-Stack-Manager.pssm.RectangleRounded" href="#Python-Screen-Stack-Manager.pssm.RectangleRounded">RectangleRounded</a></code></h4>
</li>
<li>
<h4><code><a title="Python-Screen-Stack-Manager.pssm.Static" href="#Python-Screen-Stack-Manager.pssm.Static">Static</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.1</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>